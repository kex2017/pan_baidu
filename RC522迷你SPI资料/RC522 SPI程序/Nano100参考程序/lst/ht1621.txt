; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\ht1621.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ht1621.d --feedback=.\obj\START_KIT.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Libraries -I.\Include -I.\Users -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -D__MICROLIB -D__LCDDISPLAY_BTL001_LB_H --omf_browse=.\obj\ht1621.crf Users\ht1621.c]
                          THUMB

                          AREA ||i.Clear_All||, CODE, READONLY, ALIGN=2

                  Clear_All PROC
;;;178    **********************************************************************/
;;;179    void Clear_All(void)
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181    	unsigned char i;
;;;182    	
;;;183    	for(i=0;i<13;i++)
000002  2400              MOVS     r4,#0
000004  e004              B        |L1.16|
                  |L1.6|
;;;184    	{
;;;185    		DISP_BUF[i] = 0;
000006  2000              MOVS     r0,#0
000008  4904              LDR      r1,|L1.28|
00000a  5508              STRB     r0,[r1,r4]
00000c  1c60              ADDS     r0,r4,#1              ;183
00000e  b2c4              UXTB     r4,r0                 ;183
                  |L1.16|
000010  2c0d              CMP      r4,#0xd               ;183
000012  dbf8              BLT      |L1.6|
;;;186    	}
;;;187    	Display(DISP_BUF);
000014  4801              LDR      r0,|L1.28|
000016  f7fffffe          BL       Display
;;;188    } 
00001a  bd10              POP      {r4,pc}
;;;189    
                          ENDP

                  |L1.28|
                          DCD      DISP_BUF

                          AREA ||i.Delay_10_uS||, CODE, READONLY, ALIGN=1

                  Delay_10_uS PROC
;;;21     
;;;22     void Delay_10_uS(void)
000000  2032              MOVS     r0,#0x32
;;;23     {
;;;24     	unsigned char i;
;;;25     	for (i = 50; i > 0; i--);
000002  e001              B        |L2.8|
                  |L2.4|
000004  1e41              SUBS     r1,r0,#1
000006  b2c8              UXTB     r0,r1
                  |L2.8|
000008  2800              CMP      r0,#0
00000a  dcfb              BGT      |L2.4|
;;;26     }
00000c  4770              BX       lr
;;;27     
                          ENDP


                          AREA ||i.DispInit||, CODE, READONLY, ALIGN=2

                  DispInit PROC
;;;191    //*************************显示全8****************************
;;;192    void DispInit(void)
000000  b510              PUSH     {r4,lr}
;;;193    {
;;;194    	memset(DISP_BUF, 0, 13);	
000002  210d              MOVS     r1,#0xd
000004  4821              LDR      r0,|L3.140|
000006  f7fffffe          BL       __aeabi_memclr
;;;195    
;;;196    	DISP_BUF[0] = (DISP_BUF[0] & 0xF0) + (NumCode[8] >> 4);
00000a  4820              LDR      r0,|L3.140|
00000c  7800              LDRB     r0,[r0,#0]  ; DISP_BUF
00000e  21f0              MOVS     r1,#0xf0
000010  4008              ANDS     r0,r0,r1
000012  491f              LDR      r1,|L3.144|
000014  7a09              LDRB     r1,[r1,#8]  ; NumCode
000016  1109              ASRS     r1,r1,#4
000018  1840              ADDS     r0,r0,r1
00001a  491c              LDR      r1,|L3.140|
00001c  7008              STRB     r0,[r1,#0]
;;;197    	DISP_BUF[1] = (NumCode[8] << 4) + (NumCode[8] >> 4);
00001e  481c              LDR      r0,|L3.144|
000020  7a00              LDRB     r0,[r0,#8]  ; NumCode
000022  0100              LSLS     r0,r0,#4
000024  491a              LDR      r1,|L3.144|
000026  7a09              LDRB     r1,[r1,#8]  ; NumCode
000028  1109              ASRS     r1,r1,#4
00002a  1840              ADDS     r0,r0,r1
00002c  4917              LDR      r1,|L3.140|
00002e  7048              STRB     r0,[r1,#1]
;;;198    	DISP_BUF[2] = (NumCode[8] << 4) + (NumCode[8] >> 4);
000030  4817              LDR      r0,|L3.144|
000032  7a00              LDRB     r0,[r0,#8]  ; NumCode
000034  0100              LSLS     r0,r0,#4
000036  4916              LDR      r1,|L3.144|
000038  7a09              LDRB     r1,[r1,#8]  ; NumCode
00003a  1109              ASRS     r1,r1,#4
00003c  1840              ADDS     r0,r0,r1
00003e  4913              LDR      r1,|L3.140|
000040  7088              STRB     r0,[r1,#2]
;;;199    	DISP_BUF[3] = (NumCode[8] << 4) + (NumCode[8] >> 4);
000042  4813              LDR      r0,|L3.144|
000044  7a00              LDRB     r0,[r0,#8]  ; NumCode
000046  0100              LSLS     r0,r0,#4
000048  4911              LDR      r1,|L3.144|
00004a  7a09              LDRB     r1,[r1,#8]  ; NumCode
00004c  1109              ASRS     r1,r1,#4
00004e  1840              ADDS     r0,r0,r1
000050  490e              LDR      r1,|L3.140|
000052  70c8              STRB     r0,[r1,#3]
;;;200    	DISP_BUF[4] = (NumCode[8] << 4) + (NumCode[8] >> 4);
000054  480e              LDR      r0,|L3.144|
000056  7a00              LDRB     r0,[r0,#8]  ; NumCode
000058  0100              LSLS     r0,r0,#4
00005a  490d              LDR      r1,|L3.144|
00005c  7a09              LDRB     r1,[r1,#8]  ; NumCode
00005e  1109              ASRS     r1,r1,#4
000060  1840              ADDS     r0,r0,r1
000062  490a              LDR      r1,|L3.140|
000064  7108              STRB     r0,[r1,#4]
;;;201    	DISP_BUF[5] = (NumCode[8] << 4) + (NumCode[8] >> 4);
000066  480a              LDR      r0,|L3.144|
000068  7a00              LDRB     r0,[r0,#8]  ; NumCode
00006a  0100              LSLS     r0,r0,#4
00006c  4908              LDR      r1,|L3.144|
00006e  7a09              LDRB     r1,[r1,#8]  ; NumCode
000070  1109              ASRS     r1,r1,#4
000072  1840              ADDS     r0,r0,r1
000074  4905              LDR      r1,|L3.140|
000076  7148              STRB     r0,[r1,#5]
;;;202    	DISP_BUF[6] = (NumCode[8] << 4);
000078  4805              LDR      r0,|L3.144|
00007a  7a00              LDRB     r0,[r0,#8]  ; NumCode
00007c  0700              LSLS     r0,r0,#28
00007e  0e00              LSRS     r0,r0,#24
000080  7188              STRB     r0,[r1,#6]
;;;203        
;;;204     	Display(DISP_BUF);
000082  4608              MOV      r0,r1
000084  f7fffffe          BL       Display
;;;205    }
000088  bd10              POP      {r4,pc}
;;;206    
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
                          DCD      DISP_BUF
                  |L3.144|
                          DCD      NumCode

                          AREA ||i.Disp_All||, CODE, READONLY, ALIGN=2

                  Disp_All PROC
;;;164    **********************************************************************/
;;;165    void Disp_All(void)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167    	unsigned char i;
;;;168    	
;;;169    	for(i=0;i<15;i++)
000002  2400              MOVS     r4,#0
000004  e004              B        |L4.16|
                  |L4.6|
;;;170    	{
;;;171    		DISP_BUF[i] = 0xFF;
000006  20ff              MOVS     r0,#0xff
000008  4904              LDR      r1,|L4.28|
00000a  5508              STRB     r0,[r1,r4]
00000c  1c60              ADDS     r0,r4,#1              ;169
00000e  b2c4              UXTB     r4,r0                 ;169
                  |L4.16|
000010  2c0f              CMP      r4,#0xf               ;169
000012  dbf8              BLT      |L4.6|
;;;172    	}
;;;173    	Display(DISP_BUF);
000014  4801              LDR      r0,|L4.28|
000016  f7fffffe          BL       Display
;;;174    }
00001a  bd10              POP      {r4,pc}
;;;175    
                          ENDP

                  |L4.28|
                          DCD      DISP_BUF

                          AREA ||i.Display||, CODE, READONLY, ALIGN=1

                  Display PROC
;;;88     **********************************************************************/
;;;89     void Display(unsigned char *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;90     {
000002  4605              MOV      r5,r0
;;;91     	unsigned char i;
;;;92     	
;;;93     	SENDCOMB(0x00); 
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       SENDCOMB
;;;94     	for (i=0;i<15;i++)
00000a  2400              MOVS     r4,#0
00000c  e004              B        |L5.24|
                  |L5.14|
;;;95     	{
;;;96     		SendByte(buf[i]); 
00000e  5d28              LDRB     r0,[r5,r4]
000010  f7fffffe          BL       SendByte
000014  1c60              ADDS     r0,r4,#1              ;94
000016  b2c4              UXTB     r4,r0                 ;94
                  |L5.24|
000018  2c0f              CMP      r4,#0xf               ;94
00001a  dbf8              BLT      |L5.14|
;;;97     	}
;;;98     }
00001c  bd70              POP      {r4-r6,pc}
;;;99     
                          ENDP


                          AREA ||i.GPIO_ClrBit||, CODE, READONLY, ALIGN=1

                  GPIO_ClrBit PROC
;;;102      */
;;;103    static __INLINE void GPIO_ClrBit(GPIO_TypeDef *port, uint32_t bit)
000000  6882              LDR      r2,[r0,#8]
;;;104    {
;;;105    	port->DOUT &= ~(1 << bit);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  439a              BICS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;106    }
00000a  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.GPIO_SetBit||, CODE, READONLY, ALIGN=1

                  GPIO_SetBit PROC
;;;80       */
;;;81     static __INLINE void GPIO_SetBit(GPIO_TypeDef *port, uint32_t bit)
000000  6882              LDR      r2,[r0,#8]
;;;82     {
;;;83     	port->DOUT |= (1 << bit);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  431a              ORRS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;84     }
00000a  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.LCD_INIT||, CODE, READONLY, ALIGN=2

                  LCD_INIT PROC
;;;120    
;;;121    void LCD_INIT(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123    	CLS_HT_PWR();										//打开LCD电源
000002  210c              MOVS     r1,#0xc
000004  480c              LDR      r0,|L8.56|
000006  f7fffffe          BL       GPIO_ClrBit
;;;124    	SET_HT_RD();
00000a  210d              MOVS     r1,#0xd
00000c  480a              LDR      r0,|L8.56|
00000e  3840              SUBS     r0,r0,#0x40
000010  f7fffffe          BL       GPIO_SetBit
;;;125    	delay1s();
000014  f7fffffe          BL       delay1s
;;;126        SENDCOMA(BIAS); 									//设置偏压,背极数
000018  2052              MOVS     r0,#0x52
00001a  f7fffffe          BL       SENDCOMA
;;;127        SENDCOMA(RC256); 									//设为内晶振256K
00001e  2030              MOVS     r0,#0x30
000020  f7fffffe          BL       SENDCOMA
;;;128        SENDCOMA(SYSEN); 									//启动振荡器
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       SENDCOMA
;;;129        SENDCOMA(LCDON); 									//显示使能
00002a  2006              MOVS     r0,#6
00002c  f7fffffe          BL       SENDCOMA
;;;130        SENDCOMA(TIMERDIS); 								//禁止时基输出
000030  2008              MOVS     r0,#8
000032  f7fffffe          BL       SENDCOMA
;;;131    }
000036  bd10              POP      {r4,pc}
;;;132    /*
                          ENDP

                  |L8.56|
                          DCD      0x50004040

                          AREA ||i.SENDCOMA||, CODE, READONLY, ALIGN=1

                  SENDCOMA PROC
;;;53     *********************************************************************/
;;;54     void SENDCOMA(unsigned char com)
000000  b510              PUSH     {r4,lr}
;;;55     {
000002  4604              MOV      r4,r0
;;;56     	Start_spi();
000004  f7fffffe          BL       Start_spi
;;;57     	SendBit(0X80,4); 													//发送设置命令ID=100 0
000008  2104              MOVS     r1,#4
00000a  2080              MOVS     r0,#0x80
00000c  f7fffffe          BL       SendBit
;;;58     	SendByte(com); 														//发送命令字
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SendByte
;;;59     }
000016  bd10              POP      {r4,pc}
;;;60     
                          ENDP


                          AREA ||i.SENDCOMB||, CODE, READONLY, ALIGN=1

                  SENDCOMB PROC
;;;65     *********************************************************************/
;;;66     void SENDCOMB(unsigned char adr)
000000  b510              PUSH     {r4,lr}
;;;67     {
000002  4604              MOV      r4,r0
;;;68     	Start_spi();
000004  f7fffffe          BL       Start_spi
;;;69     	SendBit(0XA0,4); 													//发送写显示RAM 命令ID=101 0
000008  2104              MOVS     r1,#4
00000a  20a0              MOVS     r0,#0xa0
00000c  f7fffffe          BL       SendBit
;;;70     	SendBit(adr,5); 													//指定写入地址
000010  2105              MOVS     r1,#5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       SendBit
;;;71     }
000018  bd10              POP      {r4,pc}
;;;72     
                          ENDP


                          AREA ||i.SendBit||, CODE, READONLY, ALIGN=2

                  SendBit PROC
;;;99     
;;;100    void SendBit(unsigned char dat, unsigned char bitcnt)
000000  b570              PUSH     {r4-r6,lr}
;;;101    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;102    	unsigned char i;
;;;103    
;;;104    	for(i=0;i<bitcnt;i++)
000006  2600              MOVS     r6,#0
000008  e01b              B        |L11.66|
                  |L11.10|
;;;105    	{
;;;106    		if(( dat & 0X80 ) == 0)		CLS_HT_DATA();
00000a  2080              MOVS     r0,#0x80
00000c  4204              TST      r4,r0
00000e  d104              BNE      |L11.26|
000010  210f              MOVS     r1,#0xf
000012  480d              LDR      r0,|L11.72|
000014  f7fffffe          BL       GPIO_ClrBit
000018  e003              B        |L11.34|
                  |L11.26|
;;;107    		else		SET_HT_DATA(); 						//发送数据由高位到低位传送
00001a  210f              MOVS     r1,#0xf
00001c  480a              LDR      r0,|L11.72|
00001e  f7fffffe          BL       GPIO_SetBit
                  |L11.34|
;;;108    		Delay_10_uS();
000022  f7fffffe          BL       Delay_10_uS
;;;109    		SET_HT_WR(); 									//置时钟线为高通知被控器开始接收数位
000026  210e              MOVS     r1,#0xe
000028  4807              LDR      r0,|L11.72|
00002a  f7fffffe          BL       GPIO_SetBit
;;;110    		Delay_10_uS();
00002e  f7fffffe          BL       Delay_10_uS
;;;111    		CLS_HT_WR(); 									//钳住总线准备下一个数据位
000032  210e              MOVS     r1,#0xe
000034  4804              LDR      r0,|L11.72|
000036  f7fffffe          BL       GPIO_ClrBit
;;;112    		dat=dat<<1; 									//发送数据左移一位
00003a  0660              LSLS     r0,r4,#25
00003c  0e04              LSRS     r4,r0,#24
00003e  1c70              ADDS     r0,r6,#1              ;104
000040  b2c6              UXTB     r6,r0                 ;104
                  |L11.66|
000042  42ae              CMP      r6,r5                 ;104
000044  dbe1              BLT      |L11.10|
;;;113    	}
;;;114    }
000046  bd70              POP      {r4-r6,pc}
;;;115    
                          ENDP

                  |L11.72|
                          DCD      0x50004000

                          AREA ||i.SendByte||, CODE, READONLY, ALIGN=1

                  SendByte PROC
;;;115    
;;;116    void SendByte(unsigned char dat)
000000  b510              PUSH     {r4,lr}
;;;117    {
000002  4604              MOV      r4,r0
;;;118    	SendBit(dat,8); 									//发送字节
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SendBit
;;;119    }
00000c  bd10              POP      {r4,pc}
;;;120    
                          ENDP


                          AREA ||i.Start_spi||, CODE, READONLY, ALIGN=2

                  Start_spi PROC
;;;37     
;;;38     void Start_spi(void)
000000  b510              PUSH     {r4,lr}
;;;39     {
;;;40     	SET_HT_CS();
000002  210c              MOVS     r1,#0xc
000004  480e              LDR      r0,|L13.64|
000006  f7fffffe          BL       GPIO_SetBit
;;;41     	SET_HT_WR();
00000a  210e              MOVS     r1,#0xe
00000c  480c              LDR      r0,|L13.64|
00000e  f7fffffe          BL       GPIO_SetBit
;;;42     	SET_HT_DATA();
000012  210f              MOVS     r1,#0xf
000014  480a              LDR      r0,|L13.64|
000016  f7fffffe          BL       GPIO_SetBit
;;;43     	Delay_10_uS();
00001a  f7fffffe          BL       Delay_10_uS
;;;44     	CLS_HT_CS();
00001e  210c              MOVS     r1,#0xc
000020  4807              LDR      r0,|L13.64|
000022  f7fffffe          BL       GPIO_ClrBit
;;;45     	CLS_HT_CS();
000026  210c              MOVS     r1,#0xc
000028  4805              LDR      r0,|L13.64|
00002a  f7fffffe          BL       GPIO_ClrBit
;;;46     	CLS_HT_WR();
00002e  210e              MOVS     r1,#0xe
000030  4803              LDR      r0,|L13.64|
000032  f7fffffe          BL       GPIO_ClrBit
;;;47     	CLS_HT_WR();
000036  210e              MOVS     r1,#0xe
000038  4801              LDR      r0,|L13.64|
00003a  f7fffffe          BL       GPIO_ClrBit
;;;48     }
00003e  bd10              POP      {r4,pc}
;;;49     
                          ENDP

                  |L13.64|
                          DCD      0x50004000

                          AREA ||i.delay1s||, CODE, READONLY, ALIGN=2

                  delay1s PROC
;;;27     
;;;28     void delay1s(void)
000000  200a              MOVS     r0,#0xa
;;;29     {
;;;30     	unsigned int i, j;
;;;31     
;;;32     	for (j = 10; j > 0; j--)
000002  e005              B        |L14.16|
                  |L14.4|
;;;33     		for (i = 60000; i > 0; i--);
000004  4904              LDR      r1,|L14.24|
000006  e000              B        |L14.10|
                  |L14.8|
000008  1e49              SUBS     r1,r1,#1
                  |L14.10|
00000a  2900              CMP      r1,#0
00000c  d1fc              BNE      |L14.8|
00000e  1e40              SUBS     r0,r0,#1              ;32
                  |L14.16|
000010  2800              CMP      r0,#0                 ;32
000012  d1f7              BNE      |L14.4|
;;;34     }
000014  4770              BX       lr
;;;35     
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x0000ea60

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  DISP_BUF
                          %        13
                  lcd_buf
                          %        17

                          AREA ||.data||, DATA, ALIGN=0

                  NumCode
000000  f505d397          DCB      0xf5,0x05,0xd3,0x97
000004  27b6f615          DCB      0x27,0xb6,0xf6,0x15
000008  f7b77700          DCB      0xf7,0xb7,0x77,0x00
00000c  6e00f200          DCB      0x6e,0x00,0xf2,0x00
000010  73b602e5          DCB      0x73,0xb6,0x02,0xe5

;*** Start embedded assembler ***

#line 1 "Users\\ht1621.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_ht1621_c_NumCode____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_ht1621_c_NumCode____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_ht1621_c_NumCode____REVSH|
#line 144
|__asm___8_ht1621_c_NumCode____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
