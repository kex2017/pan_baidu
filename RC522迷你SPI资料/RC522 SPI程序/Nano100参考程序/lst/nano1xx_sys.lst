L 1 "Libraries\nano1xx_sys.c"
N/******************************************************************************
N * @file     nano1xx_sys.c
N * @brief    NANO1xx SYS driver source file
N * @version  1.0.1
N * @date     04, September, 2012
N *
N * @note
N * Copyright (C) 2012-2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#include <stdio.h>
L 1 "D:\Keil\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 11 "Libraries\nano1xx_sys.c" 2
N#include "nano1xx_sys.h"
L 1 ".\Include\nano1xx_sys.h" 1
N/******************************************************************************
N * @file     nano1xx_sys.h
N * @brief    NANO1xx SYS driver header file
N *           Defines constants, inline functions, function prototypes for GCR
N *           and clock control.
N * @version  1.0.1
N * @date     04, September, 2012
N *
N * @note
N * Copyright (C) 2012-2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __NANO1XX_SYS_H
N#define __NANO1XX_SYS_H
N
N#include "nano1xx.h"
L 1 ".\Include\nano1xx.h" 1
N/******************************************************************************
N * @file     nano1xx.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File for
N *           NANO1xx devices
N * @version  1.0.1
N * @date     04, September, 2012
N *
N * @note
N * Copyright (C) 2012-2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __NANO1xx_H    
N#define __NANO1xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N
N/** @addtogroup NANO1xx_Definitions NANO1xx Definitions
N  This file defines all structures and symbols for NANO1xx:
N    - registers and bitfields
N    - peripheral base address
N    - peripheral ID
N    - Peripheral definitions
N  @{
N*/
N
N
N/******************************************************************************/
N/*                Processor and Core Peripherals                              */
N/******************************************************************************/
N/** @addtogroup NANO1xx_CMSIS Device CMSIS Definitions
N  Configuration of the Cortex-M0 Processor and Core Peripherals
N  @{
N*/
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers **************************************************/
N  NonMaskableInt_IRQn	= -14,    /*!< 2 Non Maskable Interrupt                                  */
N  HardFault_IRQn		= -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                          */
N  SVCall_IRQn			= -5,     /*!< 11 Cortex-M0 SV Call Interrupt                            */
N  PendSV_IRQn			= -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                            */
N  SysTick_IRQn			= -1,     /*!< 15 Cortex-M0 System Tick Interrupt                        */
N/******  NANO1xx Specific Interrupt Numbers ******************************************************/
N  BOD_IRQn              = 0,      /*!< Brownout low voltage detected interrupt                   */
N  WDT_IRQn              = 1,      /*!< Watch Dog Timer interrupt                                 */
N  EINT0_IRQn            = 2,      /*!< External signal interrupt from PB.14 pin                  */
N  EINT1_IRQn            = 3,      /*!< External signal interrupt from PB.15 pin                  */
N  GPABC_IRQn            = 4,      /*!< External signal interrupt from PA[15:0]/PB[13:0]/PC[15:0] */
N  GPDEF_IRQn            = 5,      /*!< External interrupt from PD[15:0]/PE[15:0]/PF[15:0]        */
N  PWM0_IRQn             = 6,      /*!< PWM 0 interrupt                                           */
N  PWM1_IRQn             = 7,      /*!< PWM 1 interrupt                                           */
N  TMR0_IRQn             = 8,      /*!< Timer 0 interrupt                                         */
N  TMR1_IRQn             = 9,      /*!< Timer 1 interrupt                                         */
N  TMR2_IRQn             = 10,     /*!< Timer 2 interrupt                                         */
N  TMR3_IRQn             = 11,     /*!< Timer 3 interrupt                                         */
N  UART0_IRQn            = 12,     /*!< UART0 interrupt                                           */
N  UART1_IRQn            = 13,     /*!< UART1 interrupt                                           */
N  SPI0_IRQn             = 14,     /*!< SPI0 interrupt                                            */
N  SPI1_IRQn             = 15,     /*!< SPI1 interrupt                                            */
N  SPI2_IRQn             = 16,     /*!< SPI2 interrupt                                            */
N  HIRC_IRQn             = 17,     /*!< HIRC interrupt                                            */
N  I2C0_IRQn             = 18,     /*!< I2C0 interrupt                                            */
N  I2C1_IRQn             = 19,     /*!< I2C1 interrupt                                            */
N  SC2_IRQn              = 20,     /*!< Smart Card 2 interrupt                                    */
N  SC0_IRQn              = 21,     /*!< Smart Card 0 interrupt                                    */
N  SC1_IRQn              = 22,     /*!< Smart Card 1 interrupt                                    */
N  USBD_IRQn             = 23,     /*!< USB FS Device interrupt                                   */
N  TK_IRQn               = 24,     /*!< Touch key interrupt                                       */
N  LCD_IRQn              = 25,     /*!< LCD interrupt                                             */
N  PDMA_IRQn             = 26,     /*!< PDMA interrupt                                            */
N  I2S_IRQn              = 27,     /*!< I2S interrupt                                             */
N  PDWU_IRQn             = 28,     /*!< Power Down Wake up interrupt                              */
N  ADC_IRQn              = 29,     /*!< ADC interrupt                                             */
N  DAC_IRQn              = 30,     /*!< DAC interrupt                                             */
N  RTC_IRQn              = 31      /*!< Real time clock interrupt                                 */
N} IRQn_Type;
N
N																			
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M# Processor and Core Peripherals */
N#define __CM0_REV				0x0201    /*!< Core Revision r2p1                               */
N#define __NVIC_PRIO_BITS		2         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig	0         /*!< Set to 1 if different SysTick Config is used     */
N#define __MPU_PRESENT			0         /*!< MPU present or not                               */
N#define __FPU_PRESENT			0         /*!< FPU present or not                               */
N
N/*@}*/ /* end of group NANO1xx_CMSIS */
N
N
N#include "core_cm0.h"                       /* Cortex-M0 processor and core peripherals           */
L 1 "D:\Keil\ARM\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "D:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 127 "D:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "D:\Keil\ARM\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.20
N * @date     05. March 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5030076 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S   uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 128 "D:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "D:\Keil\ARM\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5030076 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 129 "D:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 104 ".\Include\nano1xx.h" 2
N#include "system_nano1xx.h"                 /* NANO1xx System include file                        */
L 1 ".\Include\system_nano1xx.h" 1
N/******************************************************************************
N * @file     system_nano1xx.h
N * @brief    The system clock frequency is define in this file.
N * @version  V1.0.1
N * @date     04, September, 2012
N *
N * @note
N * Copyright (C) 2012-2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_NANO1XX_H   
N#define __SYSTEM_NANO1XX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
Nextern uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock)  */
N
N/*----------------------------------------------------------------------------
N  Define clocks
N *----------------------------------------------------------------------------*/
N#define __XTAL      (12000000UL)	/* HXT */
N#define __RTC_XTAL  (32768UL)		/* LXT */
N#define __IRC12M    (12000000UL)	/* HIRC */
N#define __IRC10K    (10000UL)		/* LIRC */
N#define __HSI       (__IRC12M)     
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_NANO1XX_H */
N
N/*** (C) COPYRIGHT 2012 Nuvoton Technology Corp. ***/
L 105 ".\Include\nano1xx.h" 2
N#include <stdint.h>
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup NANO1xx_Peripherals NANO1xx Peripherals
N  NANO1xx Device Specific Peripheral registers structures
N  @{
N*/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/*------------- Global Control Register (GCR) -----------------------------*/
N/** @addtogroup NANO1xx_GCR NANO1xx Global Control Register (GCR)
N  @{
N*/
Ntypedef struct
N{
N  __I  uint32_t  PDID;						/*!< Offset: 0x0000   Part Device Identification Number Register         */
X  volatile const  uint32_t  PDID;						 
N  __IO uint32_t  RST_SRC;				    /*!< Offset: 0x0004   System Reset Source Register                       */                
X  volatile uint32_t  RST_SRC;				                     
N  __IO uint32_t  IPRST_CTL1;				/*!< Offset: 0x0008   IP Reset Control Register 1                        */
X  volatile uint32_t  IPRST_CTL1;				 
N  __IO uint32_t  IPRST_CTL2;				/*!< Offset: 0x000C   IP Reset Control Register 2                        */
X  volatile uint32_t  IPRST_CTL2;				 
N       uint32_t  RESERVED0[4];
N  __IO uint32_t  TEMCTL;					/*!< Offset: 0x0020   Temperature Sensor Control Register                */
X  volatile uint32_t  TEMCTL;					 
N       uint32_t  RESERVED1[3];
N  __IO uint32_t  PA_L_MFP;				    /*!< Offset: 0x0030   Port A low byte multiple function control Register */                 
X  volatile uint32_t  PA_L_MFP;				                      
N  __IO uint32_t  PA_H_MFP;					/*!< Offset: 0x0034   Port A high byte multiple function control Register */
X  volatile uint32_t  PA_H_MFP;					 
N  __IO uint32_t  PB_L_MFP;					/*!< Offset: 0x0038   Port B low byte multiple function control Register */
X  volatile uint32_t  PB_L_MFP;					 
N  __IO uint32_t  PB_H_MFP;					/*!< Offset: 0x003C   Port B high byte multiple function control Register */
X  volatile uint32_t  PB_H_MFP;					 
N  __IO uint32_t  PC_L_MFP;					/*!< Offset: 0x0040   Port C low byte multiple function control Register */
X  volatile uint32_t  PC_L_MFP;					 
N  __IO uint32_t  PC_H_MFP;					/*!< Offset: 0x0044   Port C high byte multiple function control Register */
X  volatile uint32_t  PC_H_MFP;					 
N  __IO uint32_t  PD_L_MFP;					/*!< Offset: 0x0048   Port D low byte multiple function control Register */
X  volatile uint32_t  PD_L_MFP;					 
N  __IO uint32_t  PD_H_MFP;					/*!< Offset: 0x004C   Port D high byte multiple function control Register */
X  volatile uint32_t  PD_H_MFP;					 
N  __IO uint32_t  PE_L_MFP;					/*!< Offset: 0x0050   Port E low byte multiple function control Register */
X  volatile uint32_t  PE_L_MFP;					 
N  __IO uint32_t  PE_H_MFP;					/*!< Offset: 0x0054   Port E high byte multiple function control Register */
X  volatile uint32_t  PE_H_MFP;					 
N  __IO uint32_t  PF_L_MFP;					/*!< Offset: 0x0058   Port F low byte multiple function control Register  */
X  volatile uint32_t  PF_L_MFP;					 
N       uint32_t  RESERVED3[1];
N  __IO uint32_t  PORCTL;					/*!< Offset: 0x0060   Power-On-Reset Controller Register */
X  volatile uint32_t  PORCTL;					 
N  __IO uint32_t  BODCTL;					/*!< Offset: 0x0064   Brown-out Detector Control Register */
X  volatile uint32_t  BODCTL;					 
N  __IO uint32_t  BODSTS;					/*!< Offset: 0x0068   Brown-out Detector Status Register */
X  volatile uint32_t  BODSTS;					 
N  __IO uint32_t  VREFCTL;					/*!< Offset: 0x006C   Voltage reference Control Register */
X  volatile uint32_t  VREFCTL;					 
N       uint32_t  RESERVED4[4];
N  __IO uint32_t  IRCTRIMCTL;				/*!< Offset: 0x0080   HIRC Trim Control Register */
X  volatile uint32_t  IRCTRIMCTL;				 
N  __IO uint32_t  IRCTRIMIER;				/*!< Offset: 0x0084   HIRC Trim Interrupt Enable Register */
X  volatile uint32_t  IRCTRIMIER;				 
N  __IO uint32_t  IRCTRIMISR;				/*!< Offset: 0x0088   HIRC Trim Interrupt Status Register */
X  volatile uint32_t  IRCTRIMISR;				 
N       uint32_t  RESERVED5[29];
N  __IO uint32_t  RegLockAddr;				/*!< Offset: 0x0100   Register Lock Key address */
X  volatile uint32_t  RegLockAddr;				 
N       uint32_t  RESERVED6[3];
N  __IO uint32_t  RCADJ;						/*!< Offset: 0x0110   RC Adjustment control register */
X  volatile uint32_t  RCADJ;						 
N} GCR_TypeDef;
N/*@}*/ /* end of group NANO1xx_GCR */
N
N
N/*------------- Clock Control Register (CLK) -----------------------------*/
N/** @addtogroup NANO1xx_CLK NANO1xx Clock Control Register (CLK)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  PWRCTL; 					/*!< Offset: 0x0000   System Power Down Control Register                 */
X  volatile uint32_t  PWRCTL; 					 
N  __IO uint32_t  AHBCLK;					/*!< Offset: 0x0004   AHB Devices Clock Enable Control Register          */
X  volatile uint32_t  AHBCLK;					 
N  __IO uint32_t  APBCLK;				    /*!< Offset: 0x0008   APB Devices Clock Enable Control Register          */
X  volatile uint32_t  APBCLK;				     
N  __IO uint32_t  CLKSTATUS;					/*!< Offset: 0x000C   Clock Status Monitor Register                      */
X  volatile uint32_t  CLKSTATUS;					 
N  __IO uint32_t  CLKSEL0;					/*!< Offset: 0x0010   Clock Source Select Control Register 0			 */
X  volatile uint32_t  CLKSEL0;					 
N  __IO uint32_t  CLKSEL1;					/*!< Offset: 0x0014   Clock Source Select Control Register 1			 */
X  volatile uint32_t  CLKSEL1;					 
N  __IO uint32_t  CLKSEL2;					/*!< Offset: 0x0018   Clock Source Select Control Register 2			 */
X  volatile uint32_t  CLKSEL2;					 
N  __IO uint32_t  CLKDIV0;				    /*!< Offset: 0x001C   Clock Divider Number Register	0					 */
X  volatile uint32_t  CLKDIV0;				     
N  __IO uint32_t  CLKDIV1;					/*!< Offset: 0x0020   Clock Divider Number Register	1					 */
X  volatile uint32_t  CLKDIV1;					 
N  __IO uint32_t  PLLCTL;					/*!< Offset: 0x0024   PLL Control Register		                         */
X  volatile uint32_t  PLLCTL;					 
N  __IO uint32_t  FRQDIV;					/*!< Offset: 0x0028   Frequency Divider Control Register                 */
X  volatile uint32_t  FRQDIV;					 
N  __IO uint32_t  TESTCLK;					/*!< Offset: 0x002C   Test Clock Source Select Control Register          */
X  volatile uint32_t  TESTCLK;					 
N  __IO uint32_t  WK_INTSTS;					/*!< Offset: 0x0030   Wake-up interrupt status Register                  */
X  volatile uint32_t  WK_INTSTS;					 
N} CLK_TypeDef;
N/*@}*/ /* end of group NANO1xx_CLK */
N
N
N/*------------- General Purpose I/O (GPIO) -----------------------------*/
N/** @addtogroup NANO1xx_GPIO NANO1xx General Purpose I/O (GPIO)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  PMD;                        /*!< Offset: 0x0000   GPIO Port Bit Mode Control                         */ 
X  volatile uint32_t  PMD;                          
N  __IO uint32_t  OFFD;                       /*!< Offset: 0x0004   GPIO Port Bit Off Digital Enable                   */
X  volatile uint32_t  OFFD;                        
N  __IO uint32_t  DOUT;                       /*!< Offset: 0x0008   GPIO Port Data Output                              */
X  volatile uint32_t  DOUT;                        
N  __IO uint32_t  DMASK;                      /*!< Offset: 0x000C   GPIO Port Data Output Write Mask                   */
X  volatile uint32_t  DMASK;                       
N  __I  uint32_t  PIN;                        /*!< Offset: 0x0010   GPIO Port Pin Value                                */
X  volatile const  uint32_t  PIN;                         
N  __IO uint32_t  DBEN;                       /*!< Offset: 0x0014   GPIO Port De-bounce Enable                         */
X  volatile uint32_t  DBEN;                        
N  __IO uint32_t  IMD;                        /*!< Offset: 0x0018   GPIO Port Interrupt Mode Select                    */
X  volatile uint32_t  IMD;                         
N  __IO uint32_t  IER;                        /*!< Offset: 0x001C   GPIO Port Interrupt Enable                         */
X  volatile uint32_t  IER;                         
N  __IO uint32_t  ISR;                        /*!< Offset: 0x0020   GPIO Port Interrupt Source Flag                    */
X  volatile uint32_t  ISR;                         
N  __IO uint32_t  PUEN;                       /*!< Offset: 0x0024   GPIO Port Pull-Up Enable                           */
X  volatile uint32_t  PUEN;                        
N} GPIO_TypeDef;
N
N
N/*  
N *  GPIO De-bounce Cycle Control
N */
Ntypedef struct
N{
N  __IO uint32_t  CON;                        /*!< Offset: 0x0000   GPIO De-bounce Cycle Control Register              */
X  volatile uint32_t  CON;                         
N} GPIODBNCE_TypeDef;
N
N
N/*  
N *  General Purpose I/O bit mode (GPIO bit mode)
N */
Ntypedef struct
N{
N  __IO uint32_t  GP_BIT0;                        /*!< Offset: 0x0000   GPIO Port Bit 0 Data Register                  */
X  volatile uint32_t  GP_BIT0;                         
N  __IO uint32_t  GP_BIT1;                        /*!< Offset: 0x0004   GPIO Port Bit 1 Data Register                  */
X  volatile uint32_t  GP_BIT1;                         
N  __IO uint32_t  GP_BIT2;                        /*!< Offset: 0x0008   GPIO Port Bit 2 Data Register                  */
X  volatile uint32_t  GP_BIT2;                         
N  __IO uint32_t  GP_BIT3;                        /*!< Offset: 0x000C   GPIO Port Bit 3 Data Register                  */
X  volatile uint32_t  GP_BIT3;                         
N  __IO uint32_t  GP_BIT4;                        /*!< Offset: 0x0010   GPIO Port Bit 4 Data Register                  */
X  volatile uint32_t  GP_BIT4;                         
N  __IO uint32_t  GP_BIT5;                        /*!< Offset: 0x0014   GPIO Port Bit 5 Data Register                  */
X  volatile uint32_t  GP_BIT5;                         
N  __IO uint32_t  GP_BIT6;                        /*!< Offset: 0x0018   GPIO Port Bit 6 Data Register                  */
X  volatile uint32_t  GP_BIT6;                         
N  __IO uint32_t  GP_BIT7;                        /*!< Offset: 0x001C   GPIO Port Bit 7 Data Register                  */
X  volatile uint32_t  GP_BIT7;                         
N  __IO uint32_t  GP_BIT8;                        /*!< Offset: 0x0020   GPIO Port Bit 8 Data Register                  */
X  volatile uint32_t  GP_BIT8;                         
N  __IO uint32_t  GP_BIT9;                        /*!< Offset: 0x0024   GPIO Port Bit 9 Data Register                  */
X  volatile uint32_t  GP_BIT9;                         
N  __IO uint32_t  GP_BIT10;                       /*!< Offset: 0x0028   GPIO Port Bit 10 Data Register                 */
X  volatile uint32_t  GP_BIT10;                        
N  __IO uint32_t  GP_BIT11;                       /*!< Offset: 0x002C   GPIO Port Bit 11 Data Register                 */
X  volatile uint32_t  GP_BIT11;                        
N  __IO uint32_t  GP_BIT12;                       /*!< Offset: 0x0030   GPIO Port Bit 12 Data Register                 */
X  volatile uint32_t  GP_BIT12;                        
N  __IO uint32_t  GP_BIT13;                       /*!< Offset: 0x0034   GPIO Port Bit 13 Data Register                 */
X  volatile uint32_t  GP_BIT13;                        
N  __IO uint32_t  GP_BIT14;                       /*!< Offset: 0x0038   GPIO Port Bit 14 Data Register                 */
X  volatile uint32_t  GP_BIT14;                        
N  __IO uint32_t  GP_BIT15;                       /*!< Offset: 0x003C   GPIO Port Bit 15 Data Register                 */
X  volatile uint32_t  GP_BIT15;                        
N} GPIOBIT_TypeDef;
N/*@}*/ /* end of group NANO1xx_GPIO */
N
N
N/*------------- VDMA Control Register (VDMA) -----------------------------*/
N/** @addtogroup NANO1xx_VDMA NANO1xx VDMA Control Register (VDMA)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CSR;                        	 /*!< Offset: 0x0000   VDMA Control Register                          */
X  volatile uint32_t  CSR;                        	  
N  __IO uint32_t  SAR;                        	 /*!< Offset: 0x0004   VDMA Source Address Register                   */
X  volatile uint32_t  SAR;                        	  
N  __IO uint32_t  DAR;                        	 /*!< Offset: 0x0008   VDMA Destination Address Register              */
X  volatile uint32_t  DAR;                        	  
N  __IO uint32_t  BCR;                        	 /*!< Offset: 0x000C   VDMA Transfer Byte Count Register              */
X  volatile uint32_t  BCR;                        	  
N       uint32_t  RESERVED0;                    	 /*!< Offset: 0x0010   Reserved                                       */
N  __I  uint32_t  CSAR;                        	 /*!< Offset: 0x0014   VDMA Current Source Address Register           */
X  volatile const  uint32_t  CSAR;                        	  
N  __I  uint32_t  CDAR;                        	 /*!< Offset: 0x0018   VDMA Current Destination Address Register      */
X  volatile const  uint32_t  CDAR;                        	  
N  __I  uint32_t  CBCR;                        	 /*!< Offset: 0x001C   VDMA Current Transfer Byte Count Register      */
X  volatile const  uint32_t  CBCR;                        	  
N  __IO uint32_t  IER;                        	 /*!< Offset: 0x0020   VDMA Interrupt Enable Register                 */
X  volatile uint32_t  IER;                        	  
N  __IO uint32_t  ISR;                        	 /*!< Offset: 0x0024   VDMA Interrupt Status Register                 */
X  volatile uint32_t  ISR;                        	  
N       uint32_t  RESERVED1;                      /*!< Offset: 0x0028   Reserved                                       */
N  __IO uint32_t  SASOCR;                         /*!< Offset: 0x002C   VDMA Source Address Stride Offset Register     */
X  volatile uint32_t  SASOCR;                          
N  __IO uint32_t  DASOCR;                         /*!< Offset: 0x0030   VDMA Destination Address Stride Offset Register*/
X  volatile uint32_t  DASOCR;                          
N       uint32_t  RESERVED2[19];                  /*!< Offset: 0x0034~0x007C   Reserved                                */
N  __I  uint32_t  BUF0;                        	 /*!< Offset: 0x0080   VDMA Internal Buffer FIFO 0                    */
X  volatile const  uint32_t  BUF0;                        	  
N  __I  uint32_t  BUF1;                        	 /*!< Offset: 0x0084   VDMA Internal Buffer FIFO 1                    */
X  volatile const  uint32_t  BUF1;                        	  
N} VDMA_TypeDef;
N/*@}*/ /* end of group NANO1xx_VDMA */
N
N
N/*------------- PDMA Control Register (PDMA) -----------------------------*/
N/** @addtogroup NANO1xx_PDMA NANO1xx PDMA Control Register (PDMA)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CSR;                        	 /*!< Offset: 0x0000   PDMA Control Register                          */
X  volatile uint32_t  CSR;                        	  
N  __IO uint32_t  SAR;                        	 /*!< Offset: 0x0004   PDMA Source Address Register                   */
X  volatile uint32_t  SAR;                        	  
N  __IO uint32_t  DAR;                        	 /*!< Offset: 0x0008   PDMA Destination Address Register              */
X  volatile uint32_t  DAR;                        	  
N  __IO uint32_t  BCR;                        	 /*!< Offset: 0x000C   PDMA Transfer Byte Count Register              */
X  volatile uint32_t  BCR;                        	  
N       uint32_t  RESERVED0;                      /*!< Offset: 0x0010   Reserved                                       */
N  __I  uint32_t  CSAR;                        	 /*!< Offset: 0x0014   PDMA Current Source Address Register           */
X  volatile const  uint32_t  CSAR;                        	  
N  __I  uint32_t  CDAR;                        	 /*!< Offset: 0x0018   PDMA Current Destination Address Register      */
X  volatile const  uint32_t  CDAR;                        	  
N  __I  uint32_t  CBCR;                        	 /*!< Offset: 0x001C   PDMA Current Transfer Byte Count Register      */
X  volatile const  uint32_t  CBCR;                        	  
N  __IO uint32_t  IER;                        	 /*!< Offset: 0x0020   PDMA Interrupt Enable Register                 */
X  volatile uint32_t  IER;                        	  
N  __IO uint32_t  ISR;                        	 /*!< Offset: 0x0024   PDMA Interrupt Status Register                 */
X  volatile uint32_t  ISR;                        	  
N  __IO uint32_t  TCR;                        	 /*!< Offset: 0x0028   PDMA Timer Counter Setting Register            */
X  volatile uint32_t  TCR;                        	  
N       uint32_t  RESERVED1[21];                  /*!< Offset: 0x002C~0x7C   Reserved                                  */
N  __I  uint32_t  BUF0;                        	 /*!< Offset: 0x0080   PDMA Internal Buffer FIFO                      */
X  volatile const  uint32_t  BUF0;                        	  
N} PDMA_TypeDef;
N
N
N/*  
N *  PDMA Global Control Registers
N */
Ntypedef struct
N{
N  __IO uint32_t  CSR;                        	 /*!< Offset: 0x0000   DMA Global Control Register                    */
X  volatile uint32_t  CSR;                        	  
N  __IO uint32_t  PDSSR0;                         /*!< Offset: 0x0004   DMA Service Selection Control Register 0       */
X  volatile uint32_t  PDSSR0;                          
N  __IO uint32_t  PDSSR1;                         /*!< Offset: 0x0008   DMA Service Selection Control Register 1       */
X  volatile uint32_t  PDSSR1;                          
N  __I  uint32_t  ISR;                        	 /*!< Offset: 0x000C   DMA Global Interrupt Register                  */
X  volatile const  uint32_t  ISR;                        	  
N} PDMAGCR_TypeDef;
N
N
N/*  
N *  PDMA CRC Control Registers
N */
Ntypedef struct
N{
N  __IO uint32_t  CTL;
X  volatile uint32_t  CTL;
N  __IO uint32_t  DMASAR;
X  volatile uint32_t  DMASAR;
N       uint32_t  RESERVED0;
N  __IO uint32_t  DMABCR;
X  volatile uint32_t  DMABCR;
N       uint32_t  RESERVED1;
N  __I  uint32_t  DMACSAR;
X  volatile const  uint32_t  DMACSAR;
N       uint32_t  RESERVED2;
N  __I  uint32_t  DMACBCR;
X  volatile const  uint32_t  DMACBCR;
N  __IO uint32_t  DMAIER;
X  volatile uint32_t  DMAIER;
N  __IO uint32_t  DMAISR;
X  volatile uint32_t  DMAISR;
N       uint32_t  RESERVED3[22];
N  __IO uint32_t  WDATA;
X  volatile uint32_t  WDATA;
N  __IO uint32_t  SEED;
X  volatile uint32_t  SEED;
N  __I  uint32_t  CHECKSUM;
X  volatile const  uint32_t  CHECKSUM;
N} PDMACRC_TypeDef;
N/*@}*/ /* end of group NANO1xx_PDMA */
N
N
N/*------------- Flash Memory Controller (FMC) -----------------------------*/
N/** @addtogroup NANO1xx_FMC NANO1xx Flash Memory Controller Register (FMC)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  ISPCON;					/*!< Offset: 0x0000   ISP Control Register                               */
X  volatile uint32_t  ISPCON;					 
N  __IO uint32_t  ISPADR;					/*!< Offset: 0x0004   ISP Address Register                               */ 
X  volatile uint32_t  ISPADR;					  
N  __IO uint32_t  ISPDAT;					/*!< Offset: 0x0008   ISP Data Register                                  */ 
X  volatile uint32_t  ISPDAT;					  
N  __IO uint32_t  ISPCMD;					/*!< Offset: 0x000C   ISP Command Register                               */
X  volatile uint32_t  ISPCMD;					 
N  __IO uint32_t  ISPTRG;					/*!< Offset: 0x0010   ISP Trigger Register                               */
X  volatile uint32_t  ISPTRG;					 
N  __I  uint32_t  DFBADR;					/*!< Offset: 0x0014   Data Flash Start Address (CONFIG1)                 */ 
X  volatile const  uint32_t  DFBADR;					  
N  __I  uint32_t  RESERVED0[10];
X  volatile const  uint32_t  RESERVED0[10];
N  __IO uint32_t  ISPSTA;					/*!< Offset: 0x0040   ISP Status Register                                */
X  volatile uint32_t  ISPSTA;					 
N} FMC_TypeDef;
N/*@}*/ /* end of group NANO1xx_FMC */
N
N
N/*------------- External Bus Interface Control Register (EBI) -----------------------------*/
N/** @addtogroup NANO1xx_EBI NANO1xx External Bus Interfacel Control Register (EBI)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  EBICON;					/*!< Offset: 0x0000   EBI general control register                       */
X  volatile uint32_t  EBICON;					 
N  __IO uint32_t  EXTIME;					/*!< Offset: 0x0004   EBI timing control register                        */
X  volatile uint32_t  EXTIME;					 
N} EBI_TypeDef;
N/*@}*/ /* end of group NANO1xx_EBI */
N
N
N/*------------- Watchdog Timer Control Register (WDT) -----------------------------*/
N/** @addtogroup NANO1xx_WDT NANO1xx Watchdog Timer Control Register (WDT)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CTL;						/*!< Offset: 0x0000   Watchdog Timer Control Register   		         */
X  volatile uint32_t  CTL;						 
N  __IO uint32_t  IER;						/*!< Offset: 0x0004   Watchdog Timer Interrupt Enable Register 			 */
X  volatile uint32_t  IER;						 
N  __IO uint32_t  ISR;						/*!< Offset: 0x0008   Watchdog Timer Interrupt Status Register 			 */
X  volatile uint32_t  ISR;						 
N
N} WDT_TypeDef;
N/*@}*/ /* end of group NANO1xx_WDT */
N
N
N/*------------- Window Watchdog Timer Control Register (WWDT) -----------------------------*/
N/** @addtogroup NANO1xx_WWDT NANO1xx Watchdog Timer Control Register (WWDT)
N  @{
N*/
Ntypedef struct
N{
N  __O  uint32_t  RLD;						/*!< Offset: 0x0000   Window Watchdog Timer Reload Counter Register		 */
X  volatile  uint32_t  RLD;						 
N  __IO uint32_t  CR;						/*!< Offset: 0x0004   Window Watchdog Timer Control Register	    		 */
X  volatile uint32_t  CR;						 
N  __IO uint32_t  IER;						/*!< Offset: 0x0008   Window Watchdog Timer Interrupt Enable Register		 */
X  volatile uint32_t  IER;						 
N  __IO uint32_t  STS;						/*!< Offset: 0x000C   Window Watchdog Timer Status Register			 */
X  volatile uint32_t  STS;						 
N  __I  uint32_t  VAL;						/*!< Offset: 0x0010   Window Watchdog Counter Value Register			 */
X  volatile const  uint32_t  VAL;						 
N} WWDT_TypeDef;
N/*@}*/ /* end of group NANO1xx_WWDT */
N
N
N/*----------------------------- Real Time Clock Controller -------------------------------*/
N/** @addtogroup NANO1xx_RTC NANO1xx Real Time Clock (RTC)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  INIR;		/*!< Offset: 0x0000   RTC Initiation Register	  	       	*/
X  volatile uint32_t  INIR;		 
N  __IO uint32_t  AER;		/*!< Offset: 0x0004   RTC Access Enable Register  	     	*/
X  volatile uint32_t  AER;		 
N  __IO uint32_t  FCR;		/*!< Offset: 0x0008   RTC Frequency Compensation Register	*/
X  volatile uint32_t  FCR;		 
N  __IO uint32_t  TLR;		/*!< Offset: 0x000C   Time Loading Register					*/
X  volatile uint32_t  TLR;		 
N  __IO uint32_t  CLR;		/*!< Offset: 0x0010   Calendar Loading Register				*/
X  volatile uint32_t  CLR;		 
N  __IO uint32_t  TSSR;		/*!< Offset: 0x0014   Time Scale Selection Register			*/
X  volatile uint32_t  TSSR;		 
N  __IO uint32_t  DWR;		/*!< Offset: 0x0018   Day of the Week Register				*/
X  volatile uint32_t  DWR;		 
N  __IO uint32_t  TAR;		/*!< Offset: 0x001C   Time Alarm Register					*/
X  volatile uint32_t  TAR;		 
N  __IO uint32_t  CAR;		/*!< Offset: 0x0020   Calendar Alarm Register				*/
X  volatile uint32_t  CAR;		 
N  __I  uint32_t  LIR;		/*!< Offset: 0x0024   Leap year Indicator Register			*/
X  volatile const  uint32_t  LIR;		 
N  __IO uint32_t  RIER;		/*!< Offset: 0x0028   RTC Interrupt Enable Register			*/
X  volatile uint32_t  RIER;		 
N  __IO uint32_t  RIIR;		/*!< Offset: 0x002C   RTC Interrupt Indicator Register		*/
X  volatile uint32_t  RIIR;		 
N  __IO uint32_t  TTR;		/*!< Offset: 0x0030   RTC Time Tick Register				*/
X  volatile uint32_t  TTR;		 
N  uint32_t  RESERVED0[2];
N  __IO uint32_t  SPRCTL;	/*!< Offset: 0x003C   RTC Spare Functional Control Register	*/
X  volatile uint32_t  SPRCTL;	 
N  __IO uint32_t  SPR0;		/*!< Offset: 0x0040   RTC Spare Register 0					*/
X  volatile uint32_t  SPR0;		 
N  __IO uint32_t  SPR1;		/*!< Offset: 0x0044   RTC Spare Register 1					*/
X  volatile uint32_t  SPR1;		 
N  __IO uint32_t  SPR2;		/*!< Offset: 0x0048   RTC Spare Register 2					*/
X  volatile uint32_t  SPR2;		 
N  __IO uint32_t  SPR3;		/*!< Offset: 0x004C   RTC Spare Register 3					*/
X  volatile uint32_t  SPR3;		 
N  __IO uint32_t  SPR4;		/*!< Offset: 0x0050   RTC Spare Register 4					*/
X  volatile uint32_t  SPR4;		 
N  __IO uint32_t  SPR5;		/*!< Offset: 0x0054   RTC Spare Register 5					*/
X  volatile uint32_t  SPR5;		 
N  __IO uint32_t  SPR6;		/*!< Offset: 0x0058   RTC Spare Register 6					*/
X  volatile uint32_t  SPR6;		 
N  __IO uint32_t  SPR7;		/*!< Offset: 0x005C   RTC Spare Register 7					*/
X  volatile uint32_t  SPR7;		 
N  __IO uint32_t  SPR8;		/*!< Offset: 0x0060   RTC Spare Register 8					*/
X  volatile uint32_t  SPR8;		 
N  __IO uint32_t  SPR9;		/*!< Offset: 0x0064   RTC Spare Register 9					*/
X  volatile uint32_t  SPR9;		 
N  __IO uint32_t  SPR10;		/*!< Offset: 0x0068   RTC Spare Register 10					*/
X  volatile uint32_t  SPR10;		 
N  __IO uint32_t  SPR11;		/*!< Offset: 0x006C   RTC Spare Register 11					*/
X  volatile uint32_t  SPR11;		 
N  __IO uint32_t  SPR12;		/*!< Offset: 0x0070   RTC Spare Register 12					*/
X  volatile uint32_t  SPR12;		 
N  __IO uint32_t  SPR13;		/*!< Offset: 0x0074   RTC Spare Register 13					*/
X  volatile uint32_t  SPR13;		 
N  __IO uint32_t  SPR14;		/*!< Offset: 0x0078   RTC Spare Register 14					*/
X  volatile uint32_t  SPR14;		 
N  __IO uint32_t  SPR15;		/*!< Offset: 0x007C   RTC Spare Register 15					*/
X  volatile uint32_t  SPR15;		 
N  __IO uint32_t  SPR16;		/*!< Offset: 0x0080   RTC Spare Register 16					*/
X  volatile uint32_t  SPR16;		 
N  __IO uint32_t  SPR17;		/*!< Offset: 0x0084   RTC Spare Register 17					*/
X  volatile uint32_t  SPR17;		 
N  __IO uint32_t  SPR18;		/*!< Offset: 0x0088   RTC Spare Register 18					*/
X  volatile uint32_t  SPR18;		 
N  __IO uint32_t  SPR19;		/*!< Offset: 0x008C   RTC Spare Register 19					*/
X  volatile uint32_t  SPR19;		 
N} RTC_TypeDef;
N/*@}*/ /* end of group NANO1xx_RTC */
N
N
N/*----------------------------- ADC Controller -------------------------------*/
N/** @addtogroup NANO1xx_ADC NANO1xx A/D Converter (ADC)
N  @{
N*/
Ntypedef struct
N{
N  __I  uint32_t  RESULT0;					/*!< Offset: 0x0000   A/D result Register 0								 */
X  volatile const  uint32_t  RESULT0;					 
N  __I  uint32_t  RESULT1;					/*!< Offset: 0x0004   A/D result Register 1								 */
X  volatile const  uint32_t  RESULT1;					 
N  __I  uint32_t  RESULT2;					/*!< Offset: 0x0008   A/D result Register 2								 */
X  volatile const  uint32_t  RESULT2;					 
N  __I  uint32_t  RESULT3;					/*!< Offset: 0x000C   A/D result Register 3								 */
X  volatile const  uint32_t  RESULT3;					 
N  __I  uint32_t  RESULT4;					/*!< Offset: 0x0010   A/D result Register 4								 */
X  volatile const  uint32_t  RESULT4;					 
N  __I  uint32_t  RESULT5;					/*!< Offset: 0x0014   A/D result Register 5								 */
X  volatile const  uint32_t  RESULT5;					 
N  __I  uint32_t  RESULT6;					/*!< Offset: 0x0018   A/D result Register 6								 */
X  volatile const  uint32_t  RESULT6;					 
N  __I  uint32_t  RESULT7;					/*!< Offset: 0x001C   A/D result Register 7								 */
X  volatile const  uint32_t  RESULT7;					 
N  __I  uint32_t  RESULT8;					/*!< Offset: 0x0020   A/D result Register 8								 */
X  volatile const  uint32_t  RESULT8;					 
N  __I  uint32_t  RESULT9;					/*!< Offset: 0x0024   A/D result Register 9								 */
X  volatile const  uint32_t  RESULT9;					 
N  __I  uint32_t  RESULT10;					/*!< Offset: 0x0028   A/D result Register 10							 */
X  volatile const  uint32_t  RESULT10;					 
N  __I  uint32_t  RESULT11;					/*!< Offset: 0x002C   A/D result Register 11							 */
X  volatile const  uint32_t  RESULT11;					 
N  __I  uint32_t  RESULT12;					/*!< Offset: 0x0030   A/D result Register 12							 */
X  volatile const  uint32_t  RESULT12;					 
N  __I  uint32_t  RESULT13;					/*!< Offset: 0x0034   A/D result Register 13							 */
X  volatile const  uint32_t  RESULT13;					 
N  __I  uint32_t  RESULT14;					/*!< Offset: 0x0038   A/D result Register 14							 */
X  volatile const  uint32_t  RESULT14;					 
N  __I  uint32_t  RESULT15;					/*!< Offset: 0x003C   A/D result Register 15							 */				 
X  volatile const  uint32_t  RESULT15;					 				 
N  __I  uint32_t  RESULT16;					/*!< Offset: 0x0040   A/D result Register 16							 */
X  volatile const  uint32_t  RESULT16;					 
N  __I  uint32_t  RESULT17;					/*!< Offset: 0x0044   A/D result Register 17							 */
X  volatile const  uint32_t  RESULT17;					 
N  __IO uint32_t  CR;						/*!< Offset: 0x0048   A/D Control Register 								 */
X  volatile uint32_t  CR;						 
N  __IO uint32_t  CHER;						/*!< Offset: 0x004C   A/D Channel Enable Register						 */
X  volatile uint32_t  CHER;						 
N  __IO uint32_t  CMPR0;						/*!< Offset: 0x0050   A/D Compare Register 0							 */
X  volatile uint32_t  CMPR0;						 
N  __IO uint32_t  CMPR1;						/*!< Offset: 0x0054   A/D Compare Register 1							 */
X  volatile uint32_t  CMPR1;						 
N  __IO uint32_t  SR;						/*!< Offset: 0x0058   A/D Status Register								 */
X  volatile uint32_t  SR;						 
N  uint32_t  RESERVED0;						/*!< Offset: 0x005C   Reserved                                           */
N  __I  uint32_t  PDMA;  					/*!< Offset: 0x0060   A/D PDMA Current Transfer Data Register            */
X  volatile const  uint32_t  PDMA;  					 
N  __IO uint32_t  PWRCTL;					/*!< Offset: 0x0064   A/D Power Control Register                         */
X  volatile uint32_t  PWRCTL;					 
N  __IO uint32_t  CALCTL;					/*!< Offset: 0x0068   A/D Calibration Control Register                   */
X  volatile uint32_t  CALCTL;					 
N  __IO uint32_t  CALWORD;					/*!< Offset: 0x006C   A/D Calibration Load Word Register                 */
X  volatile uint32_t  CALWORD;					 
N  __IO uint32_t  SMPLCNT0;					/*!< Offset: 0x0070   A/D Sample Register 0                              */
X  volatile uint32_t  SMPLCNT0;					 
N  __IO uint32_t  SMPLCNT1;					/*!< Offset: 0x0074   A/D Sample Register 1                              */
X  volatile uint32_t  SMPLCNT1;					 
N} ADC_TypeDef;
N/*@}*/ /* end of group NANO1xx_ADC */
N
N
N/*------------- I2S Control Register (I2S) -----------------------------*/
N/** @addtogroup NANO1xx_I2S NANO1xx I2S Control Register (I2S)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CTRL;					/*!< Offset: 0x0000   I2S Control Register                               */
X  volatile uint32_t  CTRL;					 
N  __IO uint32_t  CLKDIV;				/*!< Offset: 0x0004   I2S Clock Divider Register                         */
X  volatile uint32_t  CLKDIV;				 
N  __IO uint32_t  INTEN;					/*!< Offset: 0x0008   I2S Interrupt Enable Register                      */
X  volatile uint32_t  INTEN;					 
N  __IO uint32_t  STATUS;				/*!< Offset: 0x000C   I2S Status Register                                */
X  volatile uint32_t  STATUS;				 
N  __O uint32_t  TXFIFO;					/*!< Offset: 0x0010   I2S Transmit FIFO Register                         */
X  volatile uint32_t  TXFIFO;					 
N  __I uint32_t  RXFIFO;					/*!< Offset: 0x0014   I2S Receive FIFO Register                          */
X  volatile const uint32_t  RXFIFO;					 
N} I2S_TypeDef;
N/*@}*/ /* end of group NANO1xx_I2S */
N
N
N/*------------- USB Device Control Register (USBD) -----------------------------*/
N/** @addtogroup NANO1xx_USBD NANO1xx USB Device Control Register (USBD)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CTRL;                           /*!< Offset: 0x0000   USB Control Register                           */ 
X  volatile uint32_t  CTRL;                             
N  __I  uint32_t  BUSSTS;                         /*!< Offset: 0x0004   USB Bus Status Register                        */ 
X  volatile const  uint32_t  BUSSTS;                           
N  __IO uint32_t  INTEN;                          /*!< Offset: 0x0008   USB Interrupt Enable Register                  */ 
X  volatile uint32_t  INTEN;                            
N  __IO uint32_t  INTSTS;                         /*!< Offset: 0x000C   USB Interrupt Event Status Register            */ 
X  volatile uint32_t  INTSTS;                           
N  __IO uint32_t  DADDR;                          /*!< Offset: 0x0010   USB Device's Function Address Register         */ 
X  volatile uint32_t  DADDR;                            
N  __I  uint32_t  EPSTS;                          /*!< Offset: 0x0014   USB Endpoint Status Register                   */ 
X  volatile const  uint32_t  EPSTS;                            
N  __IO uint32_t  BUFSEG;                         /*!< Offset: 0x0018   USB Setup Token Buffer Segmentation Register   */ 
X  volatile uint32_t  BUFSEG;                           
N  __I  uint32_t  EPSTS2;                         /*!< Offset: 0x001C   USB Endpoint Status Register 2                 */ 
X  volatile const  uint32_t  EPSTS2;                           
N  __IO uint32_t  BUFSEG0;                        /*!< Offset: 0x0020   USB Endpoint 0 Buffer Segmentation Register    */ 
X  volatile uint32_t  BUFSEG0;                          
N  __IO uint32_t  MXPLD0;                         /*!< Offset: 0x0024   USB Endpoint 0 Maximal Payload Register        */ 
X  volatile uint32_t  MXPLD0;                           
N  __IO uint32_t  CFG0;                           /*!< Offset: 0x0028   USB Endpoint 0 Configuration Register          */ 
X  volatile uint32_t  CFG0;                             
N       uint32_t  RESERVED1;                      /*!< Offset: 0x002C   Reserved                                       */ 
N  __IO uint32_t  BUFSEG1;                        /*!< Offset: 0x0030   USB Endpoint 1 Buffer Segmentation Register    */ 
X  volatile uint32_t  BUFSEG1;                          
N  __IO uint32_t  MXPLD1;                         /*!< Offset: 0x0034   USB Endpoint 1 Maximal Payload Register        */ 
X  volatile uint32_t  MXPLD1;                           
N  __IO uint32_t  CFG1;                           /*!< Offset: 0x0038   USB Endpoint 1 Configuration Register          */ 
X  volatile uint32_t  CFG1;                             
N       uint32_t  RESERVED2;                      /*!< Offset: 0x003C   Reserved                                       */ 
N  __IO uint32_t  BUFSEG2;                        /*!< Offset: 0x0040   USB Endpoint 2 Buffer Segmentation Register    */ 
X  volatile uint32_t  BUFSEG2;                          
N  __IO uint32_t  MXPLD2;                         /*!< Offset: 0x0044   USB Endpoint 2 Maximal Payload Register        */ 
X  volatile uint32_t  MXPLD2;                           
N  __IO uint32_t  CFG2;                           /*!< Offset: 0x0048   USB Endpoint 2 Configuration Register          */ 
X  volatile uint32_t  CFG2;                             
N       uint32_t  RESERVED3;                      /*!< Offset: 0x004C   Reserved                                       */ 
N  __IO uint32_t  BUFSEG3;                        /*!< Offset: 0x0050   USB Endpoint 3 Buffer Segmentation Register    */ 
X  volatile uint32_t  BUFSEG3;                          
N  __IO uint32_t  MXPLD3;                         /*!< Offset: 0x0054   USB Endpoint 3 Maximal Payload Register        */ 
X  volatile uint32_t  MXPLD3;                           
N  __IO uint32_t  CFG3;                           /*!< Offset: 0x0058   USB Endpoint 3 Configuration Register          */ 
X  volatile uint32_t  CFG3;                             
N       uint32_t  RESERVED4;                      /*!< Offset: 0x005C   Reserved                                       */ 
N  __IO uint32_t  BUFSEG4;                        /*!< Offset: 0x0060   USB Endpoint 4 Buffer Segmentation Register    */ 
X  volatile uint32_t  BUFSEG4;                          
N  __IO uint32_t  MXPLD4;                         /*!< Offset: 0x0064   USB Endpoint 4 Maximal Payload Register        */ 
X  volatile uint32_t  MXPLD4;                           
N  __IO uint32_t  CFG4;                           /*!< Offset: 0x0068   USB Endpoint 4 Configuration Register          */ 
X  volatile uint32_t  CFG4;                             
N       uint32_t  RESERVED5;                      /*!< Offset: 0x006C   Reserved                                       */ 
N  __IO uint32_t  BUFSEG5;                        /*!< Offset: 0x0070   USB Endpoint 5 Buffer Segmentation Register    */ 
X  volatile uint32_t  BUFSEG5;                          
N  __IO uint32_t  MXPLD5;                         /*!< Offset: 0x0074   USB Endpoint 5 Maximal Payload Register        */ 
X  volatile uint32_t  MXPLD5;                           
N  __IO uint32_t  CFG5;                           /*!< Offset: 0x0078   USB Endpoint 5 Configuration Register          */ 
X  volatile uint32_t  CFG5;                             
N       uint32_t  RESERVED6;                      /*!< Offset: 0x007C   Reserved                                       */ 
N  __IO uint32_t  BUFSEG6;                        /*!< Offset: 0x0080   USB Endpoint 6 Buffer Segmentation Register    */ 
X  volatile uint32_t  BUFSEG6;                          
N  __IO uint32_t  MXPLD6;                         /*!< Offset: 0x0084   USB Endpoint 6 Maximal Payload Register        */ 
X  volatile uint32_t  MXPLD6;                           
N  __IO uint32_t  CFG6;                           /*!< Offset: 0x0088   USB Endpoint 6 Configuration Register          */ 
X  volatile uint32_t  CFG6;                             
N       uint32_t  RESERVED7;                      /*!< Offset: 0x008C   Reserved                                       */ 
N  __IO uint32_t  BUFSEG7;                        /*!< Offset: 0x0090   USB Endpoint 7 Buffer Segmentation Register    */ 
X  volatile uint32_t  BUFSEG7;                          
N  __IO uint32_t  MXPLD7;                         /*!< Offset: 0x0094   USB Endpoint 7 Maximal Payload Register        */ 
X  volatile uint32_t  MXPLD7;                           
N  __IO uint32_t  CFG7;                           /*!< Offset: 0x0098   USB Endpoint 7 Configuration Register          */ 
X  volatile uint32_t  CFG7;                             
N       uint32_t  RESERVED8[2];                   /*!< Offset: 0x009C~0x00A0   Reserved                                       */ 
N  __IO uint32_t  PDMA;                           /*!< Offset: 0x00A4   USB PDMA Control Register                           */ 
X  volatile uint32_t  PDMA;                             
N} USBD_TypeDef;
N/*@}*/ /* end of group NANO1xx_USBD */
N
N
N/*------------- DAC (DAC) -----------------------------*/
N/** @addtogroup NANO1xx_DAC NANO1xx DAC Control Register (DAC)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CTL0;						/*!< Offset: 0x0000   DAC0 Control Register                              */
X  volatile uint32_t  CTL0;						 
N  __IO uint32_t  DATA0;						/*!< Offset: 0x0004   DAC0 Data Register                                 */
X  volatile uint32_t  DATA0;						 
N  __IO uint32_t  STS0;						/*!< Offset: 0x0008   DAC0 Status Register                               */
X  volatile uint32_t  STS0;						 
N  uint32_t  RESERVED0;						/*!< Offset: 0x000C   Reserved                                           */
N  __IO uint32_t  CTL1;						/*!< Offset: 0x0010   DAC1 Control Register                              */
X  volatile uint32_t  CTL1;						 
N  __IO uint32_t  DATA1;						/*!< Offset: 0x0014   DAC1 Data Register                                 */
X  volatile uint32_t  DATA1;						 
N  __IO uint32_t  STS1;						/*!< Offset: 0x0018   DAC1 Status Register                               */
X  volatile uint32_t  STS1;						 
N  uint32_t  RESERVED1;						/*!< Offset: 0x001C   Reserved                                           */
N  __IO uint32_t  COMCTL;					/*!< Offset: 0x0020   DAC01 Common Control Register                      */
X  volatile uint32_t  COMCTL;					 
N} DAC_TypeDef;
N/*@}*/ /* end of group NANO1xx_DAC */
N
N
N/*------------- LCD (LCD) -----------------------------*/
N/** @addtogroup NANO1xx_LCD NANO1xx LCD Control Register (LCD)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CTL;		/*!< Offset: 0x0000   LCD Control Register		    	   */
X  volatile uint32_t  CTL;		 
N  __IO uint32_t  DISPCTL;	/*!< Offset: 0x0004   LCD Display Control Register	      */
X  volatile uint32_t  DISPCTL;	 
N  __IO uint32_t  MEM_0;		/*!< Offset: 0x0008   LCD SEG3 ~ SEG0 data				  */
X  volatile uint32_t  MEM_0;		 
N  __IO uint32_t  MEM_1;		/*!< Offset: 0x000C   LCD SEG7 ~ SEG4 data				  */
X  volatile uint32_t  MEM_1;		 
N  __IO uint32_t  MEM_2;		/*!< Offset: 0x0010   LCD SEG11 ~ SEG8 data				  */
X  volatile uint32_t  MEM_2;		 
N  __IO uint32_t  MEM_3;		/*!< Offset: 0x0014   LCD SEG15 ~ SEG12 data			  */
X  volatile uint32_t  MEM_3;		 
N  __IO uint32_t  MEM_4;		/*!< Offset: 0x0018   LCD SEG19 ~ SEG16 data			  */
X  volatile uint32_t  MEM_4;		 
N  __IO uint32_t  MEM_5;		/*!< Offset: 0x001C   LCD SEG23 ~ SEG20 data			  */
X  volatile uint32_t  MEM_5;		 
N  __IO uint32_t  MEM_6;		/*!< Offset: 0x0020   LCD SEG27 ~ SEG24 data			  */
X  volatile uint32_t  MEM_6;		 
N  __IO uint32_t  MEM_7;		/*!< Offset: 0x0024   LCD SEG31 ~ SEG28 data			  */
X  volatile uint32_t  MEM_7;		 
N  __IO uint32_t  MEM_8;		/*!< Offset: 0x0028   LCD SEG35 ~ SEG32 data			  */
X  volatile uint32_t  MEM_8;		 
N  __IO uint32_t  MEM_9;		/*!< Offset: 0x002C   LCD SEG39 ~ SEG36 data			  */
X  volatile uint32_t  MEM_9;		 
N  __IO uint32_t  FCR;		/*!< Offset: 0x0030   LCD frame counter control register  */
X  volatile uint32_t  FCR;		 
N  __IO uint32_t  FCSTS;		/*!< Offset: 0x0034   LCD frame counter status			  */
X  volatile uint32_t  FCSTS;		 
N} LCD_TypeDef;
N/*@}*/ /* end of group NANO1xx_LCD */
N
N
N/*  
N * @brief Capacitive Touch-Key Sensing Engine
N */
N /*------------- Touch-Key Sensing Engine -----------------------------*/
N/** @addtogroup NANO1xx_TK NANO1xx TK Control Register (TK)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CTL1;						/*!< Offset: 0x0000  Touch Key Control Register 1				 	 	 */
X  volatile uint32_t  CTL1;						 
N  __IO uint32_t  CTL2;						/*!< Offset: 0x0004  Touch Key Control Register 2				 	 	 */
X  volatile uint32_t  CTL2;						 
N  __IO uint32_t  CTL3;						/*!< Offset: 0x0008  Touch Key Control Register 3				 	 	 */
X  volatile uint32_t  CTL3;						 
N  __IO uint32_t  STAT;						/*!< Offset: 0x000C  Touch Key Status Register  				 	 	 */
X  volatile uint32_t  STAT;						 
N  __IO uint32_t  DATA1;						/*!< Offset: 0x0010  Touch Key Data Register 1					 	 	 */
X  volatile uint32_t  DATA1;						 
N  __IO uint32_t  DATA2;						/*!< Offset: 0x0014  Touch Key Data Register 2					 	 	 */
X  volatile uint32_t  DATA2;						 
N  __IO uint32_t  DATA3;						/*!< Offset: 0x0018  Touch Key Data Register 3					 	 	 */
X  volatile uint32_t  DATA3;						 
N  __IO uint32_t  DATA4;						/*!< Offset: 0x001C  Touch Key Data Register 4					 	 	 */
X  volatile uint32_t  DATA4;						 
N  __IO uint32_t  INTEN;						/*!< Offset: 0x0020  Touch Key Interrupt Enable Register		 	 	 */
X  volatile uint32_t  INTEN;						 
N  __IO uint32_t  TK8_0_THC;					/*!< Offset: 0x0024  TK8/TK0 Threshold Control Register			 	 	 */
X  volatile uint32_t  TK8_0_THC;					 
N  __IO uint32_t  TK9_1_THC;					/*!< Offset: 0x0028  TK9/TK1 Threshold Control Register			 	 	 */
X  volatile uint32_t  TK9_1_THC;					 
N  __IO uint32_t  TK10_2_THC;				/*!< Offset: 0x002C  TK10/TK2 Threshold Control Register		 	 	 */
X  volatile uint32_t  TK10_2_THC;				 
N  __IO uint32_t  TK11_3_THC;				/*!< Offset: 0x0030  TK11/TK3 Threshold Control Register		 	 	 */
X  volatile uint32_t  TK11_3_THC;				 
N  __IO uint32_t  TK12_4_THC;				/*!< Offset: 0x0034  TK12/TK4 Threshold Control Register		 	 	 */
X  volatile uint32_t  TK12_4_THC;				 
N  __IO uint32_t  TK13_5_THC;				/*!< Offset: 0x0038  TK13/TK5 Threshold Control Register		 	 	 */
X  volatile uint32_t  TK13_5_THC;				 
N  __IO uint32_t  TK14_6_THC;				/*!< Offset: 0x003C  TK14/TK6 Threshold Control Register		 	 	 */
X  volatile uint32_t  TK14_6_THC;				 
N  __IO uint32_t  TK15_7_THC;				/*!< Offset: 0x0040  TK15/TK7 Threshold Control Register		 	 	 */
X  volatile uint32_t  TK15_7_THC;				 
N} TK_TypeDef;
N/*@}*/ /* end of group NANO1xx_TK */
N
N
N/*------------- Timer Control Register (TIMER) -----------------------------*/
N/** @addtogroup NANO1xx_TIMER NANO1xx TIMER Control Register (TIMER)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  CTL;						/*!< Offset: 0x0000   Timer Control Register        			         */
X  volatile uint32_t  CTL;						 
N  __IO uint32_t  PRECNT;					/*!< Offset: 0x0004   Timer Pre-Scale Counter Register      			 */
X  volatile uint32_t  PRECNT;					 
N  __IO uint32_t  CMPR;						/*!< Offset: 0x0008   Timer Compare Register             			     */
X  volatile uint32_t  CMPR;						 
N  __IO uint32_t  IER;						/*!< Offset: 0x000C   Timer Interrupt Enable Register 				     */
X  volatile uint32_t  IER;						 
N  __IO uint32_t  ISR;						/*!< Offset: 0x0010   Timer Interrupt Status Register        			 */
X  volatile uint32_t  ISR;						 
N  __I  uint32_t  DR;						/*!< Offset: 0x0014   Timer Data Register      				  			 */
X  volatile const  uint32_t  DR;						 
N  __I  uint32_t  TCAP;						/*!< Offset: 0x0018   Timer Capture Data Register 			  			 */
X  volatile const  uint32_t  TCAP;						 
N} TIMER_TypeDef;
N/*@}*/ /* end of group NANO1xx_TIMER */
N
N
N/*----------------------------- PWM Controller ----------------------------*/
N/** @addtogroup NANO1xx_PWM NANO1xx PWM Control Register (PWM)
N  @{
N*/
Ntypedef struct
N{
N  __IO uint32_t  PRES;						/*!< Offset: 0x0000   PWM Prescaler Register 				 	  		 */
X  volatile uint32_t  PRES;						 
N  __IO uint32_t  CLKSEL;					/*!< Offset: 0x0004   PWM Clock Select Register 			 	  		 */
X  volatile uint32_t  CLKSEL;					 
N  __IO uint32_t  CTL;						/*!< Offset: 0x0008   PWM Ccontrol Register 				 	  		 */
X  volatile uint32_t  CTL;						 
N  __IO uint32_t  INTEN;						/*!< Offset: 0x000C   PWM Interrupt Enable Register 		 	  		 */
X  volatile uint32_t  INTEN;						 
N  __IO uint32_t  INTSTS;					/*!< Offset: 0x0010   PWM Interrupt Indication Register		 	  		 */
X  volatile uint32_t  INTSTS;					 
N  __IO uint32_t  OE;						/*!< Offset: 0x0014   PWM Output Enable Register			 	  		 */
X  volatile uint32_t  OE;						 
N       uint32_t  RESERVED0;					/*!< Offset: 0x0018   Reserved                                           */
N  __IO uint32_t  DUTY0;						/*!< Offset: 0x001C   PWM Counter/Comparator Register 0		 	  		 */
X  volatile uint32_t  DUTY0;						 
N       uint32_t  RESERVED1[2];				/*!< Offset: 0x0020 ~ 0x0024 Reserved	                                 */
N  __IO uint32_t  DUTY1;						/*!< Offset: 0x0028  PWM Counter/Comparator Register 1		 	  		 */
X  volatile uint32_t  DUTY1;						 
N       uint32_t  RESERVED2[2];				/*!< Offset: 0x002C ~ 0x0030 Reserved	                                 */
N  __IO uint32_t  DUTY2;						/*!< Offset: 0x0034  PWM Counter/Comparator Register 2		 	  		 */
X  volatile uint32_t  DUTY2;						 
N       uint32_t  RESERVED3[2];				/*!< Offset: 0x0038 ~ 0x003C Reserved	                                 */
N  __IO uint32_t  DUTY3;						/*!< Offset: 0x0040  PWM Counter/Comparator Register 3		 	  		 */
X  volatile uint32_t  DUTY3;						 
N       uint32_t  RESERVED4[4];				/*!< Offset: 0x0044 ~ 0x0050 Reserved	                                 */
N  __IO uint32_t  CAPCTL;					/*!< Offset: 0x0054  Capture Control Register				 	  		 */
X  volatile uint32_t  CAPCTL;					 
N  __IO uint32_t  CAPINTEN;					/*!< Offset: 0x0058  Capture Interrupt Enable Register			 	 	 */
X  volatile uint32_t  CAPINTEN;					 
N  __IO uint32_t  CAPINTSTS;					/*!< Offset: 0x005C  Capture Interrupt Indication Register		 	 	 */
X  volatile uint32_t  CAPINTSTS;					 
N  __I  uint32_t  CRL0;						/*!< Offset: 0x0060  Capture Rising Latch Register 0			 	 	 */
X  volatile const  uint32_t  CRL0;						 
N  __I  uint32_t  CFL0;						/*!< Offset: 0x0064  Capture Falling Latch Register 0			 	 	 */
X  volatile const  uint32_t  CFL0;						 
N  __I  uint32_t  CRL1;						/*!< Offset: 0x0068  Capture Rising Latch Register 1			 	 	 */
X  volatile const  uint32_t  CRL1;						 
N  __I  uint32_t  CFL1;						/*!< Offset: 0x006C  Capture Falling Latch Register 1			 	 	 */
X  volatile const  uint32_t  CFL1;						 
N  __I  uint32_t  CRL2;						/*!< Offset: 0x0070  Capture Rising Latch Register 2			 	 	 */
X  volatile const  uint32_t  CRL2;						 
N  __I  uint32_t  CFL2;						/*!< Offset: 0x0074  Capture Falling Latch Register 2			 	 	 */
X  volatile const  uint32_t  CFL2;						 
N  __I  uint32_t  CRL3;						/*!< Offset: 0x0078  Capture Rising Latch Register 3			 	 	 */
X  volatile const  uint32_t  CRL3;						 
N  __I  uint32_t  CFL3;						/*!< Offset: 0x007C  Capture Falling Latch Register 3			 	 	 */
X  volatile const  uint32_t  CFL3;						 
N  __I  uint32_t  CH0PDMA;					/*!< Offset: 0x0080  PDMA channel 0 captured data				 	 	 */
X  volatile const  uint32_t  CH0PDMA;					 
N  __I  uint32_t  CH2PDMA;					/*!< Offset: 0x0084  PDMA channel 1 captured data				 	 	 */
X  volatile const  uint32_t  CH2PDMA;					 
N} PWM_TypeDef;
N/*@}*/ /* end of group NANO1xx_PWM */
N
N
N/*-------------------- Serial Peripheral Interface (SPI) ----------------------*/
N/** @addtogroup NANO1xx_SPI NANO1xx Serial Peripheral Interface (SPI)
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t  CTL;						/*!< Offset: 0x0000   SPI Control Register                               */
X  volatile uint32_t  CTL;						 
N  __IO uint32_t  STATUS;					/*!< Offset: 0x0004   SPI Status  Register                               */
X  volatile uint32_t  STATUS;					 
N  __IO uint32_t  CLKDIV;					/*!< Offset: 0x0008   SPI Serial Clock Divider Register                  */
X  volatile uint32_t  CLKDIV;					 
N  __IO uint32_t  SSR;						/*!< Offset: 0x000C   SPI Slave Select Register                          */
X  volatile uint32_t  SSR;						 
N  __I  uint32_t  RX0;						/*!< Offset: 0x0010   SPI Receive Data FIFO Register 0                   */
X  volatile const  uint32_t  RX0;						 
N  __I  uint32_t  RX1;						/*!< Offset: 0x0014   SPI Receive Data FIFO Register 1                   */
X  volatile const  uint32_t  RX1;						 
N       uint32_t  RESERVED0;
N       uint32_t  RESERVED1;
N  __O  uint32_t  TX0;						/*!< Offset: 0x0020   SPI Transmit Data FIFO Register 0                  */
X  volatile  uint32_t  TX0;						 
N  __O  uint32_t  TX1;						/*!< Offset: 0x0024   SPI Transmit Data FIFO Register 1                  */
X  volatile  uint32_t  TX1;						 
N       uint32_t  RESERVED2;
N       uint32_t  RESERVED3;
N       uint32_t  RESERVED4;
N  __IO uint32_t  VARCLK;					/*!< Offset: 0x0034   SPI Variable Clock Pattern Flag Register           */
X  volatile uint32_t  VARCLK;					 
N  __IO uint32_t  PDMA;						/*!< Offset: 0x0038   SPI PDMA Control Register                          */
X  volatile uint32_t  PDMA;						 
N  __IO uint32_t  FF_CTL;					/*!< Offset: 0x003C   SPI FIFO Control Register                          */
X  volatile uint32_t  FF_CTL;					 
N} SPI_TypeDef;
N/*@}*/ /* end of group NANO1xx_SPI */
N
N
N/*------------- UART -----------------------------*/
N/** @addtogroup NANO1xx_UART NANO1xx UART Control Register (UART)
N  @{
N*/
Ntypedef struct
N{
N  union {
N  __I  uint32_t  RBR;		/*!< Offset: 0x0000   UART Receive Buffer Register  	       */
X  volatile const  uint32_t  RBR;		 
N  __O  uint32_t  THR;		/*!< Offset: 0x0000   UART Transmit Holding Register  	       */
X  volatile  uint32_t  THR;		 
N  };
N  __IO uint32_t  CTL;		/*!< Offset: 0x0004   UART Control State Register	  	       */
X  volatile uint32_t  CTL;		 
N  __IO uint32_t  TLCTL;		/*!< Offset: 0x0008   UART Transfer Line Control Register       */
X  volatile uint32_t  TLCTL;		 
N  __IO uint32_t  IER;		/*!< Offset: 0x000C   UART Interrupt Enable Register	       */
X  volatile uint32_t  IER;		 
N  __IO uint32_t  ISR;		/*!< Offset: 0x0010   UART Interrupt Status Register	       */
X  volatile uint32_t  ISR;		 
N  __IO uint32_t  TRSR;		/*!< Offset: 0x0014   UART Transfer State Status Register       */
X  volatile uint32_t  TRSR;		 
N  __IO uint32_t  FSR;		/*!< Offset: 0x0018   UART FIFO State Status Register	       */
X  volatile uint32_t  FSR;		 
N  __IO uint32_t  MCSR;		/*!< Offset: 0x001C   UART Modem State Status Register	       */
X  volatile uint32_t  MCSR;		 
N  __IO uint32_t  TMCTL;		/*!< Offset: 0x0020   UART Time-Out Control State Register       */
X  volatile uint32_t  TMCTL;		 
N  __IO uint32_t  BAUD;		/*!< Offset: 0x0024   UART Baud Rate Divisor Register     		  */
X  volatile uint32_t  BAUD;		 
N  uint32_t  RESERVED0[2];
N  __IO uint32_t  IRCR;		/*!< Offset: 0x0030   UART IrDA Control Register	     		  */
X  volatile uint32_t  IRCR;		 
N  __IO uint32_t  ALT_CTL;	/*!< Offset: 0x0034   UART Alternate Control State Register		  */
X  volatile uint32_t  ALT_CTL;	 
N  __IO uint32_t  FUN_SEL;	/*!< Offset: 0x0038   UART Function Select Register				  */
X  volatile uint32_t  FUN_SEL;	 
N} UART_TypeDef;
N/*@}*/ /* end of group NANO1xx_UART */		    
N
N
N
N/*
N * @brief GPIO shadow registers
N */
N/*------------- GPIO Shadow Registers (SHADOW) -----------------------------*/
N/** @addtogroup NANO1xx_SHADOW NANO1xx GPIO Shadow Register (SHADOW)
N  @{
N*/ 
Ntypedef struct
N{
N   __I uint32_t  GPA_SHADOW;				/*!< Offset: 0x0000   GPIO Port A Pin Value Shadow Register 	  		 */
X   volatile const uint32_t  GPA_SHADOW;				 
N   __I uint32_t  GPB_SHADOW;				/*!< Offset: 0x0004   GPIO Port B Pin Value Shadow Register 	  		 */
X   volatile const uint32_t  GPB_SHADOW;				 
N   __I uint32_t  GPC_SHADOW;				/*!< Offset: 0x0008   GPIO Port C Pin Value Shadow Register 	  		 */
X   volatile const uint32_t  GPC_SHADOW;				 
N   __I uint32_t  GPD_SHADOW;				/*!< Offset: 0x000C   GPIO Port D Pin Value Shadow Register 	  		 */
X   volatile const uint32_t  GPD_SHADOW;				 
N   __I uint32_t  GPE_SHADOW;				/*!< Offset: 0x0010   GPIO Port E Pin Value Shadow Register 	  		 */
X   volatile const uint32_t  GPE_SHADOW;				 
N   __I uint32_t  GPF_SHADOW;				/*!< Offset: 0x0014   GPIO Port F Pin Value Shadow Register 	  		 */
X   volatile const uint32_t  GPF_SHADOW;				 
N} SHADOW_TypeDef;
N/*@}*/ /* end of group NANO1xx_SHADOW */
N
N
N
N/*------------- I2C Serial Interface Controller (Master/Slave) (I2C) -----------------------------*/
N/** @addtogroup NANO1xx_I2C NANO1xx I2C Controller Register (I2C)
N  @{
N*/
Ntypedef struct
N{
N   __IO uint32_t  CON;					/*!< Offset: 0x0000   I2C Control Register                               */
X   volatile uint32_t  CON;					 
N   __IO uint32_t  INTSTS;				/*!< Offset: 0x0004   I2C Control Flag Register                          */
X   volatile uint32_t  INTSTS;				 
N   __I  uint32_t  STATUS;				/*!< Offset: 0x0008   I2C Status Register                                */
X   volatile const  uint32_t  STATUS;				 
N   __IO uint32_t  DIV;					/*!< Offset: 0x000C   I2C Clock Divided Register                         */
X   volatile uint32_t  DIV;					 
N   __IO uint32_t  TOUT;					/*!< Offset: 0x0010   I2C Time Out Control Register                      */
X   volatile uint32_t  TOUT;					 
N   __IO uint32_t  DATA;					/*!< Offset: 0x0014   I2C Data Register                                  */
X   volatile uint32_t  DATA;					 
N   __IO uint32_t  SADDR0;				/*!< Offset: 0x0018   Slave Address Register 0                           */
X   volatile uint32_t  SADDR0;				 
N   __IO uint32_t  SADDR1;				/*!< Offset: 0x001C   Slave Address Register 1                           */
X   volatile uint32_t  SADDR1;				 
N        uint32_t  RESERVED0;
N        uint32_t  RESERVED1;
N   __IO uint32_t  SAMASK0;				/*!< Offset: 0x0028   Slave Address Mask Register 0                      */
X   volatile uint32_t  SAMASK0;				 
N   __IO uint32_t  SAMASK1;				/*!< Offset: 0x002C   Slave Address Mask Register 1                      */
X   volatile uint32_t  SAMASK1;				 
N   		uint32_t  RESERVED2[4];
N   __IO uint32_t  WKUPCON;				/*!< Offset: 0x003C   I2C Wake-up Control Register                       */
X   volatile uint32_t  WKUPCON;				 
N   __IO uint32_t  WKUPSTS;				/*!< Offset: 0x0040   I2C Wake-up Status Register                        */
X   volatile uint32_t  WKUPSTS;				 
N  
N} I2C_TypeDef;
N/*@}*/ /* end of group NANO1xx_I2C */
N
N
N/*------------- Smart Card Control Register (SC) -----------------------------*/
N/** @addtogroup NANO1xx_SC NANO1xx Smart Card Control Register (SC)
N  @{
N*/
Ntypedef struct
N{
N  union {
N  __I  uint32_t  RBR;						/*!< Offset: 0x0000  SC Receiving Buffer Register				 	 	 */
X  volatile const  uint32_t  RBR;						 
N  __O  uint32_t  THR;						/*!< Offset: 0x0000  SC Transmit Holding Register				 	 	 */
X  volatile  uint32_t  THR;						 
N  };
N  __IO uint32_t  CTL;						/*!< Offset: 0x0004  SC Control Register						 	 	 */
X  volatile uint32_t  CTL;						 
N  __IO uint32_t  ALTCTL;					/*!< Offset: 0x0008  SC Alternate Control Register				 	 	 */
X  volatile uint32_t  ALTCTL;					 
N  __IO uint32_t  EGTR;						/*!< Offset: 0x000C  SC Extend Guard Time Register				 	 	 */
X  volatile uint32_t  EGTR;						 
N  __IO uint32_t  RFTMR;						/*!< Offset: 0x0010  SC Receive Buffer Time-Out Register		 	 	 */
X  volatile uint32_t  RFTMR;						 
N  __IO uint32_t  ETUCR;						/*!< Offset: 0x0014  SC ETU Control Register					 	 	 */
X  volatile uint32_t  ETUCR;						 
N  __IO uint32_t  IER;						/*!< Offset: 0x0018  SC Interrupt Enable Register				 	 	 */
X  volatile uint32_t  IER;						 
N  __IO uint32_t  ISR;						/*!< Offset: 0x001C  SC Interrupt Status Register				 	 	 */
X  volatile uint32_t  ISR;						 
N  __IO uint32_t  TRSR;						/*!< Offset: 0x0020  SC Transfer Status Register				 	 	 */
X  volatile uint32_t  TRSR;						 
N  __IO uint32_t  PINCSR;					/*!< Offset: 0x0024  SC Pin Control State Register				 	 	 */
X  volatile uint32_t  PINCSR;					 
N  __IO uint32_t  TMR0;						/*!< Offset: 0x0028  SC Internal Timer Control Register 0		 	 	 */
X  volatile uint32_t  TMR0;						 
N  __IO uint32_t  TMR1;						/*!< Offset: 0x002C  SC Internal Timer Control Register 1		 	 	 */
X  volatile uint32_t  TMR1;						 
N  __IO uint32_t  TMR2;						/*!< Offset: 0x0030  SC Internal Timer Control Register 2		 	 	 */
X  volatile uint32_t  TMR2;						 
N  __IO uint32_t  UACTL;						/*!< Offset: 0x0034  SC UART Mode Control Register				 	 	 */
X  volatile uint32_t  UACTL;						 
N  __I  uint32_t  TDRA;
X  volatile const  uint32_t  TDRA;
N  __I  uint32_t  TDRB;  
X  volatile const  uint32_t  TDRB;  
N} SC_TypeDef;
N/*@}*/ /* end of group NANO1xx_SC */
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/*@}*/ /* end of group NANO1xx_Peripherals */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup NANO1xx_MemoryMap NANO1xx Memory Mapping
N  @{
N*/
N
N/* Peripheral and SRAM base address */
N//#define <DeviceAbbreviation>_FLASH_BASE       (0x00000000UL)           /*!< (FLASH     ) Base Address */
N#define SRAM_BASE            (0x20000000UL)                              /*!< (SRAM      ) Base Address */
N#define PERIPH_BASE          (0x40000000UL)                              /*!< (Peripheral) Base Address */
N
N
N/* Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x100000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x10000000)
N
N#define WDT_BASE	          (APB1PERIPH_BASE + 0x04000)
N#define WWDT_BASE	          (APB1PERIPH_BASE + 0x04100)
N#define RTC_BASE	          (APB1PERIPH_BASE + 0x08000)
N#define TIMER0_BASE	          (APB1PERIPH_BASE + 0x10000)
N#define TIMER1_BASE	          (APB1PERIPH_BASE + 0x10100)
N#define I2C0_BASE	          (APB1PERIPH_BASE + 0x20000)
N#define SPI0_BASE	          (APB1PERIPH_BASE + 0x30000)
N#define PWM0_BASE	          (APB1PERIPH_BASE + 0x40000)
N#define UART0_BASE	          (APB1PERIPH_BASE + 0x50000)
N#define USBD_BASE	          (APB1PERIPH_BASE + 0x60000)
N#define USBD_SRAM_BASE	      (APB1PERIPH_BASE + 0x60100)
N#define DAC_BASE	          (APB1PERIPH_BASE + 0xA0000)
N#define LCD_BASE	          (APB1PERIPH_BASE + 0xB0000)
N#define TK_BASE	              (APB1PERIPH_BASE + 0xC0000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0xD0000)
N#define ADC_BASE	          (APB1PERIPH_BASE + 0xE0000)
N
N#define TIMER2_BASE	          (APB2PERIPH_BASE + 0x10000)
N#define TIMER3_BASE	          (APB2PERIPH_BASE + 0x10100)
N#define SHADOW_BASE	   		  (APB1PERIPH_BASE + 0x10200)
N#define I2C1_BASE	          (APB2PERIPH_BASE + 0x20000)
N#define SPI1_BASE	          (APB2PERIPH_BASE + 0x30000)
N#define PWM1_BASE	          (APB2PERIPH_BASE + 0x40000)
N#define UART1_BASE	          (APB2PERIPH_BASE + 0x50000)
N#define SC0_BASE	          (APB2PERIPH_BASE + 0x90000)
N#define I2S_BASE	          (APB2PERIPH_BASE + 0xA0000)
N#define SC1_BASE	          (APB2PERIPH_BASE + 0xB0000)
N#define SC2_BASE	          (APB2PERIPH_BASE + 0xC0000)
N
N#define GCR_BASE	          (AHBPERIPH_BASE + 0x00000)
N#define CLK_BASE	          (AHBPERIPH_BASE + 0x00200)
N#define INTID_BASE	          (AHBPERIPH_BASE + 0x00300)
N#define GPIOA_BASE	          (AHBPERIPH_BASE + 0x04000)
N#define GPIOB_BASE	          (AHBPERIPH_BASE + 0x04040)
N#define GPIOC_BASE	          (AHBPERIPH_BASE + 0x04080)
N#define GPIOD_BASE	          (AHBPERIPH_BASE + 0x040C0)
N#define GPIOE_BASE	          (AHBPERIPH_BASE + 0x04100)
N#define GPIOF_BASE	          (AHBPERIPH_BASE + 0x04140)
N#define GPIODBNCE_BASE	      (AHBPERIPH_BASE + 0x04180)
N#define GPIOBITA_BASE	      (AHBPERIPH_BASE + 0x04200)
N#define GPIOBITB_BASE	      (AHBPERIPH_BASE + 0x04240)
N#define GPIOBITC_BASE	      (AHBPERIPH_BASE + 0x04280)
N#define GPIOBITD_BASE	      (AHBPERIPH_BASE + 0x042C0)
N#define GPIOBITE_BASE	      (AHBPERIPH_BASE + 0x04300)
N#define GPIOBITF_BASE	      (AHBPERIPH_BASE + 0x04340)
N#define VDMA_BASE	          (AHBPERIPH_BASE + 0x08000)
N#define PDMA1_BASE	          (AHBPERIPH_BASE + 0x08100)
N#define PDMA2_BASE	          (AHBPERIPH_BASE + 0x08200)
N#define PDMA3_BASE	          (AHBPERIPH_BASE + 0x08300)
N#define PDMA4_BASE	          (AHBPERIPH_BASE + 0x08400)
N#define PDMA5_BASE	          (AHBPERIPH_BASE + 0x08500)
N#define PDMA6_BASE	          (AHBPERIPH_BASE + 0x08600)
N#define PDMACRC_BASE          (AHBPERIPH_BASE + 0x08E00)
N#define PDMAGCR_BASE	      (AHBPERIPH_BASE + 0x08F00)
N#define FMC_BASE	          (AHBPERIPH_BASE + 0x0C000)
N#define EBI_BASE	          (AHBPERIPH_BASE + 0x10000)
N
N/*@}*/ /* end of group <Device>_MemoryMap */
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N/** @addtogroup NANO1xx_PeripheralDecl NANO1xx Peripheral Declaration
N  @{
N*/
N#define WDT                   ((WDT_TypeDef *) WDT_BASE)
N#define WWDT                  ((WWDT_TypeDef *) WWDT_BASE)
N#define RTC                   ((RTC_TypeDef *) RTC_BASE)
N#define TIMER0                ((TIMER_TypeDef *) TIMER0_BASE)
N#define TIMER1   	          ((TIMER_TypeDef *) TIMER1_BASE)
N#define TIMER2                ((TIMER_TypeDef *) TIMER2_BASE)
N#define TIMER3   	          ((TIMER_TypeDef *) TIMER3_BASE)
N#define SHADOW                ((SHADOW_TypeDef *) SHADOW_BASE)
N#define I2C0                  ((I2C_TypeDef *) I2C0_BASE)
N#define I2C1                  ((I2C_TypeDef *) I2C1_BASE)
N#define SPI0                  ((SPI_TypeDef *) SPI0_BASE)
N#define SPI1                  ((SPI_TypeDef *) SPI1_BASE)
N#define SPI2                  ((SPI_TypeDef *) SPI2_BASE)
N#define PWM0                  ((PWM_TypeDef *) PWM0_BASE)
N#define PWM1                  ((PWM_TypeDef *) PWM1_BASE)
N#define UART0                 ((UART_TypeDef *) UART0_BASE)
N#define UART1                 ((UART_TypeDef *) UART1_BASE)
N#define USBD                  ((USBD_TypeDef *) USBD_BASE)
N#define DAC                   ((DAC_TypeDef *) DAC_BASE)
N#define LCD                   ((LCD_TypeDef *) LCD_BASE)
N#define TK                    ((TK_TypeDef *) TK_BASE)
N#define ADC                   ((ADC_TypeDef *) ADC_BASE)
N#define SC0                    ((SC_TypeDef *) SC0_BASE)
N#define I2S                   ((I2S_TypeDef *) I2S_BASE)
N#define SC1                    ((SC_TypeDef *) SC1_BASE)
N#define SC2                    ((SC_TypeDef *) SC2_BASE)
N
N
N#define GCR                   ((GCR_TypeDef *) GCR_BASE)
N#define CLK                   ((CLK_TypeDef *) CLK_BASE)
N#define INTID                 ((INTID_TypeDef *) INTID_BASE)
N#define GPIOA                 ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB                 ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC                 ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD                 ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE                 ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF                 ((GPIO_TypeDef *) GPIOF_BASE)
N#define GPIODBNCE             ((GPIODBNCE_TypeDef *) GPIODBNCE_BASE)
N#define GPIOBITA              ((GPIOBIT_TypeDef *) GPIOBITA_BASE)
N#define GPIOBITB              ((GPIOBIT_TypeDef *) GPIOBITB_BASE)
N#define GPIOBITC              ((GPIOBIT_TypeDef *) GPIOBITC_BASE)
N#define GPIOBITD              ((GPIOBIT_TypeDef *) GPIOBITD_BASE)
N#define GPIOBITE              ((GPIOBIT_TypeDef *) GPIOBITE_BASE)
N#define GPIOBITF              ((GPIOBIT_TypeDef *) GPIOBITF_BASE)
N#define VDMA                  ((VDMA_TypeDef *) VDMA_BASE)
N#define PDMA1                 ((PDMA_TypeDef *) PDMA1_BASE)
N#define PDMA2                 ((PDMA_TypeDef *) PDMA2_BASE)
N#define PDMA3                 ((PDMA_TypeDef *) PDMA3_BASE)
N#define PDMA4                 ((PDMA_TypeDef *) PDMA4_BASE)
N#define PDMA5                 ((PDMA_TypeDef *) PDMA5_BASE)
N#define PDMA6                 ((PDMA_TypeDef *) PDMA6_BASE)
N#define PDMACRC               ((PDMACRC_TypeDef *) PDMACRC_BASE)
N#define PDMAGCR               ((PDMAGCR_TypeDef *) PDMAGCR_BASE)
N#define FMC                   ((FMC_TypeDef *) FMC_BASE)
N#define EBI                   ((EBI_TypeDef *) EBI_BASE)
N
N/*@}*/ /* end of group NANO1xx_PeripheralDecl */
N
N
N/******************************************************************************/
N/*                Device Specific Constants                                   */
N/******************************************************************************/
N/** @addtogroup NANO1xx_Exported_Constants NANO1xx Exported Constants
N  NANO1xx Device Specific Constantss
N  @{
N*/
N
N/******************************************************************************/
N/*                GCR                                                         */
N/******************************************************************************/
N/********************* Bit definition of RSTSRC register **********************/
N#define GCR_RSTSRC_POR				((uint32_t)0x00000001)			/*!<Power on reset flag */
N#define GCR_RSTSRC_RESET			((uint32_t)0x00000002)			/*!<RESET pin reset flag */
N#define GCR_RSTSRC_WDT				((uint32_t)0x00000004)			/*!<Watchdog timer reset flag */
N#define GCR_RSTSRC_BOD				((uint32_t)0x00000010)			/*!<BOD reset flag */
N#define GCR_RSTSRC_SYS				((uint32_t)0x00000020)			/*!<System reset flag */
N#define GCR_RSTSRC_CPU				((uint32_t)0x00000080)			/*!<CPU reset flag */
N
N/********************* Bit definition of IPRSTCTL1 register **********************/
N#define GCR_IPRSTCTL1_CHIP			((uint32_t)0x00000001)			/*!<Chip oneshot reset */
N#define GCR_IPRSTCTL1_CPU			((uint32_t)0x00000002)			/*!<CPU oneshot reset */
N#define GCR_IPRSTCTL1_DMA			((uint32_t)0x00000004)			/*!<DMA reset */
N#define GCR_IPRSTCTL1_EBI			((uint32_t)0x00000008)			/*!<EBI reset */
N
N/********************* Bit definition of IPRSTCTL2 register **********************/
N#define GCR_IPRSTCTL2_GPIO			((uint32_t)0x00000002)			/*!<GPIO reset */
N#define GCR_IPRSTCTL2_TMR0			((uint32_t)0x00000004)			/*!<Timer 0 reset */
N#define GCR_IPRSTCTL2_TMR1			((uint32_t)0x00000008)			/*!<Timer 1 reset */
N#define GCR_IPRSTCTL2_TMR2			((uint32_t)0x00000010)			/*!<Timer 2 reset */
N#define GCR_IPRSTCTL2_TMR3			((uint32_t)0x00000020)			/*!<Timer 3 reset */
N#define GCR_IPRSTCTL2_SC2			((uint32_t)0x00000080)			/*!<SC 2 reset */
N#define GCR_IPRSTCTL2_I2C0			((uint32_t)0x00000100)			/*!<I2C 0 reset */
N#define GCR_IPRSTCTL2_I2C1			((uint32_t)0x00000200)			/*!<I2C 1 reset */
N#define GCR_IPRSTCTL2_SPI0			((uint32_t)0x00001000)			/*!<SPI 0 reset */
N#define GCR_IPRSTCTL2_SPI1			((uint32_t)0x00002000)			/*!<SPI 1 reset */
N#define GCR_IPRSTCTL2_SPI2			((uint32_t)0x00004000)			/*!<SPI 2 reset */
N#define GCR_IPRSTCTL2_UART0			((uint32_t)0x00010000)			/*!<UART 0 reset */
N#define GCR_IPRSTCTL2_UART1			((uint32_t)0x00020000)			/*!<UART 1 reset */
N#define GCR_IPRSTCTL2_PWM0			((uint32_t)0x00100000)			/*!<PWM 0 reset */
N#define GCR_IPRSTCTL2_PWM1			((uint32_t)0x00200000)			/*!<PWM 1 reset */
N#define GCR_IPRSTCTL2_TK			((uint32_t)0x01000000)			/*!<TK reset */
N#define GCR_IPRSTCTL2_DAC			((uint32_t)0x02000000)			/*!<DAC reset */
N#define GCR_IPRSTCTL2_LCD			((uint32_t)0x04000000)			/*!<LCD reset */
N#define GCR_IPRSTCTL2_USBD			((uint32_t)0x08000000)			/*!<USB device reset */
N#define GCR_IPRSTCTL2_ADC			((uint32_t)0x10000000)			/*!<ADC reset */
N#define GCR_IPRSTCTL2_I2S			((uint32_t)0x20000000)			/*!<I2S reset */
N#define GCR_IPRSTCTL2_SC0			((uint32_t)0x40000000)			/*!<SC0 reset */
N#define GCR_IPRSTCTL2_SC1			((uint32_t)0x80000000)			/*!<SC1 reset */
N
N/********************* Bit definition of BODCTL register **********************/
N#define GCR_BODCTL_17EN				((uint32_t)0x00000001)			/*!<Detector 1.7V Function Enable */
N#define GCR_BODCTL_20EN				((uint32_t)0x00000002)			/*!<Detector 2.0V Function Enable */
N#define GCR_BODCTL_25EN				((uint32_t)0x00000004)			/*!<Detector 2.5V Function Enable */
N#define GCR_BODCTL_17RSTEN			((uint32_t)0x00000010)			/*!<1.7V Reset Enable */
N#define GCR_BODCTL_20RSTEN			((uint32_t)0x00000020)			/*!<2.0V Reset Enable */
N#define GCR_BODCTL_25RSTEN			((uint32_t)0x00000040)			/*!<2.5V Reset Enable */
N#define GCR_BODCTL_17INTEN			((uint32_t)0x00000100)			/*!<1.7V Interrupt Enable */
N#define GCR_BODCTL_20INTEN			((uint32_t)0x00000200)			/*!<2.0V Interrupt Enable */
N#define GCR_BODCTL_25INTEN			((uint32_t)0x00000400)			/*!<2.5V Interrupt Enable */
N
N/********************* Bit definition of VREFCTL register **********************/
N#define GCR_VREFCTL_BGP_EN			((uint32_t)0x00000001)			/*!<Band-gap Enable */
N#define GCR_VREFCTL_REG_EN			((uint32_t)0x00000002)			/*!<Regulator Enable */
N#define GCR_VREFCTL_SEL25			((uint32_t)0x00000004)			/*!<Regulator Output Voltage 2.5V */
N#define GCR_VREFCTL_SEL18			((uint32_t)0x00000000)			/*!<Regulator Output Voltage 1.8V */
N#define GCR_VREFCTL_EXTMODE			((uint32_t)0x00000008)			/*!<Regulator External Mode */
N
N/********************* Bit definition of IRCTRIMCTL register **********************/
N#define GCR_IRCTRIMCTL_SEL_MASK		((uint32_t)0x00000003)			/*!<Trim frequency selection mask */
N#define GCR_IRCTRIMCTL_TRIM_DISABLE	((uint32_t)0x00000000)			/*!<Disable auto-trim function */
N#define GCR_IRCTRIMCTL_TRIM_11M		((uint32_t)0x00000001)			/*!<Trim HIRC to 11.0592 MHz */
N#define GCR_IRCTRIMCTL_TRIM_12M		((uint32_t)0x00000002)			/*!<Trim HIRC to 12 MHz */
N#define GCR_IRCTRIMCTL_TRIM_12288K	((uint32_t)0x00000003)			/*!<Trim HIRC to 12.288 MHz */
N
N#define GCR_IRCTRIMCTL_LOOP_MASK	((uint32_t)0x00000030)			/*!<Trim calculation loop mask */
N#define GCR_IRCTRIMCTL_LOOP_4CLK	((uint32_t)0x00000000)			/*!<Based on average difference in 4 x 32.768 kHz clock */
N#define GCR_IRCTRIMCTL_LOOP_8CLK	((uint32_t)0x00000010)			/*!<Based on average difference in 8 x 32.768 kHz clock */
N#define GCR_IRCTRIMCTL_LOOP_16CLK	((uint32_t)0x00000020)			/*!<Based on average difference in 16 x 32.768 kHz clock */
N#define GCR_IRCTRIMCTL_LOOP_32CLK	((uint32_t)0x00000030)			/*!<Based on average difference in 32 x 32.768 kHz clock */
N
N#define GCR_IRCTRIMCTL_RETRY_COUNT	((uint32_t)0x000000C0)			/*!<Trim value update limitation count mask */
N#define GCR_IRCTRIMCTL_RETRY_64		((uint32_t)0x00000000)			/*!<Trim retry count limitation is 64 */
N#define GCR_IRCTRIMCTL_RETRY_128	((uint32_t)0x00000040)			/*!<Trim retry count limitation is 128 */
N#define GCR_IRCTRIMCTL_RETRY_256	((uint32_t)0x00000080)			/*!<Trim retry count limitation is 256 */
N#define GCR_IRCTRIMCTL_RETRY_512	((uint32_t)0x000000C0)			/*!<Trim retry count limitation is 512 */
N
N#define GCR_IRCTRIMCTL_CLKERR_STOP	((uint32_t)0x00000100)			/*!<Clock error stop enable */
N
N/********************* Bit definition of IRCTRIMIEN register **********************/
N#define GCR_IRCTRIMIEN_FAIL_EN		((uint32_t)0x00000002)			/*!<Trim failure interrupt enable */
N#define GCR_IRCTRIMIEN_32KERR_EN	((uint32_t)0x00000004)			/*!<32.768 kHz Clock Error Interrupt Enable */
N
N/********************* Bit definition of IRCTRIMINT register **********************/
N#define GCR_IRCTRIMINT_FREQLOCK		((uint32_t)0x00000001)			/*!<HIRC frequency lock status */
N#define GCR_IRCTRIMINT_FAIL_INT		((uint32_t)0x00000002)			/*!<Trim failure interrupt status */
N#define GCR_IRCTRIMINT_32KERR_ENNT	((uint32_t)0x00000004)			/*!<32.768 kHz Clock Error Interrupt Status */
N
N/********************* Bit definition of PA_L_MFP register **********************/
N#define PA7_MFP_GPA7				((uint32_t)0x00000000)			/*!<PA7 Pin Function - GPIOA[7] */
N#define PA7_MFP_ADC_CH7				((uint32_t)0x10000000)			/*!<PA7 Pin Function - ADC input channel 7 */
N#define PA7_MFP_EBI_AD6				((uint32_t)0x20000000)			/*!<PA7 Pin Function - EBI AD[6] */
N#define PA7_MFP_TMR2_CAP			((uint32_t)0x30000000)			/*!<PA7 Pin Function - Timer 2 capture event */
N#define PA7_MFP_SC2_DAT				((uint32_t)0x40000000)			/*!<PA7 Pin Function - SmartCard 2 data pin */
N#define PA7_MFP_PWM0_CH2			((uint32_t)0x50000000)			/*!<PA7 Pin Function - PWM0 Channel 2 */
N#define PA7_MFP_LCD_S36				((uint32_t)0x70000000)			/*!<PA7 Pin Function - LCD SEG 36 */
N#define PA7_MFP_LCD_S18				((uint32_t)0x70000000)			/*!<PA7 Pin Function - LCD SEG 18 */
N#define PA7_MFP_MASK				((uint32_t)0x70000000)			/*!<PA7 Pin Function Mask */
N
N#define PA6_MFP_GPA6				((uint32_t)0x00000000)			/*!<PA6 Pin Function - GPIOA[6] */
N#define PA6_MFP_ADC_CH6				((uint32_t)0x01000000)			/*!<PA6 Pin Function - ADC input channel 6 */
N#define PA6_MFP_EBI_AD7				((uint32_t)0x02000000)			/*!<PA6 Pin Function - EBI AD[7] */
N#define PA6_MFP_TMR3_CAP			((uint32_t)0x03000000)			/*!<PA6 Pin Function - Timer 3 Capture event */
N#define PA6_MFP_SC2_CLK				((uint32_t)0x04000000)			/*!<PA6 Pin Function - SmartCard 2 clock */
N#define PA6_MFP_PWM0_CH3			((uint32_t)0x05000000)			/*!<PA6 Pin Function - PWM0 Channel 3 */
N#define PA6_MFP_LCD_S37				((uint32_t)0x07000000)			/*!<PA6 Pin Function - LCD SEG 37 */
N#define PA6_MFP_LCD_S19				((uint32_t)0x07000000)			/*!<PA6 Pin Function - LCD SEG 19 */
N#define PA6_MFP_MASK				((uint32_t)0x07000000)			/*!<PA6 Pin Function Mask */
N
N#define PA5_MFP_GPA5				((uint32_t)0x00000000)			/*!<PA5 Pin Function - GPIOA[5] */
N#define PA5_MFP_ADC_CH5				((uint32_t)0x00100000)			/*!<PA5 Pin Function - ADC input channel 5 */
N#define PA5_MFP_EBI_AD8				((uint32_t)0x00200000)			/*!<PA5 Pin Function - EBI AD[8] */
N#define PA5_MFP_SC2_RST				((uint32_t)0x00400000)			/*!<PA5 Pin Function - SmartCard2 RST */
N#define PA5_MFP_I2C0_SCL			((uint32_t)0x00500000)			/*!<PA5 Pin Function - I2C0 clock */
N#define PA5_MFP_LCD_S38				((uint32_t)0x00700000)			/*!<PA5 Pin Function - LCD SEG 38 */
N#define PA5_MFP_LCD_S20				((uint32_t)0x00700000)			/*!<PA5 Pin Function - LCD SEG 20 */
N#define PA5_MFP_MASK				((uint32_t)0x00700000)			/*!<PA5 Pin Function Mask */
N
N#define PA4_MFP_GPA4				((uint32_t)0x00000000)			/*!<PA4 Pin Function - GPIOA[4] */
N#define PA4_MFP_ADC_CH4				((uint32_t)0x00010000)			/*!<PA4 Pin Function - ADC input channel 4 */
N#define PA4_MFP_EBI_AD9				((uint32_t)0x00020000)			/*!<PA4 Pin Function - EBI AD[9] */
N#define PA4_MFP_SC2_PWR				((uint32_t)0x00040000)			/*!<PA4 Pin Function - SmartCard 2 power */
N#define PA4_MFP_I2C0_SDA			((uint32_t)0x00050000)			/*!<PA4 Pin Function - I2C0 DATA */
N#define PA4_MFP_LCD_S39				((uint32_t)0x00070000)			/*!<PA4 Pin Function - LCD SEG 39 */
N#define PA4_MFP_LCD_S21				((uint32_t)0x00070000)			/*!<PA4 Pin Function - LCD SEG 21 */
N#define PA4_MFP_MASK				((uint32_t)0x00070000)			/*!<PA4 Pin Function Mask */
N
N#define PA3_MFP_GPA3				((uint32_t)0x00000000)			/*!<PA3 Pin Function - GPIOA[3] */
N#define PA3_MFP_ADC_CH3				((uint32_t)0x00001000)			/*!<PA3 Pin Function - ADC input channel 3 */
N#define PA3_MFP_EBI_AD10			((uint32_t)0x00002000)			/*!<PA3 Pin Function - EBI AD[10] */
N#define PA3_MFP_UART1_RX			((uint32_t)0x00005000)			/*!<PA3 Pin Function - UART 1 RX */
N#define PA3_MFP_LCD_S22				((uint32_t)0x00007000)			/*!<PA3 Pin Function - LCD SEG 22 */
N#define PA3_MFP_MASK				((uint32_t)0x00007000)			/*!<PA3 Pin Function Mask */
N
N#define PA2_MFP_GPA2				((uint32_t)0x00000000)			/*!<PA2 Pin Function - GPIOA[2] */
N#define PA2_MFP_ADC_CH2				((uint32_t)0x00000100)			/*!<PA2 Pin Function - ADC input channel 2 */
N#define PA2_MFP_EBI_AD11			((uint32_t)0x00000200)			/*!<PA2 Pin Function - EBI AD[11] */
N#define PA2_MFP_UART1_TX			((uint32_t)0x00000500)			/*!<PA2 Pin Function - UART1 TX */
N#define PA2_MFP_LCD_S23				((uint32_t)0x00000700)			/*!<PA2 Pin Function - LCD SEG 23 */
N#define PA2_MFP_MASK				((uint32_t)0x00000700)			/*!<PA2 Pin Function Mask */
N
N#define PA1_MFP_GPA1				((uint32_t)0x00000000)			/*!<PA1 Pin Function - GPIOA[1] */
N#define PA1_MFP_ADC_CH1				((uint32_t)0x00000010)			/*!<PA1 Pin Function - ADC input channel 1 */
N#define PA1_MFP_EBI_AD12			((uint32_t)0x00000020)			/*!<PA1 Pin Function - EBI AD[12] */
N#define PA1_MFP_TK9					((uint32_t)0x00000060)			/*!<PA1 Pin Function - Touch key 9 */
N#define PA1_MFP_MASK				((uint32_t)0x00000070)			/*!<PA1 Pin Function Mask */
N
N#define PA0_MFP_GPA0				((uint32_t)0x00000000)			/*!<PA0 Pin Function - GPIOA[0] */
N#define PA0_MFP_ADC_CH0				((uint32_t)0x00000001)			/*!<PA0 Pin Function - ADC input channel 0 */
N#define PA0_MFP_SC2_CD				((uint32_t)0x00000004)			/*!<PA0 Pin Function - SmartCard 2 card detect */
N#define PA0_MFP_TK8					((uint32_t)0x00000006)			/*!<PA0 Pin Function - Touch key 8 */
N#define PA0_MFP_MASK				((uint32_t)0x00000007)			/*!<PA0 Pin Function Mask */
N
N/********************* Bit definition of PA_H_MFP register **********************/
N#define PA15_MFP_GPA15				((uint32_t)0x00000000)			/*!<PA15 Pin Function - GPIOA[15] */
N#define PA15_MFP_PWM0_CH3			((uint32_t)0x10000000)			/*!<PA15 Pin Function - PWM0 Channel 3 */
N#define PA15_MFP_I2S_MCLK			((uint32_t)0x20000000)			/*!<PA15 Pin Function - I2S MCLK */
N#define PA15_MFP_TMR3_CAP			((uint32_t)0x30000000)			/*!<PA15 Pin Function - Timer3 capture event */
N#define PA15_MFP_SC0_PWR			((uint32_t)0x40000000)			/*!<PA15 Pin Function - SmartCard 0 power */
N#define PA15_MFP_UART0_TX			((uint32_t)0x60000000)			/*!<PA15 Pin Function - UART0 TX */
N#define PA15_MFP_LCD_S27			((uint32_t)0x70000000)			/*!<PA15 Pin Function - LCD SEG 27 */
N#define PA15_MFP_MASK				((uint32_t)0x70000000)			/*!<PA15 Pin Function Mask */
N
N#define PA14_MFP_GPA14				((uint32_t)0x00000000)			/*!<PA14 Pin Function - GPIOA[14] */
N#define PA14_MFP_PWM0_CH2			((uint32_t)0x01000000)			/*!<PA14 Pin Function - PWM0 Channel 2 */
N#define PA14_MFP_EBI_AD15			((uint32_t)0x02000000)			/*!<PA14 Pin Function - EBI AD[15] */
N#define PA14_MFP_TMR2_CAP			((uint32_t)0x03000000)			/*!<PA14 Pin Function - Timer2 capture event */
N#define PA14_MFP_UART0_RX			((uint32_t)0x06000000)			/*!<PA14 Pin Function - UART0 RX */
N#define PA14_MFP_LCD_S26			((uint32_t)0x07000000)			/*!<PA14 Pin Function - LCD SEG 26 */
N#define PA14_MFP_MASK				((uint32_t)0x07000000)			/*!<PA14 Pin Function Mask */
N
N#define PA13_MFP_GPA13				((uint32_t)0x00000000)			/*!<PA13 Pin Function - GPIOA[13] */
N#define PA13_MFP_PWM0_CH1			((uint32_t)0x00100000)			/*!<PA13 Pin Function - PWM0 Channel 1 */
N#define PA13_MFP_EBI_AD14			((uint32_t)0x00200000)			/*!<PA13 Pin Function - EBI AD[14] */
N#define PA13_MFP_TMR1_CAP			((uint32_t)0x00300000)			/*!<PA13 Pin Function - Timer1 capture event */
N#define PA13_MFP_I2C0_SCL			((uint32_t)0x00500000)			/*!<PA13 Pin Function - I2C0 clock */
N#define PA13_MFP_TK11				((uint32_t)0x00600000)			/*!<PA13 Pin Function - Touch key 11 */
N#define PA13_MFP_TK9				((uint32_t)0x00600000)			/*!<PA13 Pin Function - Touch key 9 */
N#define PA13_MFP_LCD_S25			((uint32_t)0x00700000)			/*!<PA13 Pin Function - LCD SEG 25 */
N#define PA13_MFP_MASK				((uint32_t)0x00700000)			/*!<PA13 Pin Function Mask */
N
N#define PA12_MFP_GPA12				((uint32_t)0x00000000)			/*!<PA12 Pin Function - GPIOA[12] */
N#define PA12_MFP_PWM0_CH0			((uint32_t)0x00010000)			/*!<PA12 Pin Function - PWM0 Channel 0 */
N#define PA12_MFP_EBI_AD13			((uint32_t)0x00020000)			/*!<PA12 Pin Function - EBI AD[13] */
N#define PA12_MFP_TMR0_CAP			((uint32_t)0x00030000)			/*!<PA12 Pin Function - Timer0 capture event */
N#define PA12_MFP_I2C0_SDA			((uint32_t)0x00050000)			/*!<PA12 Pin Function - I2C0 DATA */
N#define PA12_MFP_TK10				((uint32_t)0x00060000)			/*!<PA12 Pin Function - Touch key 10 */
N#define PA12_MFP_LCD_S24			((uint32_t)0x00070000)			/*!<PA12 Pin Function - LCD SEG 24 */
N#define PA12_MFP_MASK				((uint32_t)0x00070000)			/*!<PA12 Pin Function Mask */
N
N#define PA11_MFP_GPA11				((uint32_t)0x00000000)			/*!<PA11 Pin Function - GPIOA[11] */
N#define PA11_MFP_I2C1_SCL			((uint32_t)0x00001000)			/*!<PA11 Pin Function - I2C1 clock */
N#define PA11_MFP_EBI_NRE			((uint32_t)0x00002000)			/*!<PA11 Pin Function - EBI nRE */
N#define PA11_MFP_SC0_RST			((uint32_t)0x00003000)			/*!<PA11 Pin Function - SmartCard0 RST */
N#define PA11_MFP_SPI2_MOSI0			((uint32_t)0x00004000)			/*!<PA11 Pin Function - SPI2 MOSI[0] */
N#define PA11_MFP_LCD_S23			((uint32_t)0x00007000)			/*!<PA11 Pin Function - LCD SEG 23 */
N#define PA11_MFP_LCD_S9				((uint32_t)0x00007000)			/*!<PA11 Pin Function - LCD SEG 9 */
N#define PA11_MFP_MASK				((uint32_t)0x00007000)			/*!<PA11 Pin Function Mask */
N
N#define PA10_MFP_GPA10				((uint32_t)0x00000000)			/*!<PA10 Pin Function - GPIOA[10] */
N#define PA10_MFP_I2C1_SDA			((uint32_t)0x00000100)			/*!<PA10 Pin Function - I2C1 DATA */
N#define PA10_MFP_EBI_NWE			((uint32_t)0x00000200)			/*!<PA10 Pin Function - EBI nWE */
N#define PA10_MFP_SC0_PWR			((uint32_t)0x00000300)			/*!<PA10 Pin Function - SmartCard0 Power */
N#define PA10_MFP_SPI2_MISO0			((uint32_t)0x00000400)			/*!<PA10 Pin Function - SPI2 MISO[0] */
N#define PA10_MFP_LCD_S22			((uint32_t)0x00000700)			/*!<PA10 Pin Function - LCD SEG 22 */
N#define PA10_MFP_LCD_S8				((uint32_t)0x00000700)			/*!<PA10 Pin Function - LCD SEG 8 */
N#define PA10_MFP_MASK				((uint32_t)0x00000700)			/*!<PA10 Pin Function Mask */
N
N#define PA9_MFP_GPA9				((uint32_t)0x00000000)			/*!<PA9 Pin Function - GPIOA[9] */
N#define PA9_MFP_I2C0_SCL			((uint32_t)0x00000010)			/*!<PA9 Pin Function - I2C0 clock */
N#define PA9_MFP_SC0_DAT				((uint32_t)0x00000030)			/*!<PA9 Pin Function - SmartCard0 DATA */
N#define PA9_MFP_SPI2_SCLK			((uint32_t)0x00000040)			/*!<PA9 Pin Function - SPI2 SCLK */
N#define PA9_MFP_LCD_S21				((uint32_t)0x00000070)			/*!<PA9 Pin Function - LCD SEG 21 */
N#define PA9_MFP_LCD_S7				((uint32_t)0x00000070)			/*!<PA9 Pin Function - LCD SEG 7 */
N#define PA9_MFP_MASK				((uint32_t)0x00000070)			/*!<PA9 Pin Function Mask */
N
N#define PA8_MFP_GPA8				((uint32_t)0x00000000)			/*!<PA8 Pin Function - GPIOA[8] */
N#define PA8_MFP_I2C0_SDA			((uint32_t)0x00000001)			/*!<PA8 Pin Function - I2C0 DATA */
N#define PA8_MFP_SC0_CLK				((uint32_t)0x00000003)			/*!<PA8 Pin Function - SmartCard0 clock */
N#define PA8_MFP_SPI2_SS0			((uint32_t)0x00000004)			/*!<PA8 Pin Function - SPI2 1st chip selection */
N#define PA8_MFP_LCD_S20				((uint32_t)0x00000007)			/*!<PA8 Pin Function - LCD SEG 20 */
N#define PA8_MFP_LCD_S6				((uint32_t)0x00000007)			/*!<PA8 Pin Function - LCD SEG 6 */
N#define PA8_MFP_MASK				((uint32_t)0x00000007)			/*!<PA8 Pin Function Mask */
N
N/********************* Bit definition of PB_L_MFP register **********************/
N#define PB7_MFP_GPB7				((uint32_t)0x00000000)			/*!<PB7 Pin Function - GPIOB[7] */
N#define PB7_MFP_UART1_CTS			((uint32_t)0x10000000)			/*!<PB7 Pin Function - UART1 CTSn */
N#define PB7_MFP_EBI_NCS				((uint32_t)0x20000000)			/*!<PB7 Pin Function - EBI nCS */
N#define PB7_MFP_SPI2_MOSI0			((uint32_t)0x40000000)			/*!<PB7 Pin Function - SPI2 MOSI[0] */
N#define PB7_MFP_LCD_S10				((uint32_t)0x70000000)			/*!<PB7 Pin Function - LCD SEG 10 */
N#define PB7_MFP_LCD_S2				((uint32_t)0x70000000)			/*!<PB7 Pin Function - LCD SEG 2 */
N#define PB7_MFP_MASK				((uint32_t)0x70000000)			/*!<PB7 Pin Function Mask */
N
N#define PB6_MFP_GPB6				((uint32_t)0x00000000)			/*!<PB6 Pin Function - GPIOB[6] */
N#define PB6_MFP_UART1_RTS			((uint32_t)0x01000000)			/*!<PB6 Pin Function - UART1 RTSn */
N#define PB6_MFP_EBI_ALE				((uint32_t)0x02000000)			/*!<PB6 Pin Function - EBI ALE */
N#define PB6_MFP_SPI2_MISO0			((uint32_t)0x04000000)			/*!<PB6 Pin Function - SPI2 MISO[0] */
N#define PB6_MFP_LCD_S11				((uint32_t)0x07000000)			/*!<PB6 Pin Function - LCD SEG 11 */
N#define PB6_MFP_LCD_S3				((uint32_t)0x07000000)			/*!<PB6 Pin Function - LCD SEG 3 */
N#define PB6_MFP_MASK				((uint32_t)0x07000000)			/*!<PB6 Pin Function Mask */
N
N#define PB5_MFP_GPB5				((uint32_t)0x00000000)			/*!<PB5 Pin Function - GPIOB[5] */
N#define PB5_MFP_UART1_TX			((uint32_t)0x00100000)			/*!<PB5 Pin Function - UART1 TX */
N#define PB5_MFP_SC0_RST				((uint32_t)0x00300000)			/*!<PB5 Pin Function - SmartCard0 RST */
N#define PB5_MFP_SPI2_SCLK			((uint32_t)0x00400000)			/*!<PB5 Pin Function - SPI2 SCLK */
N#define PB5_MFP_LCD_S12				((uint32_t)0x00700000)			/*!<PB5 Pin Function - LCD SEG 12 */
N#define PB5_MFP_LCD_S4				((uint32_t)0x00700000)			/*!<PB5 Pin Function - LCD SEG 4 */
N#define PB5_MFP_MASK				((uint32_t)0x00700000)			/*!<PB5 Pin Function Mask */
N
N#define PB4_MFP_GPB4				((uint32_t)0x00000000)			/*!<PB4 Pin Function - GPIOB[4] */
N#define PB4_MFP_UART1_RX			((uint32_t)0x00010000)			/*!<PB4 Pin Function - UART1 RX */
N#define PB4_MFP_SC0_CD				((uint32_t)0x00030000)			/*!<PB4 Pin Function - SmartCard0 card detection */
N#define PB4_MFP_SPI2_SS0			((uint32_t)0x00040000)			/*!<PB4 Pin Function - SPI2 chip selection 0 */
N#define PB4_MFP_LCD_S13				((uint32_t)0x00070000)			/*!<PB4 Pin Function - LCD SEG 13 */
N#define PB4_MFP_LCD_S5				((uint32_t)0x00070000)			/*!<PB4 Pin Function - LCD SEG 5 */
N#define PB4_MFP_MASK				((uint32_t)0x00070000)			/*!<PB4 Pin Function Mask */
N
N#define PB3_MFP_GPB3				((uint32_t)0x00000000)			/*!<PB3 Pin Function - GPIOB[3] */
N#define PB3_MFP_UART0_CTS			((uint32_t)0x00001000)			/*!<PB3 Pin Function - UART0 CTSn */
N#define PB3_MFP_EBI_NWRH			((uint32_t)0x00002000)			/*!<PB3 Pin Function - EBI nWRH */
N#define PB3_MFP_SPI1_SS0			((uint32_t)0x00003000)			/*!<PB3 Pin Function - SPI1 chip selection 0 */
N#define PB3_MFP_LCD_S4				((uint32_t)0x00007000)			/*!<PB3 Pin Function - LCD SEG 4 */
N#define PB3_MFP_LCD_COM2			((uint32_t)0x00007000)			/*!<PB3 Pin Function - LCD COM 2 */
N#define PB3_MFP_MASK				((uint32_t)0x00007000)			/*!<PB3 Pin Function Mask */
N
N#define PB2_MFP_GPB2				((uint32_t)0x00000000)			/*!<PB2 Pin Function - GPIOB[2] */
N#define PB2_MFP_UART0_RTS			((uint32_t)0x00000100)			/*!<PB2 Pin Function - UART0 RTSn */
N#define PB2_MFP_EBI_NWRL			((uint32_t)0x00000200)			/*!<PB2 Pin Function - EBI nWRL */
N#define PB2_MFP_SPI1_SCLK			((uint32_t)0x00000300)			/*!<PB2 Pin Function - SPI1 SCLK */
N#define PB2_MFP_LCD_S5				((uint32_t)0x00000700)			/*!<PB2 Pin Function - LCD SEG 5 */
N#define PB2_MFP_LCD_COM3			((uint32_t)0x00000700)			/*!<PB2 Pin Function - LCD COM 3 */
N#define PB2_MFP_MASK				((uint32_t)0x00000700)			/*!<PB2 Pin Function Mask */
N
N#define PB1_MFP_GPB1				((uint32_t)0x00000000)			/*!<PB1 Pin Function - GPIOB[1] */
N#define PB1_MFP_UART0_TX			((uint32_t)0x00000010)			/*!<PB1 Pin Function - UART0 TX */
N#define PB1_MFP_SPI1_MISO0			((uint32_t)0x00000030)			/*!<PB1 Pin Function - SPI1 MISO[0] */
N#define PB1_MFP_LCD_S6				((uint32_t)0x00000070)			/*!<PB1 Pin Function - LCD SEG 6 */
N#define PB1_MFP_LCD_S0				((uint32_t)0x00000070)			/*!<PB1 Pin Function - LCD SEG 0 */
N#define PB1_MFP_MASK				((uint32_t)0x00000070)			/*!<PB1 Pin Function Mask */
N
N#define PB0_MFP_GPB0				((uint32_t)0x00000000)			/*!<PB0 Pin Function - GPIOB[0] */
N#define PB0_MFP_UART0_RX			((uint32_t)0x00000001)			/*!<PB0 Pin Function - UART0 RX */
N#define PB0_MFP_SPI1_MOSI0			((uint32_t)0x00000003)			/*!<PB0 Pin Function - SPI1 MOSI[0] */
N#define PB0_MFP_LCD_S7				((uint32_t)0x00000007)			/*!<PB0 Pin Function - LCD SEG 7 */
N#define PB0_MFP_LCD_S1				((uint32_t)0x00000007)			/*!<PB0 Pin Function - LCD SEG 1 */
N#define PB0_MFP_MASK				((uint32_t)0x00000007)			/*!<PB0 Pin Function Mask */
N
N/********************* Bit definition of PB_H_MFP register **********************/
N#define PB15_MFP_GPB15				((uint32_t)0x00000000)			/*!<PB15 Pin Function - GPIOB[15] */
N#define PB15_MFP_EXT_INT1			((uint32_t)0x10000000)			/*!<PB15 Pin Function - External interrupt 1 */
N#define PB15_MFP_SNOOPER			((uint32_t)0x30000000)			/*!<PB15 Pin Function - Snooper pin */
N#define PB15_MFP_SC1_CD				((uint32_t)0x40000000)			/*!<PB15 Pin Function - SmartCard1 card detect */
N#define PB15_MFP_LCD_S31			((uint32_t)0x70000000)			/*!<PB15 Pin Function - LCD SEG 31 */
N#define PB15_MFP_LCD_S14			((uint32_t)0x70000000)			/*!<PB15 Pin Function - LCD SEG 14 */
N#define PB15_MFP_MASK				((uint32_t)0x70000000)			/*!<PB15 Pin Function Mask */
N
N#define PB14_MFP_GPB14				((uint32_t)0x00000000)			/*!<PB14 Pin Function - GPIOB[14] */
N#define PB14_MFP_EXT_INT0			((uint32_t)0x01000000)			/*!<PB14 Pin Function - External interrupt 0 */
N#define PB14_MFP_SC2_CD				((uint32_t)0x03000000)			/*!<PB14 Pin Function - SmartCard 2 card detect */
N#define PB14_MFP_SPI2_SS1			((uint32_t)0x04000000)			/*!<PB14 Pin Function - SPI2 2nd chip selection */
N#define PB14_MFP_LCD_S26			((uint32_t)0x07000000)			/*!<PB14 Pin Function - LCD SEG 26 */
N#define PB14_MFP_LCD_S12			((uint32_t)0x07000000)			/*!<PB14 Pin Function - LCD SEG 12 */
N#define PB14_MFP_MASK				((uint32_t)0x07000000)			/*!<PB14 Pin Function Mask */
N
N#define PB13_MFP_GPB13				((uint32_t)0x00000000)			/*!<PB13 Pin Function - GPIOB[13] */
N#define PB13_MFP_EBI_AD1			((uint32_t)0x00200000)			/*!<PB13 Pin Function - EBI AD[1] */
N#define PB13_MFP_LCD_S25			((uint32_t)0x00700000)			/*!<PB13 Pin Function - LCD SEG 25 */
N#define PB13_MFP_LCD_S11			((uint32_t)0x00700000)			/*!<PB13 Pin Function - LCD SEG 11 */
N#define PB13_MFP_MASK				((uint32_t)0x00700000)			/*!<PB13 Pin Function Mask */
N
N#define PB12_MFP_GPB12				((uint32_t)0x00000000)			/*!<PB12 Pin Function - GPIOB[12] */
N#define PB12_MFP_EBI_AD0			((uint32_t)0x00020000)			/*!<PB12 Pin Function - EBI AD[0] */
N#define PB12_MFP_FRQDIV_CLK			((uint32_t)0x00040000)			/*!<PB12 Pin Function - FRQDIV_CLK */
N#define PB12_MFP_LCD_S24			((uint32_t)0x00070000)			/*!<PB12 Pin Function - LCD SEG 24 */
N#define PB12_MFP_LCD_S10			((uint32_t)0x00070000)			/*!<PB12 Pin Function - LCD SEG 10 */
N#define PB12_MFP_MASK				((uint32_t)0x00070000)			/*!<PB12 Pin Function Mask */
N
N#define PB11_MFP_GPB11				((uint32_t)0x00000000)			/*!<PB11 Pin Function - GPIOB[11] */
N#define PB11_MFP_PWM1_CH0			((uint32_t)0x00001000)			/*!<PB11 Pin Function - PWM1 Channel 0 */
N#define PB11_MFP_TMR3_EXT			((uint32_t)0x00002000)			/*!<PB11 Pin Function - Timer3 external event input */
N#define PB11_MFP_TMR3_TOGGLE_OUT	((uint32_t)0x00002000)			/*!<PB11 Pin Function - Timer3 toggle output */
N#define PB11_MFP_SC2_DAT			((uint32_t)0x00004000)			/*!<PB11 Pin Function - SmartCard2 DATA */
N#define PB11_MFP_SPI0_MISO0			((uint32_t)0x00005000)			/*!<PB11 Pin Function - SPI 0 MISO[0] */
N#define PB11_MFP_LCD_V3				((uint32_t)0x00007000)			/*!<PB11 Pin Function - LCD V3 */
N#define PB11_MFP_MASK				((uint32_t)0x00007000)			/*!<PB11 Pin Function Mask */
N
N#define PB10_MFP_GPB10				((uint32_t)0x00000000)			/*!<PB10 Pin Function - GPIOB[10] */
N#define PB10_MFP_SPI0_SS1			((uint32_t)0x00000100)			/*!<PB10 Pin Function - SPI0 chip selection 1 */
N#define PB10_MFP_TMR2_EXT			((uint32_t)0x00000200)			/*!<PB10 Pin Function - Timer2 external event input */
N#define PB10_MFP_TMR2_TOGGLE_OUT	((uint32_t)0x00000200)			/*!<PB10 Pin Function - Timer2 toggle output */
N#define PB10_MFP_SC2_CLK			((uint32_t)0x00000400)			/*!<PB10 Pin Function - SmartCard2 clock */
N#define PB10_MFP_SPI0_MOSI0			((uint32_t)0x00000500)			/*!<PB10 Pin Function - SPI0 MOSI[0] */
N#define PB10_MFP_LCD_V2				((uint32_t)0x00000700)			/*!<PB10 Pin Function - LCD V2 */
N#define PB10_MFP_MASK				((uint32_t)0x00000700)			/*!<PB10 Pin Function Mask */
N
N#define PB9_MFP_GPB9				((uint32_t)0x00000000)			/*!<PB9 Pin Function - GPIOB[9] */
N#define PB9_MFP_SPI1_SS1			((uint32_t)0x00000010)			/*!<PB9 Pin Function - SPI1 chip selection 1 */
N#define PB9_MFP_TMR1_EXT			((uint32_t)0x00000020)			/*!<PB9 Pin Function - Timer1 external event input */
N#define PB9_MFP_TMR1_TOGGLE_OUT		((uint32_t)0x00000020)			/*!<PB9 Pin Function - Timer1 toggle output */
N#define PB9_MFP_SC2_RST				((uint32_t)0x00000040)			/*!<PB9 Pin Function - SmartCard2 RST */
N#define PB9_MFP_EXT_INT0			((uint32_t)0x00000050)			/*!<PB9 Pin Function - External interrupt 0 */
N#define PB9_MFP_LCD_V1				((uint32_t)0x00000070)			/*!<PB9 Pin Function - LCD V1 */
N#define PB9_MFP_MASK				((uint32_t)0x00000070)			/*!<PB9 Pin Function Mask */
N
N#define PB8_MFP_GPB8				((uint32_t)0x00000000)			/*!<PB8 Pin Function - GPIOB[8] */
N#define PB8_MFP_ADC_EXT				((uint32_t)0x00000001)			/*!<PB8 Pin Function - ADC external trigger */
N#define PB8_MFP_TMR0_EXT			((uint32_t)0x00000002)			/*!<PB8 Pin Function - Timer0 external event input */
N#define PB8_MFP_TMR0_TOGGLE_OUT		((uint32_t)0x00000002)			/*!<PB8 Pin Function - Timer0 toggle output */
N#define PB8_MFP_EXT_INT0			((uint32_t)0x00000003)			/*!<PB8 Pin Function - External interrupt 0 */
N#define PB8_MFP_SC2_PWR				((uint32_t)0x00000004)			/*!<PB8 Pin Function - SmartCard 2 power */
N#define PB8_MFP_LCD_S30				((uint32_t)0x00000007)			/*!<PB8 Pin Function - LCD SEG 30 */
N#define PB8_MFP_LCD_S13				((uint32_t)0x00000007)			/*!<PB8 Pin Function - LCD SEG 13 */
N#define PB8_MFP_MASK				((uint32_t)0x00000007)			/*!<PB8 Pin Function Mask */
N
N/********************* Bit definition of PC_L_MFP register **********************/
N#define PC7_MFP_GPC7				((uint32_t)0x00000000)			/*!<PC7 Pin Function - GPIOC[7] */
N#define PC7_MFP_DA_OUT1				((uint32_t)0x10000000)			/*!<PC7 Pin Function - DA out1 */
N#define PC7_MFP_EBI_AD5				((uint32_t)0x20000000)			/*!<PC7 Pin Function - EBI AD[5] */
N#define PC7_MFP_TMR1_CAP			((uint32_t)0x30000000)			/*!<PC7 Pin Function - Timer1 capture event */
N#define PC7_MFP_PWM0_CH1			((uint32_t)0x50000000)			/*!<PC7 Pin Function - PWM0 Channel 1 */
N#define PC7_MFP_LCD_S17				((uint32_t)0x70000000)			/*!<PC7 Pin Function - LCD SEG 17 */
N#define PC7_MFP_MASK				((uint32_t)0x70000000)			/*!<PC7 Pin Function Mask */
N
N#define PC6_MFP_GPC6				((uint32_t)0x00000000)			/*!<PC6 Pin Function - GPIOC[6] */
N#define PC6_MFP_DA_OUT0				((uint32_t)0x01000000)			/*!<PC6 Pin Function - DA out0 */
N#define PC6_MFP_EBI_AD4				((uint32_t)0x02000000)			/*!<PC6 Pin Function - EBI AD[4] */
N#define PC6_MFP_TMR0_CAP			((uint32_t)0x03000000)			/*!<PC6 Pin Function - Timer0 Capture event */
N#define PC6_MFP_SC1_CD				((uint32_t)0x04000000)			/*!<PC6 Pin Function - SmartCard1 card detection */
N#define PC6_MFP_PWM0_CH0			((uint32_t)0x05000000)			/*!<PC6 Pin Function - PWM0 Channel 0 */
N#define PC6_MFP_MASK				((uint32_t)0x07000000)			/*!<PC6 Pin Function Mask */
N
N#define PC5_MFP_GPC5				((uint32_t)0x00000000)			/*!<PC5 Pin Function - GPIOC[5] */
N#define PC5_MFP_SPI0_MOSI1			((uint32_t)0x00100000)			/*!<PC5 Pin Function - SPI0 MOSI[1] */
N#define PC5_MFP_LCD_COM3			((uint32_t)0x00700000)			/*!<PC5 Pin Function - LCD COM 3 */
N#define PC5_MFP_MASK				((uint32_t)0x00700000)			/*!<PC5 Pin Function Mask */
N
N#define PC4_MFP_GPC4				((uint32_t)0x00000000)			/*!<PC4 Pin Function - GPIOC[4] */
N#define PC4_MFP_SPI0_MISO1			((uint32_t)0x00010000)			/*!<PC4 Pin Function - SPI0 MISO[1] */
N#define PC4_MFP_LCD_COM2			((uint32_t)0x00070000)			/*!<PC4 Pin Function - LCD COM 2 */
N#define PC4_MFP_MASK				((uint32_t)0x00070000)			/*!<PC4 Pin Function Mask */
N
N#define PC3_MFP_GPC3				((uint32_t)0x00000000)			/*!<PC3 Pin Function - GPIOC[3] */
N#define PC3_MFP_SPI0_MOSI0			((uint32_t)0x00001000)			/*!<PC3 Pin Function - SPI0 MOSI[0] */
N#define PC3_MFP_I2S_DOUT			((uint32_t)0x00002000)			/*!<PC3 Pin Function - I2S Dout */
N#define PC3_MFP_SC1_RST				((uint32_t)0x00004000)			/*!<PC3 Pin Function - SmartCard1 RST */
N#define PC3_MFP_LCD_COM1			((uint32_t)0x00007000)			/*!<PC3 Pin Function - LCD COM 1 */
N#define PC3_MFP_MASK				((uint32_t)0x00007000)			/*!<PC3 Pin Function Mask */
N
N#define PC2_MFP_GPC2				((uint32_t)0x00000000)			/*!<PC2 Pin Function - GPIOC[2] */
N#define PC2_MFP_SPI0_MISO0			((uint32_t)0x00000100)			/*!<PC2 Pin Function - SPI0 MISO[0] */
N#define PC2_MFP_I2S_DIN				((uint32_t)0x00000200)			/*!<PC2 Pin Function - I2S Din */
N#define PC2_MFP_SC1_PWR				((uint32_t)0x00000400)			/*!<PC2 Pin Function - SmartCard1 Power */
N#define PC2_MFP_LCD_COM0			((uint32_t)0x00000700)			/*!<PC2 Pin Function - LCD COM 0 */
N#define PC2_MFP_MASK				((uint32_t)0x00000700)			/*!<PC2 Pin Function Mask */
N
N#define PC1_MFP_GPC1				((uint32_t)0x00000000)			/*!<PC1 Pin Function - GPIOC[1] */
N#define PC1_MFP_SPI0_SCLK			((uint32_t)0x00000010)			/*!<PC1 Pin Function - SPI0 SCLK */
N#define PC1_MFP_I2S_BCLK			((uint32_t)0x00000020)			/*!<PC1 Pin Function - I2S BCLK */
N#define PC1_MFP_SC1_DAT				((uint32_t)0x00000040)			/*!<PC1 Pin Function - SmartCard1 DATA */
N#define PC1_MFP_LCD_DH2				((uint32_t)0x00000070)			/*!<PC1 Pin Function - LCD DH2 */
N#define PC1_MFP_MASK				((uint32_t)0x00000070)			/*!<PC1 Pin Function Mask */
N
N#define PC0_MFP_GPC0				((uint32_t)0x00000000)			/*!<PC0 Pin Function - GPIOC[0] */
N#define PC0_MFP_SPI0_SS0			((uint32_t)0x00000001)			/*!<PC0 Pin Function - SPI0 chip selection 0 */
N#define PC0_MFP_I2S_WS				((uint32_t)0x00000002)			/*!<PC0 Pin Function - I2S WS */
N#define PC0_MFP_SC1_CLK				((uint32_t)0x00000004)			/*!<PC0 Pin Function - SmartCard1 clock */
N#define PC0_MFP_LCD_DH1				((uint32_t)0x00000007)			/*!<PC0 Pin Function - LCD DH1 */
N#define PC0_MFP_MASK				((uint32_t)0x00000007)			/*!<PC0 Pin Function Mask */
N
N/********************* Bit definition of PC_H_MFP register **********************/
N#define PC15_MFP_GPC15				((uint32_t)0x00000000)			/*!<PC15 Pin Function - GPIOC[15] */
N#define PC15_MFP_EBI_AD3			((uint32_t)0x20000000)			/*!<PC15 Pin Function - EBI AD[3] */
N#define PC15_MFP_TMR0_CAP			((uint32_t)0x30000000)			/*!<PC15 Pin Function - Timer0 capture event */
N#define PC15_MFP_PWM1_CH2			((uint32_t)0x40000000)			/*!<PC15 Pin Function - PWM1 Channel 2 */
N#define PC15_MFP_LCD_S33			((uint32_t)0x70000000)			/*!<PC15 Pin Function - LCD SEG 33 */
N#define PC15_MFP_LCD_S16			((uint32_t)0x70000000)			/*!<PC15 Pin Function - LCD SEG 16 */
N#define PC15_MFP_MASK				((uint32_t)0x70000000)			/*!<PC15 Pin Function Mask */
N
N#define PC14_MFP_GPC14				((uint32_t)0x00000000)			/*!<PC14 Pin Function - GPIOC[14] */
N#define PC14_MFP_EBI_AD2			((uint32_t)0x02000000)			/*!<PC14 Pin Function - EBI AD[2] */
N#define PC14_MFP_PWM1_CH3			((uint32_t)0x04000000)			/*!<PC14 Pin Function - PWM1 Channel 3 */
N#define PC14_MFP_LCD_S32			((uint32_t)0x07000000)			/*!<PC14 Pin Function - LCD SEG 32 */
N#define PC14_MFP_LCD_S15			((uint32_t)0x07000000)			/*!<PC14 Pin Function - LCD SEG 15 */
N#define PC14_MFP_MASK				((uint32_t)0x07000000)			/*!<PC14 Pin Function Mask */
N
N#define PC13_MFP_GPC13				((uint32_t)0x00000000)			/*!<PC13 Pin Function - GPIOC[13] */
N#define PC13_MFP_SPI1_MOSI1			((uint32_t)0x00100000)			/*!<PC13 Pin Function - SPI1 MOSI[1] */
N#define PC13_MFP_PWM1_CH1			((uint32_t)0x00200000)			/*!<PC13 Pin Function - PWM1 Channel 1 */
N#define PC13_MFP_SNOOPER			((uint32_t)0x00400000)			/*!<PC13 Pin Function - Snooper pin */
N#define PC13_MFP_EXT_INT1			((uint32_t)0x00500000)			/*!<PC13 Pin Function - External interrupt 1 */
N#define PC13_MFP_I2C0_SCL			((uint32_t)0x00600000)			/*!<PC13 Pin Function - I2C0 clock */
N#define PC13_MFP_MASK				((uint32_t)0x00700000)			/*!<PC13 Pin Function Mask */
N
N#define PC12_MFP_GPC12				((uint32_t)0x00000000)			/*!<PC12 Pin Function - GPIOC[12] */
N#define PC12_MFP_SPI1_MISO1			((uint32_t)0x00010000)			/*!<PC12 Pin Function - SPI1 MISO[1] */
N#define PC12_MFP_PWM1_CH0			((uint32_t)0x00020000)			/*!<PC12 Pin Function - PWM1 Channel 0 */
N#define PC12_MFP_EXT_INT0			((uint32_t)0x00050000)			/*!<PC12 Pin Function - External interrupt 0 */
N#define PC12_MFP_I2C0_SDA			((uint32_t)0x00060000)			/*!<PC12 Pin Function - I2C0 DATA */
N#define PC12_MFP_MASK				((uint32_t)0x00070000)			/*!<PC12 Pin Function Mask */
N
N#define PC11_MFP_GPC11				((uint32_t)0x00000000)			/*!<PC11 Pin Function - GPIOC[11] */
N#define PC11_MFP_SPI1_MOSI0			((uint32_t)0x00001000)			/*!<PC11 Pin Function - SPI1 MOSI[0] */
N#define PC11_MFP_UART1_TX			((uint32_t)0x00005000)			/*!<PC11 Pin Function - UART1 TX */
N#define PC11_MFP_TK15				((uint32_t)0x00006000)			/*!<PC11 Pin Function - Touch key 15 */
N#define PC11_MFP_LCD_S31			((uint32_t)0x00007000)			/*!<PC11 Pin Function - LCD SEG 31 */
N#define PC11_MFP_MASK				((uint32_t)0x00007000)			/*!<PC11 Pin Function Mask */
N
N#define PC10_MFP_GPC10				((uint32_t)0x00000000)			/*!<PC10 Pin Function - GPIOC[10] */
N#define PC10_MFP_SPI1_MISO0			((uint32_t)0x00000100)			/*!<PC10 Pin Function - SPI1 MISO[0] */
N#define PC10_MFP_UART1_RX			((uint32_t)0x00000500)			/*!<PC10 Pin Function - UART1 RX */
N#define PC10_MFP_TK14				((uint32_t)0x00000600)			/*!<PC10 Pin Function - Touch key 14 */
N#define PC10_MFP_LCD_S30			((uint32_t)0x00000700)			/*!<PC10 Pin Function - LCD SEG 30 */
N#define PC10_MFP_MASK				((uint32_t)0x00000700)			/*!<PC10 Pin Function Mask */
N
N#define PC9_MFP_GPC9				((uint32_t)0x00000000)			/*!<PC9 Pin Function - GPIOC[9] */
N#define PC9_MFP_SPI1_SCLK			((uint32_t)0x00000010)			/*!<PC9 Pin Function - SPI1 SCLK */
N#define PC9_MFP_I2C1_SCL			((uint32_t)0x00000050)			/*!<PC9 Pin Function - I2C1 clock */
N#define PC9_MFP_TK13				((uint32_t)0x00000060)			/*!<PC9 Pin Function - Touch key 13 */
N#define PC9_MFP_LCD_S29				((uint32_t)0x00000070)			/*!<PC9 Pin Function - LCD SEG 29 */
N#define PC9_MFP_MASK				((uint32_t)0x00000070)			/*!<PC9 Pin Function Mask */
N
N#define PC8_MFP_GPC8				((uint32_t)0x00000000)			/*!<PC8 Pin Function - GPIOC[8] */
N#define PC8_MFP_SPI1_SS0			((uint32_t)0x00000001)			/*!<PC8 Pin Function - SPI1 SS[0] */
N#define PC8_MFP_EBI_XCLK			((uint32_t)0x00000002)			/*!<PC8 Pin Function - EBI XCLK */
N#define PC8_MFP_I2C1_SDA			((uint32_t)0x00000005)			/*!<PC8 Pin Function - I2C1 DATA */
N#define PC8_MFP_TK12				((uint32_t)0x00000006)			/*!<PC8 Pin Function - Touch key 12 */
N#define PC8_MFP_LCD_S28				((uint32_t)0x00000007)			/*!<PC8 Pin Function - LCD SEG 28 */
N#define PC8_MFP_MASK				((uint32_t)0x00000007)			/*!<PC8 Pin Function Mask */
N
N/********************* Bit definition of PD_L_MFP register **********************/
N#define PD7_MFP_GPD7				((uint32_t)0x00000000)			/*!<PD7 Pin Function - GPIOD[7] */
N#define PD7_MFP_LCD_S2				((uint32_t)0x70000000)			/*!<PD7 Pin Function - LCD SEG 2 */
N#define PD7_MFP_MASK				((uint32_t)0x70000000)			/*!<PD7 Pin Function Mask */
N
N#define PD6_MFP_GPD6				((uint32_t)0x00000000)			/*!<PD6 Pin Function - GPIOD[6] */
N#define PD6_MFP_LCD_S3				((uint32_t)0x07000000)			/*!<PD6 Pin Function - LCD SEG 3 */
N#define PD6_MFP_MASK				((uint32_t)0x07000000)			/*!<PD6 Pin Function Mask */
N
N#define PD5_MFP_GPD5				((uint32_t)0x00000000)			/*!<PD5 Pin Function - GPIOD[5] */
N#define PD5_MFP_I2S_DOUT			((uint32_t)0x00200000)			/*!<PD5 Pin Function - I2S Dout */
N#define PD5_MFP_SPI2_MOSI1			((uint32_t)0x00300000)			/*!<PD5 Pin Function - SPI2 MOSI[1] */
N#define PD5_MFP_TK5					((uint32_t)0x00600000)			/*!<PD5 Pin Function - Touch key 5 */
N#define PD5_MFP_LCD_S34				((uint32_t)0x00700000)			/*!<PD5 Pin Function - LCD SEG 34 */
N#define PD5_MFP_MASK				((uint32_t)0x00700000)			/*!<PD5 Pin Function Mask */
N
N#define PD4_MFP_GPD4				((uint32_t)0x00000000)			/*!<PD4 Pin Function - GPIOD[4] */
N#define PD4_MFP_I2S_DIN				((uint32_t)0x00020000)			/*!<PD4 Pin Function - I2S Din */
N#define PD4_MFP_SPI2_MISO1			((uint32_t)0x00030000)			/*!<PD4 Pin Function - SPI2 MISO[1] */
N#define PD4_MFP_SC1_CD				((uint32_t)0x00040000)			/*!<PD4 Pin Function - SmartCard1 card detection */
N#define PD4_MFP_TK4					((uint32_t)0x00060000)			/*!<PD4 Pin Function - Touch key 4 */
N#define PD4_MFP_LCD_S35				((uint32_t)0x00070000)			/*!<PD4 Pin Function - LCD SEG 35 */
N#define PD4_MFP_MASK				((uint32_t)0x00070000)			/*!<PD4 Pin Function Mask */
N
N#define PD3_MFP_GPD3				((uint32_t)0x00000000)			/*!<PD3 Pin Function - GPIOD[3] */
N#define PD3_MFP_UART1_CTS			((uint32_t)0x00001000)			/*!<PD3 Pin Function - UART1 CTSn */
N#define PD3_MFP_I2S_BCLK			((uint32_t)0x00002000)			/*!<PD3 Pin Function - I2S BCLK */
N#define PD3_MFP_SPI2_MOSI0			((uint32_t)0x00003000)			/*!<PD3 Pin Function - SPI2 MOSI[0] */
N#define PD3_MFP_SC1_RST				((uint32_t)0x00004000)			/*!<PD3 Pin Function - SmartCard1 reset */
N#define PD3_MFP_ADC_CH11			((uint32_t)0x00005000)			/*!<PD3 Pin Function - ADC input channel 11 */
N#define PD3_MFP_TK3					((uint32_t)0x00006000)			/*!<PD3 Pin Function - Touch key 3 */
N#define PD3_MFP_MASK				((uint32_t)0x00007000)			/*!<PD3 Pin Function Mask */
N
N#define PD2_MFP_GPD2				((uint32_t)0x00000000)			/*!<PD2 Pin Function - GPIOD[2] */
N#define PD2_MFP_UART1_RTS			((uint32_t)0x00000100)			/*!<PD2 Pin Function - UART1 RTSn */
N#define PD2_MFP_I2S_WS				((uint32_t)0x00000200)			/*!<PD2 Pin Function - I2S WS */
N#define PD2_MFP_SPI2_MISO0			((uint32_t)0x00000300)			/*!<PD2 Pin Function - SPI2 MISO[0] */
N#define PD2_MFP_SC1_PWR				((uint32_t)0x00000400)			/*!<PD2 Pin Function - SmartCard1 power */
N#define PD2_MFP_ADC_CH10			((uint32_t)0x00000500)			/*!<PD2 Pin Function - ADC input channel 10 */
N#define PD2_MFP_TK2					((uint32_t)0x00000600)			/*!<PD2 Pin Function - Touch key 2 */
N#define PD2_MFP_MASK				((uint32_t)0x00000700)			/*!<PD2 Pin Function Mask */
N
N#define PD1_MFP_GPD1				((uint32_t)0x00000000)			/*!<PD1 Pin Function - GPIOD[1] */
N#define PD1_MFP_UART1_TX			((uint32_t)0x00000010)			/*!<PD1 Pin Function - UART1 TX */
N#define PD1_MFP_SPI2_SCLK			((uint32_t)0x00000030)			/*!<PD1 Pin Function - SPI2 SCLK */
N#define PD1_MFP_SC1_DAT				((uint32_t)0x00000040)			/*!<PD1 Pin Function - SmartCard1 DATA */
N#define PD1_MFP_ADC_CH9				((uint32_t)0x00000050)			/*!<PD1 Pin Function - ADC input channel 9 */
N#define PD1_MFP_TK1					((uint32_t)0x00000060)			/*!<PD1 Pin Function - Touch key 1 */
N#define PD1_MFP_MASK				((uint32_t)0x00000070)			/*!<PD1 Pin Function Mask */
N
N#define PD0_MFP_GPD0				((uint32_t)0x00000000)			/*!<PD0 Pin Function - GPIOD[0] */
N#define PD0_MFP_UART1_RX			((uint32_t)0x00000001)			/*!<PD0 Pin Function - UART1 RX */
N#define PD0_MFP_SPI2_SS0			((uint32_t)0x00000003)			/*!<PD0 Pin Function - SPI2 chip selection 0 */
N#define PD0_MFP_SC1_CLK				((uint32_t)0x00000004)			/*!<PD0 Pin Function - SmartCard1 clock */
N#define PD0_MFP_ADC_CH8				((uint32_t)0x00000005)			/*!<PD0 Pin Function - ADC input channel 8 */
N#define PD0_MFP_TK0					((uint32_t)0x00000006)			/*!<PD0 Pin Function - Touch key 0 */
N#define PD0_MFP_MASK				((uint32_t)0x00000007)			/*!<PD0 Pin Function Mask */
N
N/********************* Bit definition of PD_H_MFP register **********************/
N#define PD15_MFP_GPD15				((uint32_t)0x00000000)			/*!<PD15 Pin Function - GPIOD[15] */
N#define PD15_MFP_LCD_S0				((uint32_t)0x70000000)			/*!<PD15 Pin Function - LCD SEG 0 */
N#define PD15_MFP_MASK				((uint32_t)0x70000000)			/*!<PD15 Pin Function Mask */
N
N#define PD14_MFP_GPD14				((uint32_t)0x00000000)			/*!<PD14 Pin Function - GPIOD[14] */
N#define PD14_MFP_LCD_S1				((uint32_t)0x07000000)			/*!<PD14 Pin Function - LCD SEG 1 */
N#define PD14_MFP_MASK				((uint32_t)0x07000000)			/*!<PD14 Pin Function Mask */
N
N#define PD13_MFP_GPD13				((uint32_t)0x00000000)			/*!<PD13 Pin Function - GPIOD[13] */
N#define PD13_MFP_LCD_S14			((uint32_t)0x00700000)			/*!<PD13 Pin Function - LCD SEG 14 */
N#define PD13_MFP_MASK				((uint32_t)0x00700000)			/*!<PD13 Pin Function Mask */
N
N#define PD12_MFP_GPD12				((uint32_t)0x00000000)			/*!<PD12 Pin Function - GPIOD[12] */
N#define PD12_MFP_LCD_S15			((uint32_t)0x00070000)			/*!<PD12 Pin Function - LCD SEG 15 */
N#define PD12_MFP_MASK				((uint32_t)0x00070000)			/*!<PD12 Pin Function Mask */
N
N#define PD11_MFP_GPD11				((uint32_t)0x00000000)			/*!<PD11 Pin Function - GPIOD[11] */
N#define PD11_MFP_LCD_S16			((uint32_t)0x00007000)			/*!<PD11 Pin Function - LCD SEG 16 */
N#define PD11_MFP_MASK				((uint32_t)0x00007000)			/*!<PD11 Pin Function Mask */
N
N#define PD10_MFP_GPD10				((uint32_t)0x00000000)			/*!<PD10 Pin Function - GPIOD[10] */
N#define PD10_MFP_LCD_S17			((uint32_t)0x00000700)			/*!<PD10 Pin Function - LCD SEG 17 */
N#define PD10_MFP_MASK				((uint32_t)0x00000700)			/*!<PD10 Pin Function Mask */
N
N#define PD9_MFP_GPD9				((uint32_t)0x00000000)			/*!<PD9 Pin Function - GPIOD[9] */
N#define PD9_MFP_LCD_S18				((uint32_t)0x00000070)			/*!<PD9 Pin Function - LCD SEG 18 */
N#define PD9_MFP_MASK				((uint32_t)0x00000070)			/*!<PD9 Pin Function Mask */
N
N#define PD8_MFP_GPD8				((uint32_t)0x00000000)			/*!<PD8 Pin Function - GPIOD[8] */
N#define PD8_MFP_LCD_S19				((uint32_t)0x00000007)			/*!<PD8 Pin Function - LCD SEG 19 */
N#define PD8_MFP_MASK				((uint32_t)0x00000007)			/*!<PD8 Pin Function Mask */
N
N/********************* Bit definition of PE_L_MFP register **********************/
N#define PE7_MFP_GPE7				((uint32_t)0x00000000)			/*!<PE7 Pin Function - GPIOE[7] */
N#define PE7_MFP_LCD_S8				((uint32_t)0x70000000)			/*!<PE7 Pin Function - LCD SEG 8 */
N#define PE7_MFP_MASK				((uint32_t)0x70000000)			/*!<PE7 Pin Function Mask */
N
N#define PE6_MFP_GPE6				((uint32_t)0x00000000)			/*!<PE6 Pin Function - GPIOE[6] */
N#define PE6_MFP_MASK				((uint32_t)0x07000000)			/*!<PE6 Pin Function Mask */
N
N#define PE5_MFP_GPE5				((uint32_t)0x00000000)			/*!<PE5 Pin Function - GPIOE[5] */
N#define PE5_MFP_PWM1_CH1			((uint32_t)0x00100000)			/*!<PE5 Pin Function - PWM1 Channel 1 */
N#define PE5_MFP_MASK				((uint32_t)0x00700000)			/*!<PE5 Pin Function Mask */
N
N#define PE4_MFP_GPE4				((uint32_t)0x00000000)			/*!<PE4 Pin Function - GPIOE[4] */
N#define PE4_MFP_SPI0_MISO0			((uint32_t)0x00060000)			/*!<PE4 Pin Function - SPI0 MISO[0] */
N#define PE4_MFP_MASK				((uint32_t)0x00070000)			/*!<PE4 Pin Function Mask */
N
N#define PE3_MFP_GPE3				((uint32_t)0x00000000)			/*!<PE3 Pin Function - GPIOE[3] */
N#define PE3_MFP_SPI0_MISO0			((uint32_t)0x00006000)			/*!<PE3 Pin Function - SPI0 MISO[0] */
N#define PE3_MFP_MASK				((uint32_t)0x00007000)			/*!<PE3 Pin Function Mask */
N
N#define PE2_MFP_GPE2				((uint32_t)0x00000000)			/*!<PE2 Pin Function - GPIOE[2] */
N#define PE2_MFP_SPI0_SCLK			((uint32_t)0x00000600)			/*!<PE2 Pin Function - SPI0 SCLK */
N#define PE2_MFP_MASK				((uint32_t)0x00000700)			/*!<PE2 Pin Function Mask */
N
N#define PE1_MFP_GPE1				((uint32_t)0x00000000)			/*!<PE1 Pin Function - GPIOE[1] */
N#define PE1_MFP_PWM1_CH3			((uint32_t)0x00000010)			/*!<PE1 Pin Function - PWM1 Channel 3 */
N#define PE1_MFP_SPI0_SS0			((uint32_t)0x00000060)			/*!<PE1 Pin Function - SPI0 chip selection 0 */
N#define PE1_MFP_MASK				((uint32_t)0x00000070)			/*!<PE1 Pin Function Mask */
N
N#define PE0_MFP_GPE0				((uint32_t)0x00000000)			/*!<PE0 Pin Function - GPIOE[0] */
N#define PE0_MFP_PWM1_CH2			((uint32_t)0x00000001)			/*!<PE0 Pin Function - PWM1 Channel 2 */
N#define PE0_MFP_I2S_MCLK			((uint32_t)0x00000002)			/*!<PE0 Pin Function - I2S MCLK */
N#define PE0_MFP_MASK				((uint32_t)0x00000007)			/*!<PE0 Pin Function Mask */
N
N/********************* Bit definition of PE_H_MFP register **********************/
N#define PE15_MFP_GPE15				((uint32_t)0x00000000)			/*!<PE15 Pin Function - GPIOE[15] */
N#define PE15_MFP_LCD_S29			((uint32_t)0x70000000)			/*!<PE15 Pin Function - LCD SEG 29 */
N#define PE15_MFP_MASK				((uint32_t)0x70000000)			/*!<PE15 Pin Function Mask */
N
N#define PE14_MFP_GPA14				((uint32_t)0x00000000)			/*!<PE14 Pin Function - GPIOE[14] */
N#define PE14_MFP_LCD_S28			((uint32_t)0x07000000)			/*!<PE14 Pin Function - LCD SEG 28 */
N#define PE14_MFP_MASK				((uint32_t)0x07000000)			/*!<PE14 Pin Function Mask */
N
N#define PE13_MFP_GPE13				((uint32_t)0x00000000)			/*!<PE13 Pin Function - GPIOE[13] */
N#define PE13_MFP_LCD_S27			((uint32_t)0x00700000)			/*!<PE13 Pin Function - LCD SEG 27 */
N#define PE13_MFP_MASK				((uint32_t)0x00700000)			/*!<PE13 Pin Function Mask */
N
N#define PE12_MFP_GPE12				((uint32_t)0x00000000)			/*!<PE12 Pin Function - GPIOE[12] */
N#define PE12_MFP_UART1_CTS			((uint32_t)0x00070000)			/*!<PE12 Pin Function - UART1 CTSn */
N#define PE12_MFP_MASK				((uint32_t)0x00070000)			/*!<PE12 Pin Function Mask */
N
N#define PE11_MFP_GPE11				((uint32_t)0x00000000)			/*!<PE11 Pin Function - GPIOE[11] */
N#define PE11_MFP_UART1_RTS			((uint32_t)0x00007000)			/*!<PE11 Pin Function - UART1 RTSn */
N#define PE11_MFP_MASK				((uint32_t)0x00007000)			/*!<PE11 Pin Function Mask */
N
N#define PE10_MFP_GPE10				((uint32_t)0x00000000)			/*!<PE10 Pin Function - GPIOE[10] */
N#define PE10_MFP_UART1_TX			((uint32_t)0x00000700)			/*!<PE10 Pin Function - UART1 TX */
N#define PE10_MFP_MASK				((uint32_t)0x00000700)			/*!<PE10 Pin Function Mask */
N
N#define PE9_MFP_GPE9				((uint32_t)0x00000000)			/*!<PE9 Pin Function - GPIOE[9] */
N#define PE9_MFP_UART1_RX			((uint32_t)0x00000070)			/*!<PE9 Pin Function - UART1 RX */
N#define PE9_MFP_MASK				((uint32_t)0x00000070)			/*!<PE9 Pin Function Mask */
N
N#define PE8_MFP_GPE8				((uint32_t)0x00000000)			/*!<PE8 Pin Function - GPIOA[8] */
N#define PE8_MFP_LCD_S9				((uint32_t)0x00000007)			/*!<PE8 Pin Function - LCD SEG 9 */
N#define PE8_MFP_MASK				((uint32_t)0x00000007)			/*!<PE8 Pin Function Mask */
N
N/********************* Bit definition of PF_L_MFP register **********************/
N#define PF5_MFP_GPF5				((uint32_t)0x00000000)			/*!<PF5 Pin Function - GPIOF[5] */
N#define PF5_MFP_I2C0_SCL			((uint32_t)0x00100000)			/*!<PF5 Pin Function - I2C0 clock */
N#define PF5_MFP_TK7					((uint32_t)0x00600000)			/*!<PF5 Pin Function - Touch key 7 */
N#define PF5_MFP_MASK				((uint32_t)0x00700000)			/*!<PF5 Pin Function Mask */
N
N#define PF4_MFP_GPF4				((uint32_t)0x00000000)			/*!<PF4 Pin Function - GPIOF[4] */
N#define PF4_MFP_I2C0_SDA			((uint32_t)0x00010000)			/*!<PF4 Pin Function - I2C0 DATA */
N#define PF4_MFP_TK6					((uint32_t)0x00060000)			/*!<PF4 Pin Function - Touch key 6 */
N#define PF4_MFP_MASK				((uint32_t)0x00070000)			/*!<PF4 Pin Function Mask */
N
N#define PF3_MFP_GPF3				((uint32_t)0x00000000)			/*!<PF3 Pin Function - GPIOF[3] */
N#define PF3_MFP_HXT_IN				((uint32_t)0x00007000)			/*!<PF3 Pin Function - HXT IN */
N#define PF3_MFP_MASK				((uint32_t)0x00007000)			/*!<PF3 Pin Function Mask */
N
N#define PF2_MFP_GPF2				((uint32_t)0x00000000)			/*!<PF2 Pin Function - GPIOF[2] */
N#define PF2_MFP_HXT_OUT				((uint32_t)0x00000700)			/*!<PF2 Pin Function - HXT OUT */
N#define PF2_MFP_MASK				((uint32_t)0x00000700)			/*!<PF2 Pin Function Mask */
N
N#define PF1_MFP_GPF1				((uint32_t)0x00000000)			/*!<PF1 Pin Function - GPIOF[1] */
N#define PF1_MFP_FRQDIV_CLK			((uint32_t)0x00000040)			/*!<PF1 Pin Function - FRQDIV_CLK */
N#define PF1_MFP_EXT_INT1			((uint32_t)0x00000050)			/*!<PF1 Pin Function - External interrupt 1 */
N#define PF1_MFP_ICE_CLK				((uint32_t)0x00000070)			/*!<PF1 Pin Function - ICE CLOCK */
N#define PF1_MFP_MASK				((uint32_t)0x00000070)			/*!<PF1 Pin Function Mask */
N
N#define PF0_MFP_GPF0				((uint32_t)0x00000000)			/*!<PF0 Pin Function - GPIOF[0] */
N#define PF0_MFP_EXT_INT0			((uint32_t)0x00000005)			/*!<PF0 Pin Function - External interrupt 0 */
N#define PF0_MFP_ICE_DAT				((uint32_t)0x00000007)			/*!<PF0 Pin Function - ICE DATA */
N#define PF0_MFP_MASK				((uint32_t)0x00000007)			/*!<PF0 Pin Function Mask */
N
N
N/******************************************************************************/
N/*                CLK                                                         */
N/******************************************************************************/
N/********************* Bit definition of PWRCTL register **********************/
N#define CLK_PWRCTL_HXT_EN			((uint32_t)0x00000001)			/*!<Enable high speed crystal */
N#define CLK_PWRCTL_LXT_EN			((uint32_t)0x00000002)			/*!<Enable low speed crystal */
N#define CLK_PWRCTL_HIRC_EN			((uint32_t)0x00000004)			/*!<Enable internal high speed oscillator */
N#define CLK_PWRCTL_LIRC_EN			((uint32_t)0x00000008)			/*!<Enable internal low speed oscillator */
N#define CLK_PWRCTL_DELY_EN			((uint32_t)0x00000010)			/*!<Enable the wake-up delay counter */
N#define CLK_PWRCTL_WAKEINT_EN		((uint32_t)0x00000020)			/*!<Enable the wake-up interrupt */
N#define CLK_PWRCTL_PWRDOWN_EN		((uint32_t)0x00000040)			/*!<Power down enable bit */
N#define CLK_PWRCTL_HXT_SELXT		((uint32_t)0x00000100)			/*!<High frequency crystal loop back path Enabled */
N#define CLK_PWRCTL_HXT_GAIN			((uint32_t)0x00000200)			/*!<High frequency crystal Gain control Enabled */
N#define CLK_PWRCTL_LXT_SCNT			((uint32_t)0x00000400)			/*!<Delay 8192 LXT before LXT output */
N
N
N/********************* Bit definition of AHBCLK register **********************/
N#define CLK_AHBCLK_GPIO_EN			((uint32_t)0x00000001)			/*!<GPIO clock enable */
N#define CLK_AHBCLK_DMA_EN			((uint32_t)0x00000002)			/*!<DMA clock enable */
N#define CLK_AHBCLK_ISP_EN			((uint32_t)0x00000004)			/*!<Flash ISP controller clock enable */
N#define CLK_AHBCLK_EBI_EN			((uint32_t)0x00000008)			/*!<EBI clock enable */
N#define CLK_AHBCLK_SRAM_EN			((uint32_t)0x00000010)			/*!<SRAM Controller Clock Enable */
N#define CLK_AHBCLK_TICK_EN			((uint32_t)0x00000020)			/*!<System Tick Clock Enable */
N
N/********************* Bit definition of APBCLK register **********************/
N#define CLK_APBCLK_WDT_EN			((uint32_t)0x00000001)			/*!<Watchdog clock enable */
N#define CLK_APBCLK_RTC_EN			((uint32_t)0x00000002)			/*!<RTC clock enable */
N#define CLK_APBCLK_TMR0_EN			((uint32_t)0x00000004)			/*!<Timer 0 clock enable */
N#define CLK_APBCLK_TMR1_EN			((uint32_t)0x00000008)			/*!<Timer 1 clock enable */
N#define CLK_APBCLK_TMR2_EN			((uint32_t)0x00000010)			/*!<Timer 2 clock enable */
N#define CLK_APBCLK_TMR3_EN			((uint32_t)0x00000020)			/*!<Timer 3 clock enable */
N#define CLK_APBCLK_FDIV_EN			((uint32_t)0x00000040)			/*!<Frequency Divider Output clock enable */
N#define CLK_APBCLK_SC2_EN			((uint32_t)0x00000080)			/*!<SmartCard 2 Clock Enable Control */
N#define CLK_APBCLK_I2C0_EN			((uint32_t)0x00000100)			/*!<I2C 0 clock enable */
N#define CLK_APBCLK_I2C1_EN			((uint32_t)0x00000200)			/*!<I2C 1 clock enable */
N#define CLK_APBCLK_SPI0_EN			((uint32_t)0x00001000)			/*!<SPI 0 clock enable */
N#define CLK_APBCLK_SPI1_EN			((uint32_t)0x00002000)			/*!<SPI 1 clock enable */
N#define CLK_APBCLK_SPI2_EN			((uint32_t)0x00004000)			/*!<SPI 2 clock enable */
N#define CLK_APBCLK_UART0_EN			((uint32_t)0x00010000)			/*!<UART 0 clock enable */
N#define CLK_APBCLK_UART1_EN			((uint32_t)0x00020000)			/*!<UART 1 clock enable */
N#define CLK_APBCLK_PWM0_CH01_EN		((uint32_t)0x00100000)			/*!<PWM0 Channel 0 and Channel 1 Clock Enable Control */
N#define CLK_APBCLK_PWM0_CH23_EN		((uint32_t)0x00200000)			/*!<PWM0 Channel 2 and Channel 3 Clock Enable Control */
N#define CLK_APBCLK_PWM1_CH01_EN		((uint32_t)0x00400000)			/*!<PWM1 Channel 0 and Channel 1 Clock Enable Control */
N#define CLK_APBCLK_PWM1_CH23_EN		((uint32_t)0x00800000)			/*!<PWM1 Channel 2 and Channel 3 Clock Enable Control */
N#define CLK_APBCLK_TK_EN			((uint32_t)0x01000000)			/*!<Touch key Clock Enable Control */
N#define CLK_APBCLK_DAC_EN			((uint32_t)0x02000000)			/*!<DAC Clock Enable Control */
N#define CLK_APBCLK_LCD_EN			((uint32_t)0x04000000)			/*!<LCD controller Clock Enable Control */
N#define CLK_APBCLK_USBD_EN			((uint32_t)0x08000000)			/*!<USB device clock enable */
N#define CLK_APBCLK_ADC_EN			((uint32_t)0x10000000)			/*!<ADC clock enable */
N#define CLK_APBCLK_I2S_EN			((uint32_t)0x20000000)			/*!<I2S clock enable */
N#define CLK_APBCLK_SC0_EN			((uint32_t)0x40000000)			/*!<SmartCard 0 Clock Enable Control */
N#define CLK_APBCLK_SC1_EN			((uint32_t)0x80000000)			/*!<SmartCard 1 Clock Enable Control */
N
N/********************* Bit definition of CLKSTATUS register **********************/
N#define CLK_CLKSTATUS_HXT_STB		((uint32_t)0x00000001)			/*!<External high speed crystal clock source stable flag */
N#define CLK_CLKSTATUS_LXT_STB		((uint32_t)0x00000002)			/*!<External low speed crystal clock source stable flag */
N#define CLK_CLKSTATUS_PLL_STB		((uint32_t)0x00000004)			/*!<Internal PLL clock source stable flag */
N#define CLK_CLKSTATUS_LIRC_STB		((uint32_t)0x00000008)			/*!<Internal low speed oscillator clock source stable flag */
N#define CLK_CLKSTATUS_HIRC_STB		((uint32_t)0x00000010)			/*!<Internal high speed oscillator clock source stable flag */
N#define CLK_CLKSTATUS_CLK_SW_FAIL	((uint32_t)0x00000080)			/*!<Clock switch fail flag */
N
N
N/********************* Bit definition of CLKSEL0 register **********************/
N#define CLK_CLKSEL0_HCLK_MASK		((uint32_t)0x00000007)			/*!<HCLK clock source selection bit mask */
N#define CLK_CLKSEL0_HCLK_HXT		((uint32_t)0x00000000)			/*!<Select HCLK clock source from high speed crystal */
N#define CLK_CLKSEL0_HCLK_LXT		((uint32_t)0x00000001)			/*!<Select HCLK clock source from low speed crystal */
N#define CLK_CLKSEL0_HCLK_PLL		((uint32_t)0x00000002)			/*!<Select HCLK clock source from PLL */
N#define CLK_CLKSEL0_HCLK_LIRC		((uint32_t)0x00000003)			/*!<Select HCLK clock source from low speed oscillator */
N#define CLK_CLKSEL0_HCLK_HIRC		((uint32_t)0x00000007)			/*!<Select HCLK clock source from high speed oscillator */
N
N/********************* Bit definition of CLKSEL1 register **********************/
N#define CLK_CLKSEL1_UART_MASK		((uint32_t)0x00000003)			/*!<UART clock source selection bit mask */
N#define CLK_CLKSEL1_UART_HXT		((uint32_t)0x00000000)			/*!<Select UART clock source from high speed crystal */
N#define CLK_CLKSEL1_UART_LXT		((uint32_t)0x00000001)			/*!<Select UART clock source from low speed crystal */
N#define CLK_CLKSEL1_UART_PLL		((uint32_t)0x00000002)			/*!<Select UART clock source from PLL */
N#define CLK_CLKSEL1_UART_HIRC		((uint32_t)0x00000003)			/*!<Select UART clock source from igh speed oscillator */
N
N#define CLK_CLKSEL1_ADC_MASK		((uint32_t)0x0000000C)			/*!<ADC clock source selection bit mask */
N#define CLK_CLKSEL1_ADC_HXT			((uint32_t)0x00000000)			/*!<Select ADC clock source from high speed crystal */
N#define CLK_CLKSEL1_ADC_LXT			((uint32_t)0x00000004)			/*!<Select ADC clock source from low speed crystal */
N#define CLK_CLKSEL1_ADC_PLL			((uint32_t)0x00000008)			/*!<Select ADC clock source from PLL */
N#define CLK_CLKSEL1_ADC_HIRC		((uint32_t)0x0000000C)			/*!<Select ADC clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_PWM0_CH01_MASK	((uint32_t)0x00000030)			/*!<PWM0 channel 0 and channel 1 Clock Source Selection */
N#define CLK_CLKSEL1_PWM0_CH01_HXT	((uint32_t)0x00000000)			/*!<Select PWM0_CH01 clock source from high speed crystal */
N#define CLK_CLKSEL1_PWM0_CH01_LXT	((uint32_t)0x00000010)			/*!<Select PWM0_CH01 clock source from low speed crystal */
N#define CLK_CLKSEL1_PWM0_CH01_HCLK	((uint32_t)0x00000020)			/*!<Select PWM0_CH01 clock source from HCLK */
N#define CLK_CLKSEL1_PWM0_CH01_HIRC	((uint32_t)0x00000030)			/*!<Select PWM0_CH01 clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_PWM0_CH23_MASK	((uint32_t)0x000000C0)			/*!<PWM0 channel 2 and channel 3 Clock Source Selection */
N#define CLK_CLKSEL1_PWM0_CH23_HXT	((uint32_t)0x00000000)			/*!<Select PWM0_CH23 clock source from high speed crystal */
N#define CLK_CLKSEL1_PWM0_CH23_LXT	((uint32_t)0x00000040)			/*!<Select PWM0_CH23 clock source from low speed crystal */
N#define CLK_CLKSEL1_PWM0_CH23_HCLK	((uint32_t)0x00000080)			/*!<Select PWM0_CH23 clock source from HCLK */
N#define CLK_CLKSEL1_PWM0_CH23_HIRC	((uint32_t)0x000000C0)			/*!<Select PWM0_CH23 clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_TMR0_MASK		((uint32_t)0x00000700)			/*!<TMR0 clock source selection bit mask */
N#define CLK_CLKSEL1_TMR0_HXT		((uint32_t)0x00000000)			/*!<Select TMR0 clock source from high speed crystal */
N#define CLK_CLKSEL1_TMR0_LXT		((uint32_t)0x00000100)			/*!<Select TMR0 clock source from low speed crystal */
N#define CLK_CLKSEL1_TMR0_LIRC		((uint32_t)0x00000200)			/*!<Select TMR0 clock source from low speed oscillator */
N#define CLK_CLKSEL1_TMR0_EXT		((uint32_t)0x00000300)			/*!<Select TMR0 clock source from external trigger */
N#define CLK_CLKSEL1_TMR0_HIRC		((uint32_t)0x00000700)			/*!<Select TMR0 clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_TMR1_MASK		((uint32_t)0x00007000)			/*!<TMR1 clock source selection bit mask */
N#define CLK_CLKSEL1_TMR1_HXT		((uint32_t)0x00000000)			/*!<Select TMR1 clock source from high speed crystal */
N#define CLK_CLKSEL1_TMR1_LXT		((uint32_t)0x00001000)			/*!<Select TMR1 clock source from low speed crystal */
N#define CLK_CLKSEL1_TMR1_LIRC		((uint32_t)0x00002000)			/*!<Select TMR1 clock source from low speed oscillator  */
N#define CLK_CLKSEL1_TMR1_EXT		((uint32_t)0x00003000)			/*!<Select TMR1 clock source from external trigger */
N#define CLK_CLKSEL1_TMR1_HIRC		((uint32_t)0x00007000)			/*!<Select TMR1 clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_TK_MASK			((uint32_t)0x00030000)			/*!<TK clock source selection bit mask */
N#define CLK_CLKSEL1_TK_HXT			((uint32_t)0x00000000)			/*!<Select TK clock source from high speed crystal */
N#define CLK_CLKSEL1_TK_PLL			((uint32_t)0x00010000)			/*!<Select TK clock source from PLL */
N#define CLK_CLKSEL1_TK_HIRC			((uint32_t)0x00020000)			/*!<Select TK clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_LCD_MASK        ((uint32_t)0x00040000)			/*!<LCD clock source selection bit mask */
N#define CLK_CLKSEL1_LCD_LXT			((uint32_t)0x00000000)			/*!<Select LCD clock source from low speed crystal */
N#define CLK_CLKSEL1_LCD_LIRC		((uint32_t)0x00040000)			/*!<Select LCD clock source from LIRC */
N
N/********************* Bit definition of CLKSEL2 register **********************/
N#define CLK_CLKSEL2_FRQDIV_MASK		((uint32_t)0x0000000C)			/*!<FRQDIV clock source selection bit mask */
N#define CLK_CLKSEL2_FRQDIV_HXT		((uint32_t)0x00000000)			/*!<Select FRQDIV clock source from high speed crystal */
N#define CLK_CLKSEL2_FRQDIV_LXT		((uint32_t)0x00000004)			/*!<Select FRQDIV clock source from low speed crystal */
N#define CLK_CLKSEL2_FRQDIV_HCLK		((uint32_t)0x00000008)			/*!<Select FRQDIV clock source from HCLK */
N#define CLK_CLKSEL2_FRQDIV_HIRC		((uint32_t)0x0000000C)			/*!<Select FRQDIV clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_PWM1_CH01_MASK	((uint32_t)0x00000030)			/*!<PWM1_CH01 clock source selection bit mask */
N#define CLK_CLKSEL2_PWM1_CH01_HXT	((uint32_t)0x00000000)			/*!<Select PWM1_CH01 clock source from high speed crystal */
N#define CLK_CLKSEL2_PWM1_CH01_LXT	((uint32_t)0x00000010)			/*!<Select PWM1_CH01 clock source from low speed crystal */
N#define CLK_CLKSEL2_PWM1_CH01_HCLK	((uint32_t)0x00000020)			/*!<Select PWM1_CH01 clock source from HCLK */
N#define CLK_CLKSEL2_PWM1_CH01_HIRC	((uint32_t)0x00000030)			/*!<Select PWM1_CH01 clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_PWM1_CH23_MASK	((uint32_t)0x000000C0)			/*!<PWM1_CH23 clock source selection bit mask */
N#define CLK_CLKSEL2_PWM1_CH23_HXT	((uint32_t)0x00000000)			/*!<Select PWM1_CH23 clock source from high speed crystal */
N#define CLK_CLKSEL2_PWM1_CH23_LXT	((uint32_t)0x00000040)			/*!<Select PWM1_CH23 clock source from low speed crystal */
N#define CLK_CLKSEL2_PWM1_CH23_HCLK	((uint32_t)0x00000080)			/*!<Select PWM1_CH23 clock source from HCLK */
N#define CLK_CLKSEL2_PWM1_CH23_HIRC	((uint32_t)0x000000C0)			/*!<Select PWM1_CH23 clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_TMR2_MASK		((uint32_t)0x00000700)			/*!<TMR2 clock source selection bit mask */
N#define CLK_CLKSEL2_TMR2_HXT		((uint32_t)0x00000000)			/*!<Select TMR2 clock source from high speed crystal */
N#define CLK_CLKSEL2_TMR2_LXT		((uint32_t)0x00000100)			/*!<Select TMR2 clock source from low speed crystal */
N#define CLK_CLKSEL2_TMR2_LIRC		((uint32_t)0x00000200)			/*!<Select TMR2 clock source from low speed oscillator */
N#define CLK_CLKSEL2_TMR2_EXT		((uint32_t)0x00000300)			/*!<Select TMR2 clock source from external trigger */
N#define CLK_CLKSEL2_TMR2_HIRC		((uint32_t)0x00000700)			/*!<Select TMR2 clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_TMR3_MASK		((uint32_t)0x00007000)			/*!<TMR3 clock source selection bit mask */
N#define CLK_CLKSEL2_TMR3_HXT		((uint32_t)0x00000000)			/*!<Select TMR3 clock source from high speed crystal */
N#define CLK_CLKSEL2_TMR3_LXT		((uint32_t)0x00001000)			/*!<Select TMR3 clock source from low speed crystal */
N#define CLK_CLKSEL2_TMR3_LIRC		((uint32_t)0x00002000)			/*!<Select TMR3 clock source from low speed oscillator  */
N#define CLK_CLKSEL2_TMR3_EXT		((uint32_t)0x00003000)			/*!<Select TMR3 clock source from external trigger */
N#define CLK_CLKSEL2_TMR3_HIRC		((uint32_t)0x00007000)			/*!<Select TMR3 clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_I2S_MASK		((uint32_t)0x00030000)			/*!<I2S clock source selection bit mask */
N#define CLK_CLKSEL2_I2S_HXT			((uint32_t)0x00000000)			/*!<Select I2S clock source from high speed crystal */
N#define CLK_CLKSEL2_I2S_PLL			((uint32_t)0x00010000)			/*!<Select I2S clock source from PLL */
N#define CLK_CLKSEL2_I2S_HIRC		((uint32_t)0x00020000)			/*!<Select I2S clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_SC_MASK			((uint32_t)0x000C0000)			/*!<SC clock source selection bit mask */
N#define CLK_CLKSEL2_SC_HXT			((uint32_t)0x00000000)			/*!<Select SC clock source from high speed crystal */
N#define CLK_CLKSEL2_SC_PLL			((uint32_t)0x00040000)			/*!<Select SC clock source from PLL */
N#define CLK_CLKSEL2_SC_HIRC			((uint32_t)0x00080000)			/*!<Select SC clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_SPI0_MASK		((uint32_t)0x00100000)			/*!<SPI 0 clock source selection bit mask */
N#define CLK_CLKSEL2_SPI0_PLL		((uint32_t)0x00000000)			/*!<Select SPI 0 clock source from PLL */
N#define CLK_CLKSEL2_SPI0_HCLK		((uint32_t)0x00100000)			/*!<Select SPI 0 clock source from HCLK */
N
N#define CLK_CLKSEL2_SPI1_MASK		((uint32_t)0x00200000)			/*!<SPI 1 clock source selection bit mask */
N#define CLK_CLKSEL2_SPI1_PLL		((uint32_t)0x00000000)			/*!<Select SPI 1 clock source from PLL */
N#define CLK_CLKSEL2_SPI1_HCLK		((uint32_t)0x00200000)			/*!<Select SPI 1 clock source from HCLK */
N
N#define CLK_CLKSEL2_SPI2_MASK		((uint32_t)0x00400000)			/*!<SPI 2 clock source selection bit mask */
N#define CLK_CLKSEL2_SPI2_PLL		((uint32_t)0x00000000)			/*!<Select SPI 2 clock source from PLL */
N#define CLK_CLKSEL2_SPI2_HCLK		((uint32_t)0x00400000)			/*!<Select SPI 2 clock source from HCLK */
N
N/********************* Bit definition of CLKDIV0 register **********************/
N#define CLK_CLKDIV0_HCLK_MASK		((uint32_t)0x0000000F)			/*!<HCLK clock divider bit mask */
N#define HCLK_CLK_DIVIDER(x)			(x & 0x0F)
N
N#define CLK_CLKDIV0_USB_MASK		((uint32_t)0x000000F0)			/*!<USB clock divider bit mask */
N#define USB_CLK_DIVIDER(x)			((x & 0x0F) << 4)
N
N#define CLK_CLKDIV0_UART_MASK		((uint32_t)0x00000F00)			/*!<UART clock divider bit mask */
N#define UART_CLK_DIVIDER(x)			((x & 0x0F) << 8)
N
N#define CLK_CLKDIV0_I2S_MASK		((uint32_t)0x0000F000)			/*!<I2S clock divider bit mask */
N#define I2S_CLK_DIVIDER(x)			((x & 0x0F) << 12)
N
N#define CLK_CLKDIV0_ADC_MASK		((uint32_t)0x00FF0000)			/*!<ADC clock divider bit mask */
N#define ADC_CLK_DIVIDER(x)			((x & 0xFF) << 16)
N
N#define CLK_CLKDIV0_TK_MASK			((uint32_t)0x0F000000)			/*!<TK clock divider bit mask */
N#define TK_CLK_DIVIDER(x)			((x & 0x0F) << 24)
N
N#define CLK_CLKDIV0_SC0_MASK		((uint32_t)0xF0000000)			/*!<SC0 clock divider bit mask */
N#define SC0_CLK_DIVIDER(x)			((x & 0x0F) << 28)
N
N/********************* Bit definition of CLKDIV1 register **********************/
N#define CLK_CLKDIV1_SC1_MASK		((uint32_t)0x0000000F)			/*!<SC1 clock divider bit mask */
N#define SC1_CLK_DIVIDER(x)			(x & 0x0F)
N
N#define CLK_CLKDIV1_SC2_MASK		((uint32_t)0x000000F0)			/*!<SC2 clock divider bit mask */
N#define SC2_CLK_DIVIDER(x)			((x & 0x0F) << 4)
N
N/********************* Bit definition of PLLCTL register **********************/
N#define CLK_PLLCTL_FB_DIVIDER_MASK	((uint32_t)0x0000003F)		/*!<PLL Feedback divider bit mask */
N#define CLK_PLLCTL_IN_DIVIDER_MASK	((uint32_t)0x00000300)		/*!<PLL Input divider bit mask */
N#define CLK_PLLCTL_OUT_DV			((uint32_t)0x00001000)		/*!<PLL Output Divider Control */
N#define CLK_PLLCTL_PD				((uint32_t)0x00010000)		/*!<PLL Power down mode */
N
N#define CLK_PLLCTL_PLLSRC_MASK		((uint32_t)0x00020000)		/*!<PLL clock source bit mask */
N#define CLK_PLLCTL_PLLSRC_HIRC		((uint32_t)0x00020000)		/*!<PLL clock source from high speed oscillator */
N#define CLK_PLLCTL_PLLSRC_HXT		((uint32_t)0x00000000)		/*!<PLL clock source from high speed crystal */
N
N/********************* Bit definition of FRQDIV register **********************/
N#define CLK_FRQDIV_SEL_MASK			((uint32_t)0x0000000F)		/*!<Divider output frequency selection bits mask */
N#define CLK_FRQDIV_EN				((uint32_t)0x00000010)		/*!<Frequency divider enable bit */
N
N/********************* Bit definition of WK_INTSTS register **********************/
N#define CLK_WK_INTSTS_IS			((uint32_t)0x00000001)		/*!<Wake-up Interrupt Sstatus in chip Power-down Mode */
N
N
N/************************** PLL Control Setting ******************************/
N/* PLL Constants */
N#define PLL_NOT_SUPPORTED		0xFFFF
N
N/* PLL seting for 4M input clock */
N#define PLL_IN_4M_OUT_45M		PLL_NOT_SUPPORTED
N#define PLL_IN_4M_OUT_48M		0x0110
N#define PLL_IN_4M_OUT_90M		PLL_NOT_SUPPORTED
N#define PLL_IN_4M_OUT_96M		0x0010
N#define PLL_IN_4M_OUT_120M		0x001c
N#define PLL_IN_4M_OUT_128M		0xFFFF	
N/* PLL seting for 8M input clock */
N#define PLL_IN_8M_OUT_45M		PLL_NOT_SUPPORTED
N#define PLL_IN_8M_OUT_48M		0x0210
N#define PLL_IN_8M_OUT_90M		PLL_NOT_SUPPORTED
N#define PLL_IN_8M_OUT_96M		0x0110
N#define PLL_IN_8M_OUT_120M		PLL_NOT_SUPPORTED
N#define PLL_IN_8M_OUT_128M		0x0120	
N/* PLL seting for 12M input clock */
N#define PLL_IN_12M_OUT_45M		PLL_NOT_SUPPORTED
N#define PLL_IN_12M_OUT_48M		0x0200
N#define PLL_IN_12M_OUT_90M		PLL_NOT_SUPPORTED
N#define PLL_IN_12M_OUT_96M		0x0100
N#define PLL_IN_12M_OUT_120M		0x0230
N#define PLL_IN_12M_OUT_128M		PLL_NOT_SUPPORTED
N/* PLL seting for 15M input clock */
N#define PLL_IN_15M_OUT_45M		0x0310
N#define PLL_IN_15M_OUT_48M		PLL_NOT_SUPPORTED
N#define PLL_IN_15M_OUT_90M		0x0210
N#define PLL_IN_15M_OUT_96M		PLL_NOT_SUPPORTED
N#define PLL_IN_15M_OUT_120M		0x0220
N#define PLL_IN_15M_OUT_128M		PLL_NOT_SUPPORTED
N/* PLL seting for 24M input clock */
N#define PLL_IN_24M_OUT_45M		PLL_NOT_SUPPORTED
N#define PLL_IN_24M_OUT_48M		0x1320
N#define PLL_IN_24M_OUT_90M		PLL_NOT_SUPPORTED
N#define PLL_IN_24M_OUT_96M		0x0320
N#define PLL_IN_24M_OUT_120M		0x0330
N#define PLL_IN_24M_OUT_128M		PLL_NOT_SUPPORTED
N
N
N/******************************************************************************/
N/*                GPIO                                                        */
N/******************************************************************************/
N/********************* Bit definition of PMD register **********************/
N#define GPIO_PMD_PMD0_INPUT			((uint32_t)0x00000000)			/*!<Pin 0 input mode             */
N#define GPIO_PMD_PMD0_OUTPUT		((uint32_t)0x00000001)			/*!<Pin 0 output mode            */
N#define GPIO_PMD_PMD0_OPEN_DRAIN    ((uint32_t)0x00000002)			/*!<Pin 0 open drain mode        */
N#define GPIO_PMD_PMD0_MASK		    ((uint32_t)0x00000003)			/*!<Mask setting of Pin 0 Mode   */
N#define GPIO_PMD_PMD1_INPUT			((uint32_t)0x00000000)			/*!<Pin 1 input mode             */
N#define GPIO_PMD_PMD1_OUTPUT		((uint32_t)0x00000004)			/*!<Pin 1 output mode            */
N#define GPIO_PMD_PMD1_OPEN_DRAIN    ((uint32_t)0x00000008)			/*!<Pin 1 open drain mode        */
N#define GPIO_PMD_PMD1_MASK		    ((uint32_t)0x0000000C)			/*!<Mask setting of Pin 1 Mode   */
N#define GPIO_PMD_PMD2_INPUT			((uint32_t)0x00000000)			/*!<Pin 2 input mode             */
N#define GPIO_PMD_PMD2_OUTPUT		((uint32_t)0x00000010)			/*!<Pin 2 output mode            */
N#define GPIO_PMD_PMD2_OPEN_DRAIN    ((uint32_t)0x00000020)			/*!<Pin 2 open drain mode        */
N#define GPIO_PMD_PMD2_MASK		    ((uint32_t)0x00000030)			/*!<Mask setting of Pin 2 Mode   */
N#define GPIO_PMD_PMD3_INPUT			((uint32_t)0x00000000)			/*!<Pin 3 input mode             */
N#define GPIO_PMD_PMD3_OUTPUT		((uint32_t)0x00000040)			/*!<Pin 3 output mode            */
N#define GPIO_PMD_PMD3_OPEN_DRAIN    ((uint32_t)0x00000080)			/*!<Pin 3 open drain mode        */
N#define GPIO_PMD_PMD3_MASK		    ((uint32_t)0x000000C0)			/*!<Mask setting of Pin 3 Mode   */
N#define GPIO_PMD_PMD4_INPUT			((uint32_t)0x00000000)			/*!<Pin 4 input mode             */
N#define GPIO_PMD_PMD4_OUTPUT		((uint32_t)0x00000100)			/*!<Pin 4 output mode            */
N#define GPIO_PMD_PMD4_OPEN_DRAIN    ((uint32_t)0x00000200)			/*!<Pin 4 open drain mode        */
N#define GPIO_PMD_PMD4_MASK		    ((uint32_t)0x00000300)			/*!<Mask setting of Pin 4 Mode   */
N#define GPIO_PMD_PMD5_INPUT			((uint32_t)0x00000000)			/*!<Pin 5 input mode             */
N#define GPIO_PMD_PMD5_OUTPUT		((uint32_t)0x00000400)			/*!<Pin 5 output mode            */
N#define GPIO_PMD_PMD5_OPEN_DRAIN    ((uint32_t)0x00000800)			/*!<Pin 5 open drain mode        */
N#define GPIO_PMD_PMD5_MASK		    ((uint32_t)0x00000C00)			/*!<Mask setting of Pin 5 Mode   */
N#define GPIO_PMD_PMD6_INPUT			((uint32_t)0x00000000)			/*!<Pin 6 input mode             */
N#define GPIO_PMD_PMD6_OUTPUT		((uint32_t)0x00001000)			/*!<Pin 6 output mode            */
N#define GPIO_PMD_PMD6_OPEN_DRAIN    ((uint32_t)0x00002000)			/*!<Pin 6 open drain mode        */
N#define GPIO_PMD_PMD6_MASK		    ((uint32_t)0x00003000)			/*!<Mask setting of Pin 6 Mode   */
N#define GPIO_PMD_PMD7_INPUT			((uint32_t)0x00000000)			/*!<Pin 7 input mode             */
N#define GPIO_PMD_PMD7_OUTPUT		((uint32_t)0x00004000)			/*!<Pin 7 output mode            */
N#define GPIO_PMD_PMD7_OPEN_DRAIN    ((uint32_t)0x00008000)			/*!<Pin 7 open drain mode        */
N#define GPIO_PMD_PMD7_MASK		    ((uint32_t)0x0000C000)			/*!<Mask setting of Pin 7 Mode   */
N#define GPIO_PMD_PMD8_INPUT			((uint32_t)0x00000000)			/*!<Pin 8 input mode             */
N#define GPIO_PMD_PMD8_OUTPUT		((uint32_t)0x00010000)			/*!<Pin 8 output mode            */
N#define GPIO_PMD_PMD8_OPEN_DRAIN    ((uint32_t)0x00020000)			/*!<Pin 8 open drain mode        */
N#define GPIO_PMD_PMD8_MASK		    ((uint32_t)0x00030000)			/*!<Mask setting of Pin 8 Mode   */
N#define GPIO_PMD_PMD9_INPUT			((uint32_t)0x00000000)			/*!<Pin 9 input mode             */
N#define GPIO_PMD_PMD9_OUTPUT		((uint32_t)0x00040000)			/*!<Pin 9 output mode            */
N#define GPIO_PMD_PMD9_OPEN_DRAIN    ((uint32_t)0x00080000)			/*!<Pin 9 open drain mode        */
N#define GPIO_PMD_PMD9_MASK		    ((uint32_t)0x000C0000)			/*!<Mask setting of Pin 9 Mode   */
N#define GPIO_PMD_PMD10_INPUT	    ((uint32_t)0x00000000)			/*!<Pin 10 input mode             */
N#define GPIO_PMD_PMD10_OUTPUT		((uint32_t)0x00100000)			/*!<Pin 10 output mode            */
N#define GPIO_PMD_PMD10_OPEN_DRAIN   ((uint32_t)0x00200000)			/*!<Pin 10 open drain mode        */
N#define GPIO_PMD_PMD10_MASK		    ((uint32_t)0x00300000)			/*!<Mask setting of Pin 10 Mode   */
N#define GPIO_PMD_PMD11_INPUT	    ((uint32_t)0x00000000)			/*!<Pin 11 input mode             */
N#define GPIO_PMD_PMD11_OUTPUT		((uint32_t)0x00400000)			/*!<Pin 11 output mode            */
N#define GPIO_PMD_PMD11_OPEN_DRAIN   ((uint32_t)0x00800000)			/*!<Pin 11 open drain mode        */
N#define GPIO_PMD_PMD11_MASK		    ((uint32_t)0x00C00000)			/*!<Mask setting of Pin 11 Mode   */
N#define GPIO_PMD_PMD12_INPUT	    ((uint32_t)0x00000000)			/*!<Pin 12 input mode             */
N#define GPIO_PMD_PMD12_OUTPUT		((uint32_t)0x01000000)			/*!<Pin 12 output mode            */
N#define GPIO_PMD_PMD12_OPEN_DRAIN   ((uint32_t)0x02000000)			/*!<Pin 12 open drain mode        */
N#define GPIO_PMD_PMD12_MASK		    ((uint32_t)0x03000000)			/*!<Mask setting of Pin 12 Mode   */
N#define GPIO_PMD_PMD13_INPUT	    ((uint32_t)0x00000000)			/*!<Pin 13 input mode             */
N#define GPIO_PMD_PMD13_OUTPUT		((uint32_t)0x04000000)			/*!<Pin 13 output mode            */
N#define GPIO_PMD_PMD13_OPEN_DRAIN   ((uint32_t)0x08000000)			/*!<Pin 13 open drain mode        */
N#define GPIO_PMD_PMD13_MASK		    ((uint32_t)0x0C000000)			/*!<Mask setting of Pin 13 Mode   */
N#define GPIO_PMD_PMD14_INPUT	    ((uint32_t)0x00000000)			/*!<Pin 14 input mode             */
N#define GPIO_PMD_PMD14_OUTPUT		((uint32_t)0x10000000)			/*!<Pin 14 output mode            */
N#define GPIO_PMD_PMD14_OPEN_DRAIN   ((uint32_t)0x20000000)			/*!<Pin 14 open drain mode        */
N#define GPIO_PMD_PMD14_MASK		    ((uint32_t)0x30000000)			/*!<Mask setting of Pin 14 Mode   */
N#define GPIO_PMD_PMD15_INPUT	    ((uint32_t)0x00000000)			/*!<Pin 15 input mode             */
N#define GPIO_PMD_PMD15_OUTPUT		((uint32_t)0x40000000)			/*!<Pin 15 output mode            */
N#define GPIO_PMD_PMD15_OPEN_DRAIN   ((uint32_t)0x80000000)			/*!<Pin 15 open drain mode        */
N#define GPIO_PMD_PMD15_MASK		    ((uint32_t)0xC0000000)			/*!<Mask setting of Pin 15 Mode   */
N
N/********************* Bit definition of OFFD register **********************/
N#define GPIO_OFFD_OFFD_0		    ((uint32_t)0x00010000)			/*!<Pin 0 digital input path disable */
N#define GPIO_OFFD_OFFD_1		    ((uint32_t)0x00020000)			/*!<Pin 1 digital input path disable */
N#define GPIO_OFFD_OFFD_2		    ((uint32_t)0x00040000)			/*!<Pin 2 digital input path disable */
N#define GPIO_OFFD_OFFD_3		    ((uint32_t)0x00080000)			/*!<Pin 3 digital input path disable */
N#define GPIO_OFFD_OFFD_4		    ((uint32_t)0x00100000)			/*!<Pin 4 digital input path disable */
N#define GPIO_OFFD_OFFD_5		    ((uint32_t)0x00200000)			/*!<Pin 5 digital input path disable */
N#define GPIO_OFFD_OFFD_6		    ((uint32_t)0x00400000)			/*!<Pin 6 digital input path disable */
N#define GPIO_OFFD_OFFD_7		    ((uint32_t)0x00800000)			/*!<Pin 7 digital input path disable */
N#define GPIO_OFFD_OFFD_8		    ((uint32_t)0x01000000)			/*!<Pin 8 digital input path disable */
N#define GPIO_OFFD_OFFD_9		    ((uint32_t)0x02000000)			/*!<Pin 9 digital input path disable */
N#define GPIO_OFFD_OFFD_10		    ((uint32_t)0x04000000)			/*!<Pin 10 digital input path disable */
N#define GPIO_OFFD_OFFD_11		    ((uint32_t)0x08000000)			/*!<Pin 11 digital input path disable */
N#define GPIO_OFFD_OFFD_12		    ((uint32_t)0x10000000)			/*!<Pin 12 digital input path disable */
N#define GPIO_OFFD_OFFD_13		    ((uint32_t)0x20000000)			/*!<Pin 13 digital input path disable */
N#define GPIO_OFFD_OFFD_14		    ((uint32_t)0x40000000)			/*!<Pin 14 digital input path disable */
N#define GPIO_OFFD_OFFD_15		    ((uint32_t)0x80000000)			/*!<Pin 15 digital input path disable */
N#define GPIO_OFFD_OFFD_MASK		    ((uint32_t)0xFFFF0000)			/*!<Mask settings of Pin Digital Input Path Disable */
N
N/********************* Bit definition of DOUT register ************************/
N#define GPIO_DOUT_DOUT_0		    ((uint32_t)0x00000001)			/*!<Pin 0 drive High */
N#define GPIO_DOUT_DOUT_1		    ((uint32_t)0x00000002)			/*!<Pin 1 drive High */
N#define GPIO_DOUT_DOUT_2		    ((uint32_t)0x00000004)			/*!<Pin 2 drive High */
N#define GPIO_DOUT_DOUT_3		    ((uint32_t)0x00000008)			/*!<Pin 3 drive High */
N#define GPIO_DOUT_DOUT_4		    ((uint32_t)0x00000010)			/*!<Pin 4 drive High */
N#define GPIO_DOUT_DOUT_5		    ((uint32_t)0x00000020)			/*!<Pin 5 drive High */
N#define GPIO_DOUT_DOUT_6		    ((uint32_t)0x00000040)			/*!<Pin 6 drive High */
N#define GPIO_DOUT_DOUT_7		    ((uint32_t)0x00000080)			/*!<Pin 7 drive High */
N#define GPIO_DOUT_DOUT_8		    ((uint32_t)0x00000100)			/*!<Pin 8 drive High */
N#define GPIO_DOUT_DOUT_9		    ((uint32_t)0x00000200)			/*!<Pin 9 drive High */
N#define GPIO_DOUT_DOUT_10		    ((uint32_t)0x00000400)			/*!<Pin 10 drive High */
N#define GPIO_DOUT_DOUT_11		    ((uint32_t)0x00000800)			/*!<Pin 11 drive High */
N#define GPIO_DOUT_DOUT_12		    ((uint32_t)0x00001000)			/*!<Pin 12 drive High */
N#define GPIO_DOUT_DOUT_13		    ((uint32_t)0x00002000)			/*!<Pin 13 drive High */
N#define GPIO_DOUT_DOUT_14		    ((uint32_t)0x00004000)			/*!<Pin 14 drive High */
N#define GPIO_DOUT_DOUT_15		    ((uint32_t)0x00008000)			/*!<Pin 15 drive High */
N#define GPIO_DOUT_DOUT_MASK		    ((uint32_t)0x0000FFFF)			/*!<Mask settings of Port Data Optput Value */
N
N/********************* Bit definition of DMASK register ***********************/
N#define GPIO_DMASK_DMASK_0		    ((uint32_t)0x00000001)			/*!<Pin 0 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_1		    ((uint32_t)0x00000002)			/*!<Pin 1 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_2		    ((uint32_t)0x00000004)			/*!<Pin 2 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_3		    ((uint32_t)0x00000008)			/*!<Pin 3 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_4		    ((uint32_t)0x00000010)			/*!<Pin 4 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_5		    ((uint32_t)0x00000020)			/*!<Pin 5 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_6		    ((uint32_t)0x00000040)			/*!<Pin 6 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_7		    ((uint32_t)0x00000080)			/*!<Pin 7 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_8		    ((uint32_t)0x00000100)			/*!<Pin 8 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_9		    ((uint32_t)0x00000200)			/*!<Pin 9 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_10		    ((uint32_t)0x00000400)			/*!<Pin 10 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_11		    ((uint32_t)0x00000800)			/*!<Pin 11 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_12		    ((uint32_t)0x00001000)			/*!<Pin 12 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_13		    ((uint32_t)0x00002000)			/*!<Pin 13 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_14		    ((uint32_t)0x00004000)			/*!<Pin 14 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_15		    ((uint32_t)0x00008000)			/*!<Pin 15 DOUT Mask enable */
N#define GPIO_DMASK_DMASK_MASK	    ((uint32_t)0x0000FFFF)			/*!<Mask settings of Port Data Output Write Mask */
N
N/********************* Bit definition of PIN register *************************/
N#define GPIO_PIN_PIN_0		        ((uint32_t)0x00000001)			/*!<Indicates Pin 0 PIN value is High */
N#define GPIO_PIN_PIN_1		        ((uint32_t)0x00000002)			/*!<Indicates Pin 1 PIN value is High */
N#define GPIO_PIN_PIN_2		        ((uint32_t)0x00000004)			/*!<Indicates Pin 2 PIN value is High */
N#define GPIO_PIN_PIN_3		        ((uint32_t)0x00000008)			/*!<Indicates Pin 3 PIN value is High */
N#define GPIO_PIN_PIN_4		        ((uint32_t)0x00000010)			/*!<Indicates Pin 4 PIN value is High */
N#define GPIO_PIN_PIN_5		        ((uint32_t)0x00000020)			/*!<Indicates Pin 5 PIN value is High */
N#define GPIO_PIN_PIN_6		        ((uint32_t)0x00000040)			/*!<Indicates Pin 6 PIN value is High */
N#define GPIO_PIN_PIN_7		        ((uint32_t)0x00000080)			/*!<Indicates Pin 7 PIN value is High */
N#define GPIO_PIN_PIN_8		        ((uint32_t)0x00000100)			/*!<Indicates Pin 8 PIN value is High */
N#define GPIO_PIN_PIN_9		        ((uint32_t)0x00000200)			/*!<Indicates Pin 9 PIN value is High */
N#define GPIO_PIN_PIN_10		        ((uint32_t)0x00000400)			/*!<Indicates Pin 10 PIN value is High */
N#define GPIO_PIN_PIN_11		        ((uint32_t)0x00000800)			/*!<Indicates Pin 11 PIN value is High */
N#define GPIO_PIN_PIN_12		        ((uint32_t)0x00001000)			/*!<Indicates Pin 12 PIN value is High */
N#define GPIO_PIN_PIN_13		        ((uint32_t)0x00002000)			/*!<Indicates Pin 13 PIN value is High */
N#define GPIO_PIN_PIN_14		        ((uint32_t)0x00004000)			/*!<Indicates Pin 14 PIN value is High */
N#define GPIO_PIN_PIN_15		        ((uint32_t)0x00008000)			/*!<Indicates Pin 15 PIN value is High */
N
N/********************* Bit definition of DBEN register ************************/
N#define GPIO_DBEN_DBEN_0		    ((uint32_t)0x00000001)			/*!<Pin 0 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_1		    ((uint32_t)0x00000002)			/*!<Pin 1 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_2		    ((uint32_t)0x00000004)			/*!<Pin 2 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_3		    ((uint32_t)0x00000008)			/*!<Pin 3 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_4		    ((uint32_t)0x00000010)			/*!<Pin 4 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_5		    ((uint32_t)0x00000020)			/*!<Pin 5 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_6		    ((uint32_t)0x00000040)			/*!<Pin 6 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_7		    ((uint32_t)0x00000080)			/*!<Pin 7 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_8		    ((uint32_t)0x00000100)			/*!<Pin 8 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_9		    ((uint32_t)0x00000200)			/*!<Pin 9 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_10		    ((uint32_t)0x00000400)			/*!<Pin 10 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_11		    ((uint32_t)0x00000800)			/*!<Pin 11 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_12		    ((uint32_t)0x00001000)			/*!<Pin 12 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_13		    ((uint32_t)0x00002000)			/*!<Pin 13 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_14		    ((uint32_t)0x00004000)			/*!<Pin 14 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_15		    ((uint32_t)0x00008000)			/*!<Pin 15 Input Signal De-bounce Enable */
N#define GPIO_DBEN_DBEN_MASK	        ((uint32_t)0x0000FFFF)			/*!<Mask settings of Port Input Signal De-bounce Enable */
N
N/********************* Bit definition of IMD register *************************/
N#define GPIO_IMD_EDGE_0				((uint32_t)0x00000000)			/*!<Pin 0 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_0			((uint32_t)0x00000001)			/*!<Pin 0 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_1		        ((uint32_t)0x00000000)			/*!<Pin 1 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_1		    ((uint32_t)0x00000002)			/*!<Pin 1 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_2		        ((uint32_t)0x00000000)			/*!<Pin 2 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_2		    ((uint32_t)0x00000004)			/*!<Pin 2 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_3		        ((uint32_t)0x00000000)			/*!<Pin 3 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_3		    ((uint32_t)0x00000008)			/*!<Pin 3 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_4		        ((uint32_t)0x00000000)			/*!<Pin 4 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_4		    ((uint32_t)0x00000010)			/*!<Pin 4 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_5		        ((uint32_t)0x00000000)			/*!<Pin 5 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_5		    ((uint32_t)0x00000020)			/*!<Pin 5 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_6		        ((uint32_t)0x00000000)			/*!<Pin 6 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_6		    ((uint32_t)0x00000040)			/*!<Pin 6 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_7		        ((uint32_t)0x00000000)			/*!<Pin 7 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_7		    ((uint32_t)0x00000080)			/*!<Pin 7 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_8		        ((uint32_t)0x00000000)			/*!<Pin 8 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_8		    ((uint32_t)0x00000100)			/*!<Pin 8 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_9		        ((uint32_t)0x00000000)			/*!<Pin 9 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_9		    ((uint32_t)0x00000200)			/*!<Pin 9 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_10		    ((uint32_t)0x00000000)			/*!<Pin 10 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_10		    ((uint32_t)0x00000400)			/*!<Pin 10 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_11		    ((uint32_t)0x00000000)			/*!<Pin 11 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_11		    ((uint32_t)0x00000800)			/*!<Pin 11 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_12		    ((uint32_t)0x00000000)			/*!<Pin 12 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_12		    ((uint32_t)0x00001000)			/*!<Pin 12 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_13		    ((uint32_t)0x00000000)			/*!<Pin 13 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_13		    ((uint32_t)0x00002000)			/*!<Pin 13 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_14		    ((uint32_t)0x00000000)			/*!<Pin 14 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_14		    ((uint32_t)0x00004000)			/*!<Pin 14 Level Detection Interrupt Enable */
N#define GPIO_IMD_EDGE_15		    ((uint32_t)0x00000000)			/*!<Pin 15 Edge Detection Interrupt Enable */
N#define GPIO_IMD_LEVEL_15		    ((uint32_t)0x00008000)			/*!<Pin 15 Level Detection Interrupt Enable */
N#define GPIO_IMD_IMD_MASK	        ((uint32_t)0x0000FFFF)			/*!<Mask settings of Port Edge or Level Detection Interrupt Control */
N
N/********************* Bit definition of IER register *************************/
N#define GPIO_IER_IF_EN_0		    ((uint32_t)0x00000001)			/*!<Pin 0 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_1		    ((uint32_t)0x00000002)			/*!<Pin 1 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_2		    ((uint32_t)0x00000004)			/*!<Pin 2 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_3		    ((uint32_t)0x00000008)			/*!<Pin 3 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_4		    ((uint32_t)0x00000010)			/*!<Pin 4 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_5		    ((uint32_t)0x00000020)			/*!<Pin 5 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_6		    ((uint32_t)0x00000040)			/*!<Pin 6 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_7		    ((uint32_t)0x00000080)			/*!<Pin 7 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_8		    ((uint32_t)0x00000100)			/*!<Pin 8 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_9		    ((uint32_t)0x00000200)			/*!<Pin 9 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_10		    ((uint32_t)0x00000400)			/*!<Pin 10 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_11		    ((uint32_t)0x00000800)			/*!<Pin 11 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_12		    ((uint32_t)0x00001000)			/*!<Pin 12 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_13		    ((uint32_t)0x00002000)			/*!<Pin 13 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_14		    ((uint32_t)0x00004000)			/*!<Pin 14 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_15		    ((uint32_t)0x00008000)			/*!<Pin 15 Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IF_EN_MASK		    ((uint32_t)0x0000FFFF)			/*!<Mask settings of Port Interrupt Enable by Input Falling Edge or Input Level Low */
N#define GPIO_IER_IR_EN_0		    ((uint32_t)0x00010000)			/*!<Pin 0 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_1		    ((uint32_t)0x00020000)			/*!<Pin 1 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_2		    ((uint32_t)0x00040000)			/*!<Pin 2 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_3		    ((uint32_t)0x00080000)			/*!<Pin 3 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_4		    ((uint32_t)0x00100000)			/*!<Pin 4 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_5		    ((uint32_t)0x00200000)			/*!<Pin 5 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_6		    ((uint32_t)0x00400000)			/*!<Pin 6 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_7		    ((uint32_t)0x00800000)			/*!<Pin 7 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_8		    ((uint32_t)0x01000000)			/*!<Pin 8 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_9		    ((uint32_t)0x02000000)			/*!<Pin 9 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_10		    ((uint32_t)0x04000000)			/*!<Pin 10 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_11		    ((uint32_t)0x08000000)			/*!<Pin 11 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_12		    ((uint32_t)0x10000000)			/*!<Pin 12 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_13		    ((uint32_t)0x20000000)			/*!<Pin 13 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_14		    ((uint32_t)0x40000000)			/*!<Pin 14 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_15		    ((uint32_t)0x80000000)			/*!<Pin 15 Interrupt Enable by Input Rising Edge or Input Level High */
N#define GPIO_IER_IR_EN_MASK		    ((uint32_t)0xFFFF0000)			/*!<Mask settings of Port Interrupt Enable by Input Rising Edge or Input Level High */
N
N/********************* Bit definition of ISR register *************************/
N#define GPIO_ISR_ISR_0		        ((uint32_t)0x00000001)			/*!<Indicates Pin 0 generate an interrupt */
N#define GPIO_ISR_ISR_1		        ((uint32_t)0x00000002)			/*!<Indicates Pin 1 generate an interrupt */
N#define GPIO_ISR_ISR_2		        ((uint32_t)0x00000004)			/*!<Indicates Pin 2 generate an interrupt */
N#define GPIO_ISR_ISR_3		        ((uint32_t)0x00000008)			/*!<Indicates Pin 3 generate an interrupt */
N#define GPIO_ISR_ISR_4		        ((uint32_t)0x00000010)			/*!<Indicates Pin 4 generate an interrupt */
N#define GPIO_ISR_ISR_5		        ((uint32_t)0x00000020)			/*!<Indicates Pin 5 generate an interrupt */
N#define GPIO_ISR_ISR_6		        ((uint32_t)0x00000040)			/*!<Indicates Pin 6 generate an interrupt */
N#define GPIO_ISR_ISR_7		        ((uint32_t)0x00000080)			/*!<Indicates Pin 7 generate an interrupt */
N#define GPIO_ISR_ISR_8		        ((uint32_t)0x00000100)			/*!<Indicates Pin 8 generate an interrupt */
N#define GPIO_ISR_ISR_9		        ((uint32_t)0x00000200)			/*!<Indicates Pin 9 generate an interrupt */
N#define GPIO_ISR_ISR_10		        ((uint32_t)0x00000400)			/*!<Indicates Pin 10 generate an interrupt */
N#define GPIO_ISR_ISR_11		        ((uint32_t)0x00000800)			/*!<Indicates Pin 11 generate an interrupt */
N#define GPIO_ISR_ISR_12		        ((uint32_t)0x00001000)			/*!<Indicates Pin 12 generate an interrupt */
N#define GPIO_ISR_ISR_13		        ((uint32_t)0x00002000)			/*!<Indicates Pin 13 generate an interrupt */
N#define GPIO_ISR_ISR_14		        ((uint32_t)0x00004000)			/*!<Indicates Pin 14 generate an interrupt */
N#define GPIO_ISR_ISR_15		        ((uint32_t)0x00008000)			/*!<Indicates Pin 15 generate an interrupt */
N
N/********************* Bit definition of PUEN register *************************/
N#define GPIO_PUEN_PUEN_0		    ((uint32_t)0x00000001)			/*!<Pin 0 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_1		    ((uint32_t)0x00000002)			/*!<Pin 1 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_2		    ((uint32_t)0x00000004)			/*!<Pin 2 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_3		    ((uint32_t)0x00000008)			/*!<Pin 3 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_4		    ((uint32_t)0x00000010)			/*!<Pin 4 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_5		    ((uint32_t)0x00000020)			/*!<Pin 5 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_6		    ((uint32_t)0x00000040)			/*!<Pin 6 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_7		    ((uint32_t)0x00000080)			/*!<Pin 7 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_8		    ((uint32_t)0x00000100)			/*!<Pin 8 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_9		    ((uint32_t)0x00000200)			/*!<Pin 9 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_10		    ((uint32_t)0x00000400)			/*!<Pin 10 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_11		    ((uint32_t)0x00000800)			/*!<Pin 11 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_12		    ((uint32_t)0x00001000)			/*!<Pin 12 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_13		    ((uint32_t)0x00002000)			/*!<Pin 13 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_14		    ((uint32_t)0x00004000)			/*!<Pin 14 Pull-Up Enable */
N#define GPIO_PUEN_PUEN_15		    ((uint32_t)0x00008000)			/*!<Pin 15 Pull-Up Enable */
N
N/********************* Bit definition of DBNCECON register ********************/
N#define GPIO_DBNCECON_DBCLKSEL_0    ((uint32_t)0x00000000)			/*!<Sample interrupt input once per 1 clocks            */
N#define GPIO_DBNCECON_DBCLKSEL_1    ((uint32_t)0x00000001)			/*!<Sample interrupt input once per 2 clocks            */
N#define GPIO_DBNCECON_DBCLKSEL_2    ((uint32_t)0x00000002)			/*!<Sample interrupt input once per 4 clocks            */
N#define GPIO_DBNCECON_DBCLKSEL_3    ((uint32_t)0x00000003)			/*!<Sample interrupt input once per 8 clocks            */
N#define GPIO_DBNCECON_DBCLKSEL_4    ((uint32_t)0x00000004)			/*!<Sample interrupt input once per 16 clocks           */
N#define GPIO_DBNCECON_DBCLKSEL_5    ((uint32_t)0x00000005)			/*!<Sample interrupt input once per 32 clocks           */
N#define GPIO_DBNCECON_DBCLKSEL_6    ((uint32_t)0x00000006)			/*!<Sample interrupt input once per 64 clocks           */
N#define GPIO_DBNCECON_DBCLKSEL_7    ((uint32_t)0x00000007)			/*!<Sample interrupt input once per 128 clocks          */
N#define GPIO_DBNCECON_DBCLKSEL_8    ((uint32_t)0x00000008)			/*!<Sample interrupt input once per 256 clocks          */
N#define GPIO_DBNCECON_DBCLKSEL_9    ((uint32_t)0x00000009)			/*!<Sample interrupt input once per (2*256) clocks      */
N#define GPIO_DBNCECON_DBCLKSEL_10   ((uint32_t)0x0000000A)			/*!<Sample interrupt input once per (4*256) clocks      */
N#define GPIO_DBNCECON_DBCLKSEL_11   ((uint32_t)0x0000000B)			/*!<Sample interrupt input once per (8*256) clocks      */
N#define GPIO_DBNCECON_DBCLKSEL_12   ((uint32_t)0x0000000C)			/*!<Sample interrupt input once per (16*256) clocks     */
N#define GPIO_DBNCECON_DBCLKSEL_13   ((uint32_t)0x0000000D)			/*!<Sample interrupt input once per (32*256) clocks     */
N#define GPIO_DBNCECON_DBCLKSEL_14   ((uint32_t)0x0000000E)			/*!<Sample interrupt input once per (64*256) clocks     */
N#define GPIO_DBNCECON_DBCLKSEL_15   ((uint32_t)0x0000000F)			/*!<Sample interrupt input once per (128*256) clocks    */
N#define GPIO_DBNCECON_DBCLKSEL_MASK ((uint32_t)0x0000000F)			/*!<Mask settings of De-bounce sampling cycle selection */
N#define GPIO_DBNCECON_DBCLKSRC_HCLK ((uint32_t)0x00000000)			/*!<De-bounce counter clock source is the HCLK            */
N#define GPIO_DBNCECON_DBCLKSRC_10K  ((uint32_t)0x00000010)			/*!<De-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBNCECON_ICLK_ON       ((uint32_t)0x00000020)			/*!<Interrupt clock on */
N
N
N/******************************************************************************/
N/*                SHADOW                                                      */
N/******************************************************************************/
N/********************* Bit definition of GPASHADOW register **********************/
N#define SHADOW_GPA_PIN0 			((uint32_t)0x00000001)			/*!<GPIO Port A Pin 0 */
N#define SHADOW_GPA_PIN1 			((uint32_t)0x00000002)			/*!<GPIO Port A Pin 1 */
N#define SHADOW_GPA_PIN2 			((uint32_t)0x00000004)			/*!<GPIO Port A Pin 2 */
N#define SHADOW_GPA_PIN3 			((uint32_t)0x00000008)			/*!<GPIO Port A Pin 3 */
N#define SHADOW_GPA_PIN4 			((uint32_t)0x00000010)			/*!<GPIO Port A Pin 4 */
N#define SHADOW_GPA_PIN5 			((uint32_t)0x00000020)			/*!<GPIO Port A Pin 5 */
N#define SHADOW_GPA_PIN6 			((uint32_t)0x00000040)			/*!<GPIO Port A Pin 6 */
N#define SHADOW_GPA_PIN7 			((uint32_t)0x00000080)			/*!<GPIO Port A Pin 7 */
N#define SHADOW_GPA_PIN8 			((uint32_t)0x00000100)			/*!<GPIO Port A Pin 8 */
N#define SHADOW_GPA_PIN9 			((uint32_t)0x00000200)			/*!<GPIO Port A Pin 9 */
N#define SHADOW_GPA_PIN10 			((uint32_t)0x00000400)			/*!<GPIO Port A Pin 10 */
N#define SHADOW_GPA_PIN11 			((uint32_t)0x00000800)			/*!<GPIO Port A Pin 11 */
N#define SHADOW_GPA_PIN12 			((uint32_t)0x00001000)			/*!<GPIO Port A Pin 12 */
N#define SHADOW_GPA_PIN13 			((uint32_t)0x00002000)			/*!<GPIO Port Pin 13 */
N#define SHADOW_GPA_PIN14 			((uint32_t)0x00004000)			/*!<GPIO Port Pin 14 */
N#define SHADOW_GPA_PIN15 			((uint32_t)0x00008000)			/*!<GPIO Port Pin 15 */
N
N/********************* Bit definition of GPBSHADOW register **********************/
N#define SHADOW_GPB_PIN0 			((uint32_t)0x00000001)			/*!<GPIO Port Pin 0 */
N#define SHADOW_GPB_PIN1 			((uint32_t)0x00000002)			/*!<GPIO Port Pin 1 */
N#define SHADOW_GPB_PIN2 			((uint32_t)0x00000004)			/*!<GPIO Port Pin 2 */
N#define SHADOW_GPB_PIN3 			((uint32_t)0x00000008)			/*!<GPIO Port Pin 3 */
N#define SHADOW_GPB_PIN4 			((uint32_t)0x00000010)			/*!<GPIO Port Pin 4 */
N#define SHADOW_GPB_PIN5 			((uint32_t)0x00000020)			/*!<GPIO Port Pin 5 */
N#define SHADOW_GPB_PIN6 			((uint32_t)0x00000040)			/*!<GPIO Port Pin 6 */
N#define SHADOW_GPB_PIN7 			((uint32_t)0x00000080)			/*!<GPIO Port Pin 7 */
N#define SHADOW_GPB_PIN8 			((uint32_t)0x00000100)			/*!<GPIO Port Pin 8 */
N#define SHADOW_GPB_PIN9 			((uint32_t)0x00000200)			/*!<GPIO Port Pin 9 */
N#define SHADOW_GPB_PIN10 			((uint32_t)0x00000400)			/*!<GPIO Port Pin 10 */
N#define SHADOW_GPB_PIN11 			((uint32_t)0x00000800)			/*!<GPIO Port Pin 11 */
N#define SHADOW_GPB_PIN12 			((uint32_t)0x00001000)			/*!<GPIO Port Pin 12 */
N#define SHADOW_GPB_PIN13 			((uint32_t)0x00002000)			/*!<GPIO Port Pin 13 */
N#define SHADOW_GPB_PIN14 			((uint32_t)0x00004000)			/*!<GPIO Port Pin 14 */
N#define SHADOW_GPB_PIN15 			((uint32_t)0x00008000)			/*!<GPIO Port Pin 15 */
N
N/********************* Bit definition of GPCSHADOW register **********************/
N#define SHADOW_GPC_PIN0 			((uint32_t)0x00000001)			/*!<GPIO Port Pin 0 */
N#define SHADOW_GPC_PIN1 			((uint32_t)0x00000002)			/*!<GPIO Port Pin 1 */
N#define SHADOW_GPC_PIN2 			((uint32_t)0x00000004)			/*!<GPIO Port Pin 2 */
N#define SHADOW_GPC_PIN3 			((uint32_t)0x00000008)			/*!<GPIO Port Pin 3 */
N#define SHADOW_GPC_PIN4 			((uint32_t)0x00000010)			/*!<GPIO Port Pin 4 */
N#define SHADOW_GPC_PIN5 			((uint32_t)0x00000020)			/*!<GPIO Port Pin 5 */
N#define SHADOW_GPC_PIN6 			((uint32_t)0x00000040)			/*!<GPIO Port Pin 6 */
N#define SHADOW_GPC_PIN7 			((uint32_t)0x00000080)			/*!<GPIO Port Pin 7 */
N#define SHADOW_GPC_PIN8 			((uint32_t)0x00000100)			/*!<GPIO Port Pin 8 */
N#define SHADOW_GPC_PIN9 			((uint32_t)0x00000200)			/*!<GPIO Port Pin 9 */
N#define SHADOW_GPC_PIN10 			((uint32_t)0x00000400)			/*!<GPIO Port Pin 10 */
N#define SHADOW_GPC_PIN11 			((uint32_t)0x00000800)			/*!<GPIO Port Pin 11 */
N#define SHADOW_GPC_PIN12 			((uint32_t)0x00001000)			/*!<GPIO Port Pin 12 */
N#define SHADOW_GPC_PIN13 			((uint32_t)0x00002000)			/*!<GPIO Port Pin 13 */
N#define SHADOW_GPC_PIN14 			((uint32_t)0x00004000)			/*!<GPIO Port Pin 14 */
N#define SHADOW_GPC_PIN15 			((uint32_t)0x00008000)			/*!<GPIO Port Pin 15 */
N
N/********************* Bit definition of GPDSHADOW register **********************/
N#define SHADOW_GPD_PIN0 			((uint32_t)0x00000001)			/*!<GPIO Port Pin 0 */
N#define SHADOW_GPD_PIN1 			((uint32_t)0x00000002)			/*!<GPIO Port Pin 1 */
N#define SHADOW_GPD_PIN2 			((uint32_t)0x00000004)			/*!<GPIO Port Pin 2 */
N#define SHADOW_GPD_PIN3 			((uint32_t)0x00000008)			/*!<GPIO Port Pin 3 */
N#define SHADOW_GPD_PIN4 			((uint32_t)0x00000010)			/*!<GPIO Port Pin 4 */
N#define SHADOW_GPD_PIN5 			((uint32_t)0x00000020)			/*!<GPIO Port Pin 5 */
N#define SHADOW_GPD_PIN6 			((uint32_t)0x00000040)			/*!<GPIO Port Pin 6 */
N#define SHADOW_GPD_PIN7 			((uint32_t)0x00000080)			/*!<GPIO Port Pin 7 */
N#define SHADOW_GPD_PIN8 			((uint32_t)0x00000100)			/*!<GPIO Port Pin 8 */
N#define SHADOW_GPD_PIN9 			((uint32_t)0x00000200)			/*!<GPIO Port Pin 9 */
N#define SHADOW_GPD_PIN10 			((uint32_t)0x00000400)			/*!<GPIO Port Pin 10 */
N#define SHADOW_GPD_PIN11 			((uint32_t)0x00000800)			/*!<GPIO Port Pin 11 */
N#define SHADOW_GPD_PIN12 			((uint32_t)0x00001000)			/*!<GPIO Port Pin 12 */
N#define SHADOW_GPD_PIN13 			((uint32_t)0x00002000)			/*!<GPIO Port Pin 13 */
N#define SHADOW_GPD_PIN14 			((uint32_t)0x00004000)			/*!<GPIO Port Pin 14 */
N#define SHADOW_GPD_PIN15 			((uint32_t)0x00008000)			/*!<GPIO Port Pin 15 */
N
N/********************* Bit definition of GPESHADOW register **********************/
N#define SHADOW_GPE_PIN0 			((uint32_t)0x00000001)			/*!<GPIO Port Pin 0 */
N#define SHADOW_GPE_PIN1 			((uint32_t)0x00000002)			/*!<GPIO Port Pin 1 */
N#define SHADOW_GPE_PIN2 			((uint32_t)0x00000004)			/*!<GPIO Port Pin 2 */
N#define SHADOW_GPE_PIN3 			((uint32_t)0x00000008)			/*!<GPIO Port Pin 3 */
N#define SHADOW_GPE_PIN4 			((uint32_t)0x00000010)			/*!<GPIO Port Pin 4 */
N#define SHADOW_GPE_PIN5 			((uint32_t)0x00000020)			/*!<GPIO Port Pin 5 */
N#define SHADOW_GPE_PIN6 			((uint32_t)0x00000040)			/*!<GPIO Port Pin 6 */
N#define SHADOW_GPE_PIN7 			((uint32_t)0x00000080)			/*!<GPIO Port Pin 7 */
N#define SHADOW_GPE_PIN8 			((uint32_t)0x00000100)			/*!<GPIO Port Pin 8 */
N#define SHADOW_GPE_PIN9 			((uint32_t)0x00000200)			/*!<GPIO Port Pin 9 */
N#define SHADOW_GPE_PIN10 			((uint32_t)0x00000400)			/*!<GPIO Port Pin 10 */
N#define SHADOW_GPE_PIN11 			((uint32_t)0x00000800)			/*!<GPIO Port Pin 11 */
N#define SHADOW_GPE_PIN12 			((uint32_t)0x00001000)			/*!<GPIO Port Pin 12 */
N#define SHADOW_GPE_PIN13 			((uint32_t)0x00002000)			/*!<GPIO Port Pin 13 */
N#define SHADOW_GPE_PIN14 			((uint32_t)0x00004000)			/*!<GPIO Port Pin 14 */
N#define SHADOW_GPE_PIN15 			((uint32_t)0x00008000)			/*!<GPIO Port Pin 15 */
N
N/********************* Bit definition of GPFSHADOW register **********************/
N#define SHADOW_GPF_PIN0 			((uint32_t)0x00000001)			/*!<GPIO Port Pin 0 */
N#define SHADOW_GPF_PIN1 			((uint32_t)0x00000002)			/*!<GPIO Port Pin 1 */
N#define SHADOW_GPF_PIN2 			((uint32_t)0x00000004)			/*!<GPIO Port Pin 2 */
N#define SHADOW_GPF_PIN3 			((uint32_t)0x00000008)			/*!<GPIO Port Pin 3 */
N#define SHADOW_GPF_PIN4 			((uint32_t)0x00000010)			/*!<GPIO Port Pin 4 */
N#define SHADOW_GPF_PIN5 			((uint32_t)0x00000020)			/*!<GPIO Port Pin 5 */
N
N
N/******************************************************************************/
N/*                VDMA                                                        */
N/******************************************************************************/
N/********************* Bit definition of CSR register **********************/
N#define VDMA_CSR_CEN				((uint32_t)0x00000001)			/*!<VDMA Channel Enable */
N#define VDMA_CSR_SWRST				((uint32_t)0x00000002)			/*!<VDMA Software Engine Reset */
N#define VDMA_CSR_STRIDE_EN			((uint32_t)0x00000400)			/*!<VDMA Stride Mode Enable */
N#define VDMA_CSR_DIR_INC			((uint32_t)0x00000000)			/*!<VDMA Transfer Source/Destination Address Direction Select - incremented */
N#define VDMA_CSR_DIR_DEC			((uint32_t)0x00000800)			/*!<VDMA Transfer Source/Destination Address Direction Select - decremented */
N#define VDMA_CSR_TRIG_EN			((uint32_t)0x00800000)			/*!<VDMA Channel Trigger */
N
N/********************* Bit definition of IER register **********************/
N#define VDMA_IER_TABORT				((uint32_t)0x00000001)			/*!<VDMA Read/Write Target Abort Interrupt Enable */
N#define VDMA_IER_TD					((uint32_t)0x00000002)			/*!<VDMA Transfer Done Interrupt Enable */
N
N/********************* Bit definition of ISR register **********************/
N#define VDMA_ISR_TABORT				((uint32_t)0x00000001)			/*!<VDMA Read/Write Target Abort Interrupt Status Flag */
N#define VDMA_ISR_TD					((uint32_t)0x00000002)			/*!<VDMA Transfer Done Interrupt Status Flag */
N
N/********************* Bit definition of SASOCR register **********************/
N#define VDMA_SASOCR_SASTOBL_MASK	((uint32_t)0x0000FFFF)			/*!<VDMA Source Address Stride Offset Byte Length Mask */
N#define VDMA_SASOCR_STBC_MASK		((uint32_t)0xFFFF0000)			/*!<VDMA Stride Transfer Byte Count Mask */
N
N/********************* Bit definition of DASOCR register **********************/
N#define VDMA_DASOCR_DASTOBL_MASK	((uint32_t)0x0000FFFF)			/*!<VDMA Destination Address Stride Offset Byte Length Mask */
N
N
N/******************************************************************************/
N/*                PDMA                                                        */
N/******************************************************************************/
N/********************* Bit definition of CSR register **********************/
N#define PDMA_CSR_CEN				((uint32_t)0x00000001)			/*!<PDMA Channel Enable */
N#define PDMA_CSR_SWRST				((uint32_t)0x00000002)			/*!<PDMA Software Engine Reset */
N#define PDMA_CSR_MEM2MEM			((uint32_t)0x00000000)			/*!<PDMA Memory to Memory mode (Memory-to-Memory) */
N#define PDMA_CSR_IP2MEM				((uint32_t)0x00000004)			/*!<PDMA IP to Memory mode (APB-to-Memory) */
N#define PDMA_CSR_MEM2IP				((uint32_t)0x00000008)			/*!<PDMA Memory to IP mode (Memory-to-APB) */
N#define PDMA_CSR_SAD_INC			((uint32_t)0x00000000)			/*!<PDMA Transfer Source Address Direction Selection - incremented */
N#define PDMA_CSR_SAD_FIX			((uint32_t)0x00000020)			/*!<PDMA Transfer Source Address Direction Selection - fixed */
N#define PDMA_CSR_SAD_WRAP			((uint32_t)0x00000030)			/*!<PDMA Transfer Source Address Direction Selection - wrap around */
N#define PDMA_CSR_DAD_INC			((uint32_t)0x00000000)			/*!<PDMA Transfer Destination Address Direction Selection - incremented */
N#define PDMA_CSR_DAD_FIX			((uint32_t)0x00000080)			/*!<PDMA Transfer Destination Address Direction Selection - fixed */
N#define PDMA_CSR_DAD_WRAP			((uint32_t)0x000000C0)			/*!<PDMA Transfer Destination Address Direction Selection - wrap around */
N#define PDMA_CSR_TOEN				((uint32_t)0x00001000)			/*!<PDMA Time-out Enable */
N#define PDMA_CSR_APB_TWS_8BIT		((uint32_t)0x00080000)			/*!<PDMA Peripheral Transfer Width - 8-bit */
N#define PDMA_CSR_APB_TWS_16BIT		((uint32_t)0x00100000)			/*!<PDMA Peripheral Transfer Width - 16-bit */
N#define PDMA_CSR_APB_TWS_32BIT		((uint32_t)0x00000000)			/*!<PDMA Peripheral Transfer Width - 32-bit */
N#define PDMA_CSR_APB_TWS_MASK		((uint32_t)0x00180000)			/*!<PDMA Peripheral Transfer Width Mask */
N#define PDMA_CSR_TRIG_EN			((uint32_t)0x00800000)			/*!<PDMA Channel Trigger */
N
N/********************* Bit definition of IER register **********************/
N#define PDMA_IER_TABORT				((uint32_t)0x00000001)			/*!<PDMA Read/Write Target Abort Interrupt Enable */
N#define PDMA_IER_TD					((uint32_t)0x00000002)			/*!<PDMA Transfer Done Interrupt Enable */
N#define PDMA_IER_WRA_BCR_DONE		((uint32_t)0x00000004)			/*!<PDMA Wrap Around Byte Count Interrupt Enable - CBCR = 0 */
N#define PDMA_IER_WRA_BCR_HALF		((uint32_t)0x00000010)			/*!<PDMA Wrap Around Byte Count Interrupt Enable - 1/2 CBCR */
N#define PDMA_IER_TO					((uint32_t)0x00000040)			/*!<PDMA Time-Out Interrupt Enable */
N
N/********************* Bit definition of ISR register **********************/
N#define PDMA_ISR_TABORT				((uint32_t)0x00000001)			/*!<PDMA Read/Write Target Abort Interrupt Status Flag */
N#define PDMA_ISR_TD					((uint32_t)0x00000002)			/*!<PDMA Transfer Done Interrupt Status Flag */
N#define PDMA_ISR_WRA_BCR_DONE		((uint32_t)0x00000004)			/*!<PDMA Wrap Around Byte Count Interrupt Status Flag - CBCR = 0 */
N#define PDMA_ISR_WRA_BCR_HALF		((uint32_t)0x00000010)			/*!<PDMA Wrap Around Byte Count Interrupt Status Flag - 1/2 CBCR */
N#define PDMA_ISR_TO					((uint32_t)0x00000040)			/*!<PDMA Time-Out Interrupt Status Flag */
N
N/********************* Bit definition of TCR register **********************/
N#define PDMA_TCR_MASK				((uint32_t)0x0000FFFF)			/*!<PDMA Timer Count Setting Register Mask */
N
N/******************************************************************************/
N/*                CRC                                                         */
N/******************************************************************************/
N/********************* Bit definition of CTL register **********************/
N#define PDMACRC_CTL_CEN					((uint32_t)0x00000001)			/*!<CRC Channel Enable */
N#define PDMACRC_CTL_RST					((uint32_t)0x00000002)			/*!<CRC Engine Reset */
N#define PDMACRC_CTL_WDATA_RVS			((uint32_t)0x01000000)			/*!<Write Data Order Reverse */
N#define PDMACRC_CTL_CHECKSUM_RVS		((uint32_t)0x02000000)			/*!<Checksum Reverse */
N#define PDMACRC_CTL_WDATA_COM			((uint32_t)0x04000000)			/*!<Write Data Complement */
N#define PDMACRC_CTL_CHECKSUM_COM		((uint32_t)0x08000000)			/*!<Checksum Complement */
N#define PDMACRC_CTL_CPU_WDLEN_8BIT		((uint32_t)0x00000000)			/*!<CPU Write Data Length 8-bit */
N#define PDMACRC_CTL_CPU_WDLEN_16BIT		((uint32_t)0x10000000)			/*!<CPU Write Data Length 16-bit */
N#define PDMACRC_CTL_CPU_WDLEN_32BIT		((uint32_t)0x20000000)			/*!<CPU Write Data Length 32-bit */
N#define PDMACRC_CTL_CPU_WDLEN_MASK		((uint32_t)0x30000000)			/*!<CPU Write Data Length Mask */
N#define PDMACRC_CTL_MODE_CCITT			((uint32_t)0x00000000)			/*!<CRC Polynomial Mode CCITT */
N#define PDMACRC_CTL_MODE_CRC8			((uint32_t)0x40000000)			/*!<CRC Polynomial Mode CRC8 */
N#define PDMACRC_CTL_MODE_CRC16			((uint32_t)0x80000000)			/*!<CRC Polynomial Mode CRC16 */
N#define PDMACRC_CTL_MODE_CRC32			((uint32_t)0xC0000000)			/*!<CRC Polynomial Mode CRC32 */
N#define PDMACRC_CTL_MODE_MASK			((uint32_t)0xC0000000)			/*!<CRC Polynomial Mode Mask */
N#define PDMACRC_CTL_TRIG_EN				((uint32_t)0x00800000)			/*!<PDMACRC Trigger */
N
N/********************* Bit definition of DMAIER register **********************/
N#define PDMACRC_DMAIER_TABORT			((uint32_t)0x00000001)			/*!<PDMACRC Read/Write Target Abort Interrupt Enable */
N#define PDMACRC_DMAIER_TD				((uint32_t)0x00000002)			/*!<PDMACRC Transfer Done Interrupt Enable */
N
N/********************* Bit definition of DMAISR register **********************/
N#define PDMACRC_DMAISR_TABORT			((uint32_t)0x00000001)			/*!<PDMACRC Read/Write Target Abort Interrupt Flag */
N#define PDMACRC_DMAISR_TD				((uint32_t)0x00000002)			/*!<PDMACRC Transfer Done Interrupt Flag */
N
N/******************************************************************************/
N/*                PDMAGCR                                                     */
N/******************************************************************************/
N/********************* Bit definition of CSR register **********************/
N#define PDMAGCR_CSR_CLK0				((uint32_t)0x00000100)			/*!<DMA Controller Channel 0 Clock Enable Control */
N#define PDMAGCR_CSR_CLK1				((uint32_t)0x00000200)			/*!<DMA Controller Channel 1 Clock Enable Control */
N#define PDMAGCR_CSR_CLK2				((uint32_t)0x00000400)			/*!<DMA Controller Channel 2 Clock Enable Control */
N#define PDMAGCR_CSR_CLK3				((uint32_t)0x00000800)			/*!<DMA Controller Channel 3 Clock Enable Control */
N#define PDMAGCR_CSR_CLK4				((uint32_t)0x00001000)			/*!<DMA Controller Channel 4 Clock Enable Control */
N#define PDMAGCR_CSR_CLK5				((uint32_t)0x00002000)			/*!<DMA Controller Channel 5 Clock Enable Control */
N#define PDMAGCR_CSR_CLK6				((uint32_t)0x00004000)			/*!<DMA Controller Channel 6 Clock Enable Control */
N#define PDMAGCR_CSR_CRCCLK				((uint32_t)0x01000000)			/*!<DMA Controller CRC Clock Enable Control */
N
N/********************* Bit definition of PDSSR0 register **********************/
N#define PDMA_CH1_SPI0_TX			((uint32_t)0x00000000)			/*!<Channel 1 Connect to SPI0_TX */
N#define PDMA_CH1_SPI1_TX			((uint32_t)0x00000100)			/*!<Channel 1 Connect to SPI1_TX */
N#define PDMA_CH1_UART0_TX			((uint32_t)0x00000200)			/*!<Channel 1 Connect to UART0_TX */
N#define PDMA_CH1_UART1_TX			((uint32_t)0x00000300)			/*!<Channel 1 Connect to UART1_TX */
N#define PDMA_CH1_USB_TX				((uint32_t)0x00000400)			/*!<Channel 1 Connect to USB_TX */
N#define PDMA_CH1_I2S_TX				((uint32_t)0x00000500)			/*!<Channel 1 Connect to I2S_TX */
N#define PDMA_CH1_DAC0_TX			((uint32_t)0x00000600)			/*!<Channel 1 Connect to DAC0_TX */
N#define PDMA_CH1_DAC1_TX			((uint32_t)0x00000700)			/*!<Channel 1 Connect to DAC1_TX */
N#define PDMA_CH1_SPI2_TX			((uint32_t)0x00000800)			/*!<Channel 1 Connect to SPI2_TX */
N#define PDMA_CH1_TMR0_CH0			((uint32_t)0x00000900)			/*!<Channel 1 Connect to TMR0_CH0 */
N#define PDMA_CH1_TMR0_CH1			((uint32_t)0x00000A00)			/*!<Channel 1 Connect to TMR0_CH1 */
N#define PDMA_CH1_TMR1_CH0			((uint32_t)0x00000B00)			/*!<Channel 1 Connect to TMR1_CH0 */
N#define PDMA_CH1_TMR1_CH1			((uint32_t)0x00000C00)			/*!<Channel 1 Connect to TMR1_CH1 */
N
N#define PDMA_CH1_SPI0_RX			((uint32_t)0x00001000)			/*!<Channel 1 Connect to SPI0_RX */
N#define PDMA_CH1_SPI1_RX			((uint32_t)0x00001100)			/*!<Channel 1 Connect to SPI1_RX */
N#define PDMA_CH1_UART0_RX			((uint32_t)0x00001200)			/*!<Channel 1 Connect to UART0_RX */
N#define PDMA_CH1_UART1_RX			((uint32_t)0x00001300)			/*!<Channel 1 Connect to UART1_RX */
N#define PDMA_CH1_USB_RX				((uint32_t)0x00001400)			/*!<Channel 1 Connect to USB_RX */
N#define PDMA_CH1_I2S_RX				((uint32_t)0x00001500)			/*!<Channel 1 Connect to I2S_RX */
N#define PDMA_CH1_ADC				((uint32_t)0x00001600)			/*!<Channel 1 Connect to ADC */
N#define PDMA_CH1_SPI2_RX			((uint32_t)0x00001800)			/*!<Channel 1 Connect to SPI2_RX */
N#define PDMA_CH1_PWM0_CH0			((uint32_t)0x00001900)			/*!<Channel 1 Connect to PWM0_CH0 */
N#define PDMA_CH1_PWM0_CH2			((uint32_t)0x00001A00)			/*!<Channel 1 Connect to PWM0_CH2 */
N#define PDMA_CH1_PWM1_CH0			((uint32_t)0x00001B00)			/*!<Channel 1 Connect to PWM1_CH0 */
N#define PDMA_CH1_PWM1_CH2			((uint32_t)0x00001C00)			/*!<Channel 1 Connect to PWM1_CH2 */
N#define PDMA_CH1_DISABLE			((uint32_t)0x00001F00)			/*!<Disable Channel 1 */
N#define PDMA_CH1_MASK				((uint32_t)0x00001F00)			/*!<Channel 1 Service Selection Mask */
N
N#define PDMA_CH2_SPI0_TX			((uint32_t)0x00000000)			/*!<Channel 2 Connect to SPI0_TX */
N#define PDMA_CH2_SPI1_TX			((uint32_t)0x00010000)			/*!<Channel 2 Connect to SPI1_TX */
N#define PDMA_CH2_UART0_TX			((uint32_t)0x00020000)			/*!<Channel 2 Connect to UART0_TX */
N#define PDMA_CH2_UART1_TX			((uint32_t)0x00030000)			/*!<Channel 2 Connect to UART1_TX */
N#define PDMA_CH2_USB_TX				((uint32_t)0x00040000)			/*!<Channel 2 Connect to USB_TX */
N#define PDMA_CH2_I2S_TX				((uint32_t)0x00050000)			/*!<Channel 2 Connect to I2S_TX */
N#define PDMA_CH2_DAC0_TX			((uint32_t)0x00060000)			/*!<Channel 2 Connect to DAC0_TX */
N#define PDMA_CH2_DAC1_TX			((uint32_t)0x00070000)			/*!<Channel 2 Connect to DAC1_TX */
N#define PDMA_CH2_SPI2_TX			((uint32_t)0x00080000)			/*!<Channel 2 Connect to SPI2_TX */
N#define PDMA_CH2_TMR0_CH0			((uint32_t)0x00090000)			/*!<Channel 2 Connect to TMR0_CH0 */
N#define PDMA_CH2_TMR0_CH1			((uint32_t)0x000A0000)			/*!<Channel 2 Connect to TMR0_CH1 */
N#define PDMA_CH2_TMR1_CH0			((uint32_t)0x000B0000)			/*!<Channel 2 Connect to TMR1_CH0 */
N#define PDMA_CH2_TMR1_CH1			((uint32_t)0x000C0000)			/*!<Channel 2 Connect to TMR1_CH1 */
N
N#define PDMA_CH2_SPI0_RX			((uint32_t)0x00100000)			/*!<Channel 2 Connect to SPI0_RX */
N#define PDMA_CH2_SPI1_RX			((uint32_t)0x00110000)			/*!<Channel 2 Connect to SPI1_RX */
N#define PDMA_CH2_UART0_RX			((uint32_t)0x00120000)			/*!<Channel 2 Connect to UART0_RX */
N#define PDMA_CH2_UART1_RX			((uint32_t)0x00130000)			/*!<Channel 2 Connect to UART1_RX */
N#define PDMA_CH2_USB_RX				((uint32_t)0x00140000)			/*!<Channel 2 Connect to USB_RX */
N#define PDMA_CH2_I2S_RX				((uint32_t)0x00150000)			/*!<Channel 2 Connect to I2S_RX */
N#define PDMA_CH2_ADC				((uint32_t)0x00160000)			/*!<Channel 2 Connect to ADC */
N#define PDMA_CH2_SPI2_RX			((uint32_t)0x00180000)			/*!<Channel 2 Connect to SPI2_RX */
N#define PDMA_CH2_PWM0_CH0			((uint32_t)0x00190000)			/*!<Channel 2 Connect to PWM0_CH0 */
N#define PDMA_CH2_PWM0_CH2			((uint32_t)0x001A0000)			/*!<Channel 2 Connect to PWM0_CH2 */
N#define PDMA_CH2_PWM1_CH0			((uint32_t)0x001B0000)			/*!<Channel 2 Connect to PWM1_CH0 */
N#define PDMA_CH2_PWM1_CH2			((uint32_t)0x001C0000)			/*!<Channel 2 Connect to PWM1_CH2 */
N#define PDMA_CH2_DISABLE			((uint32_t)0x001F0000)			/*!<Disable Channel 2 */
N#define PDMA_CH2_MASK				((uint32_t)0x001F0000)			/*!<Channel 2 Service Selection Mask */
N
N#define PDMA_CH3_SPI0_TX			((uint32_t)0x00000000)			/*!<Channel 3 Connect to SPI0_TX */
N#define PDMA_CH3_SPI1_TX			((uint32_t)0x01000000)			/*!<Channel 3 Connect to SPI1_TX */
N#define PDMA_CH3_UART0_TX			((uint32_t)0x02000000)			/*!<Channel 3 Connect to UART0_TX */
N#define PDMA_CH3_UART1_TX			((uint32_t)0x03000000)			/*!<Channel 3 Connect to UART1_TX */
N#define PDMA_CH3_USB_TX				((uint32_t)0x04000000)			/*!<Channel 3 Connect to USB_TX */
N#define PDMA_CH3_I2S_TX				((uint32_t)0x05000000)			/*!<Channel 3 Connect to I2S_TX */
N#define PDMA_CH3_DAC0_TX			((uint32_t)0x06000000)			/*!<Channel 3 Connect to DAC0_TX */
N#define PDMA_CH3_DAC1_TX			((uint32_t)0x07000000)			/*!<Channel 3 Connect to DAC1_TX */
N#define PDMA_CH3_SPI2_TX			((uint32_t)0x08000000)			/*!<Channel 3 Connect to SPI2_TX */
N#define PDMA_CH3_TMR0_CH0			((uint32_t)0x09000000)			/*!<Channel 3 Connect to TMR0_CH0 */
N#define PDMA_CH3_TMR0_CH1			((uint32_t)0x0A000000)			/*!<Channel 3 Connect to TMR0_CH1 */
N#define PDMA_CH3_TMR1_CH0			((uint32_t)0x0B000000)			/*!<Channel 3 Connect to TMR1_CH0 */
N#define PDMA_CH3_TMR1_CH1			((uint32_t)0x0C000000)			/*!<Channel 3 Connect to TMR1_CH1 */
N
N#define PDMA_CH3_SPI0_RX			((uint32_t)0x10000000)			/*!<Channel 3 Connect to SPI0_RX */
N#define PDMA_CH3_SPI1_RX			((uint32_t)0x11000000)			/*!<Channel 3 Connect to SPI1_RX */
N#define PDMA_CH3_UART0_RX			((uint32_t)0x12000000)			/*!<Channel 3 Connect to UART0_RX */
N#define PDMA_CH3_UART1_RX			((uint32_t)0x13000000)			/*!<Channel 3 Connect to UART1_RX */
N#define PDMA_CH3_USB_RX				((uint32_t)0x14000000)			/*!<Channel 3 Connect to USB_RX */
N#define PDMA_CH3_I2S_RX				((uint32_t)0x15000000)			/*!<Channel 3 Connect to I2S_RX */
N#define PDMA_CH3_ADC				((uint32_t)0x16000000)			/*!<Channel 3 Connect to ADC */
N#define PDMA_CH3_SPI2_RX			((uint32_t)0x18000000)			/*!<Channel 3 Connect to SPI2_RX */
N#define PDMA_CH3_PWM0_CH0			((uint32_t)0x19000000)			/*!<Channel 3 Connect to PWM0_CH0 */
N#define PDMA_CH3_PWM0_CH2			((uint32_t)0x1A000000)			/*!<Channel 3 Connect to PWM0_CH2 */
N#define PDMA_CH3_PWM1_CH0			((uint32_t)0x1B000000)			/*!<Channel 3 Connect to PWM1_CH0 */
N#define PDMA_CH3_PWM1_CH2			((uint32_t)0x1C000000)			/*!<Channel 3 Connect to PWM1_CH2 */
N#define PDMA_CH3_DISABLE			((uint32_t)0x1F000000)			/*!<Disable Channel 3 */
N#define PDMA_CH3_MASK				((uint32_t)0x1F000000)			/*!<Channel 3 Service Selection Mask */
N
N/********************* Bit definition of PDSSR1 register **********************/
N#define PDMA_CH4_SPI0_TX			((uint32_t)0x00000000)			/*!<Channel 4 Connect to SPI0_TX */
N#define PDMA_CH4_SPI1_TX			((uint32_t)0x00000001)			/*!<Channel 4 Connect to SPI1_TX */
N#define PDMA_CH4_UART0_TX			((uint32_t)0x00000002)			/*!<Channel 4 Connect to UART0_TX */
N#define PDMA_CH4_UART1_TX			((uint32_t)0x00000003)			/*!<Channel 4 Connect to UART1_TX */
N#define PDMA_CH4_USB_TX				((uint32_t)0x00000004)			/*!<Channel 4 Connect to USB_TX */
N#define PDMA_CH4_I2S_TX				((uint32_t)0x00000005)			/*!<Channel 4 Connect to I2S_TX */
N#define PDMA_CH4_DAC0_TX			((uint32_t)0x00000006)			/*!<Channel 4 Connect to DAC0_TX */
N#define PDMA_CH4_DAC1_TX			((uint32_t)0x00000007)			/*!<Channel 4 Connect to DAC1_TX */
N#define PDMA_CH4_SPI2_TX			((uint32_t)0x00000008)			/*!<Channel 4 Connect to SPI2_TX */
N#define PDMA_CH4_TMR0_CH0			((uint32_t)0x00000009)			/*!<Channel 4 Connect to TMR0_CH0 */
N#define PDMA_CH4_TMR0_CH1			((uint32_t)0x0000000A)			/*!<Channel 4 Connect to TMR0_CH1 */
N#define PDMA_CH4_TMR1_CH0			((uint32_t)0x0000000B)			/*!<Channel 4 Connect to TMR1_CH0 */
N#define PDMA_CH4_TMR1_CH1			((uint32_t)0x0000000C)			/*!<Channel 4 Connect to TMR1_CH1 */
N
N#define PDMA_CH4_SPI0_RX			((uint32_t)0x00000010)			/*!<Channel 4 Connect to SPI0_RX */
N#define PDMA_CH4_SPI1_RX			((uint32_t)0x00000011)			/*!<Channel 4 Connect to SPI1_RX */
N#define PDMA_CH4_UART0_RX			((uint32_t)0x00000012)			/*!<Channel 4 Connect to UART0_RX */
N#define PDMA_CH4_UART1_RX			((uint32_t)0x00000013)			/*!<Channel 4 Connect to UART1_RX */
N#define PDMA_CH4_USB_RX				((uint32_t)0x00000014)			/*!<Channel 4 Connect to USB_RX */
N#define PDMA_CH4_I2S_RX				((uint32_t)0x00000015)			/*!<Channel 4 Connect to I2S_RX */
N#define PDMA_CH4_ADC				((uint32_t)0x00000016)			/*!<Channel 4 Connect to ADC */
N#define PDMA_CH4_SPI2_RX			((uint32_t)0x00000018)			/*!<Channel 4 Connect to SPI2_RX */
N#define PDMA_CH4_PWM0_CH0			((uint32_t)0x00000019)			/*!<Channel 4 Connect to PWM0_CH0 */
N#define PDMA_CH4_PWM0_CH2			((uint32_t)0x0000001A)			/*!<Channel 4 Connect to PWM0_CH2 */
N#define PDMA_CH4_PWM1_CH0			((uint32_t)0x0000001B)			/*!<Channel 4 Connect to PWM1_CH0 */
N#define PDMA_CH4_PWM1_CH2			((uint32_t)0x0000001C)			/*!<Channel 4 Connect to PWM1_CH2 */
N#define PDMA_CH4_DISABLE			((uint32_t)0x0000001F)			/*!<Disable Channel 4 */
N#define PDMA_CH4_MASK				((uint32_t)0x0000001F)			/*!<Channel 4 Service Selection Mask */
N
N#define PDMA_CH5_SPI0_TX			((uint32_t)0x00000000)			/*!<Channel 5 Connect to SPI0_TX */
N#define PDMA_CH5_SPI1_TX			((uint32_t)0x00000100)			/*!<Channel 5 Connect to SPI1_TX */
N#define PDMA_CH5_UART0_TX			((uint32_t)0x00000200)			/*!<Channel 5 Connect to UART0_TX */
N#define PDMA_CH5_UART1_TX			((uint32_t)0x00000300)			/*!<Channel 5 Connect to UART1_TX */
N#define PDMA_CH5_USB_TX				((uint32_t)0x00000400)			/*!<Channel 5 Connect to USB_TX */
N#define PDMA_CH5_I2S_TX				((uint32_t)0x00000500)			/*!<Channel 5 Connect to I2S_TX */
N#define PDMA_CH5_DAC0_TX			((uint32_t)0x00000600)			/*!<Channel 5 Connect to DAC0_TX */
N#define PDMA_CH5_DAC1_TX			((uint32_t)0x00000700)			/*!<Channel 5 Connect to DAC1_TX */
N#define PDMA_CH5_SPI2_TX			((uint32_t)0x00000800)			/*!<Channel 5 Connect to SPI2_TX */
N#define PDMA_CH5_TMR0_CH0			((uint32_t)0x00000900)			/*!<Channel 5 Connect to TMR0_CH0 */
N#define PDMA_CH5_TMR0_CH1			((uint32_t)0x00000A00)			/*!<Channel 5 Connect to TMR0_CH1 */
N#define PDMA_CH5_TMR1_CH0			((uint32_t)0x00000B00)			/*!<Channel 5 Connect to TMR1_CH0 */
N#define PDMA_CH5_TMR1_CH1			((uint32_t)0x00000C00)			/*!<Channel 5 Connect to TMR1_CH1 */
N
N#define PDMA_CH5_SPI0_RX			((uint32_t)0x00001000)			/*!<Channel 5 Connect to SPI0_RX */
N#define PDMA_CH5_SPI1_RX			((uint32_t)0x00001100)			/*!<Channel 5 Connect to SPI1_RX */
N#define PDMA_CH5_UART0_RX			((uint32_t)0x00001200)			/*!<Channel 5 Connect to UART0_RX */
N#define PDMA_CH5_UART1_RX			((uint32_t)0x00001300)			/*!<Channel 5 Connect to UART1_RX */
N#define PDMA_CH5_USB_RX				((uint32_t)0x00001400)			/*!<Channel 5 Connect to USB_RX */
N#define PDMA_CH5_I2S_RX				((uint32_t)0x00001500)			/*!<Channel 5 Connect to I2S_RX */
N#define PDMA_CH5_ADC				((uint32_t)0x00001600)			/*!<Channel 5 Connect to ADC */
N#define PDMA_CH5_SPI2_RX			((uint32_t)0x00001800)			/*!<Channel 5 Connect to SPI2_RX */
N#define PDMA_CH5_PWM0_CH0			((uint32_t)0x00001900)			/*!<Channel 5 Connect to PWM0_CH0 */
N#define PDMA_CH5_PWM0_CH2			((uint32_t)0x00001A00)			/*!<Channel 5 Connect to PWM0_CH2 */
N#define PDMA_CH5_PWM1_CH0			((uint32_t)0x00001B00)			/*!<Channel 5 Connect to PWM1_CH0 */
N#define PDMA_CH5_PWM1_CH2			((uint32_t)0x00001C00)			/*!<Channel 5 Connect to PWM1_CH2 */
N#define PDMA_CH5_DISABLE			((uint32_t)0x00001F00)			/*!<Disable Channel 5 */
N#define PDMA_CH5_MASK				((uint32_t)0x00001F00)			/*!<Channel 5 Service Selection Mask */
N
N#define PDMA_CH6_SPI0_TX			((uint32_t)0x00000000)			/*!<Channel 6 Connect to SPI0_TX */
N#define PDMA_CH6_SPI1_TX			((uint32_t)0x00010000)			/*!<Channel 6 Connect to SPI1_TX */
N#define PDMA_CH6_UART0_TX			((uint32_t)0x00020000)			/*!<Channel 6 Connect to UART0_TX */
N#define PDMA_CH6_UART1_TX			((uint32_t)0x00030000)			/*!<Channel 6 Connect to UART1_TX */
N#define PDMA_CH6_USB_TX				((uint32_t)0x00040000)			/*!<Channel 6 Connect to USB_TX */
N#define PDMA_CH6_I2S_TX				((uint32_t)0x00050000)			/*!<Channel 6 Connect to I2S_TX */
N#define PDMA_CH6_DAC0_TX			((uint32_t)0x00060000)			/*!<Channel 6 Connect to DAC0_TX */
N#define PDMA_CH6_DAC1_TX			((uint32_t)0x00070000)			/*!<Channel 6 Connect to DAC1_TX */
N#define PDMA_CH6_SPI2_TX			((uint32_t)0x00080000)			/*!<Channel 6 Connect to SPI2_TX */
N#define PDMA_CH6_TMR0_CH0			((uint32_t)0x00090000)			/*!<Channel 6 Connect to TMR0_CH0 */
N#define PDMA_CH6_TMR0_CH1			((uint32_t)0x000A0000)			/*!<Channel 6 Connect to TMR0_CH1 */
N#define PDMA_CH6_TMR1_CH0			((uint32_t)0x000B0000)			/*!<Channel 6 Connect to TMR1_CH0 */
N#define PDMA_CH6_TMR1_CH1			((uint32_t)0x000C0000)			/*!<Channel 6 Connect to TMR1_CH1 */
N
N#define PDMA_CH6_SPI0_RX			((uint32_t)0x00100000)			/*!<Channel 6 Connect to SPI0_RX */
N#define PDMA_CH6_SPI1_RX			((uint32_t)0x00110000)			/*!<Channel 6 Connect to SPI1_RX */
N#define PDMA_CH6_UART0_RX			((uint32_t)0x00120000)			/*!<Channel 6 Connect to UART0_RX */
N#define PDMA_CH6_UART1_RX			((uint32_t)0x00130000)			/*!<Channel 6 Connect to UART1_RX */
N#define PDMA_CH6_USB_RX				((uint32_t)0x00140000)			/*!<Channel 6 Connect to USB_RX */
N#define PDMA_CH6_I2S_RX				((uint32_t)0x00150000)			/*!<Channel 6 Connect to I2S_RX */
N#define PDMA_CH6_ADC				((uint32_t)0x00160000)			/*!<Channel 6 Connect to ADC */
N#define PDMA_CH6_SPI2_RX			((uint32_t)0x00180000)			/*!<Channel 6 Connect to SPI2_RX */
N#define PDMA_CH6_PWM0_CH0			((uint32_t)0x00190000)			/*!<Channel 6 Connect to PWM0_CH0 */
N#define PDMA_CH6_PWM0_CH2			((uint32_t)0x001A0000)			/*!<Channel 6 Connect to PWM0_CH2 */
N#define PDMA_CH6_PWM1_CH0			((uint32_t)0x001B0000)			/*!<Channel 6 Connect to PWM1_CH0 */
N#define PDMA_CH6_PWM1_CH2			((uint32_t)0x001C0000)			/*!<Channel 6 Connect to PWM1_CH2 */
N#define PDMA_CH6_DISABLE			((uint32_t)0x001F0000)			/*!<Disable Channel 6 */
N#define PDMA_CH6_MASK				((uint32_t)0x001F0000)			/*!<Channel 6 Service Selection Mask */
N
N/********************* Bit definition of ISR register **********************/
N#define PDMAGCR_ISR_INTR0			((uint32_t)0x00000001)			/*!<Interrupt Pin Status Of Channel 0 */
N#define PDMAGCR_ISR_INTR1			((uint32_t)0x00000002)			/*!<Interrupt Pin Status Of Channel 1 */
N#define PDMAGCR_ISR_INTR2			((uint32_t)0x00000004)			/*!<Interrupt Pin Status Of Channel 2 */
N#define PDMAGCR_ISR_INTR3			((uint32_t)0x00000008)			/*!<Interrupt Pin Status Of Channel 3 */
N#define PDMAGCR_ISR_INTR4			((uint32_t)0x00000010)			/*!<Interrupt Pin Status Of Channel 4 */
N#define PDMAGCR_ISR_INTR5			((uint32_t)0x00000020)			/*!<Interrupt Pin Status Of Channel 5 */
N#define PDMAGCR_ISR_INTR6			((uint32_t)0x00000040)			/*!<Interrupt Pin Status Of Channel 6 */
N#define PDMAGCR_ISR_CRC				((uint32_t)0x00010000)			/*!<Interrupt Pin Status Of CRC */
N
N
N/******************************************************************************/
N/*                FMC                                                         */
N/******************************************************************************/
N/********************* Bit definition of ISPCON register **********************/
N#define FMC_ISPCON_ISPEN			((uint32_t)0x00000001)			/*!<ISP function enable */
N#define FMC_ISPCON_BS				((uint32_t)0x00000002)			/*!<Boot Select */
N#define FMC_ISPCON_APUEN			((uint32_t)0x00000008)			/*!<User-Hidden-Block Update Enable (Write-protection Bit) */
N#define FMC_ISPCON_CFGUEN			((uint32_t)0x00000010)			/*!<Enable Config-bits Update by ISP (Write-protection Bit) */
N#define FMC_ISPCON_LDUEN			((uint32_t)0x00000020)			/*!<LDROM Update Enable (Write-protection Bit) */
N#define FMC_ISPCON_ISPFF			((uint32_t)0x00000040)			/*!<ISP Fail Flag (Write-protection Bit) */
N
N/********************* Bit definition of ISPCMD register **********************/
N#define FMC_ISPCMD_CMD_MASK			((uint32_t)0x0000003F)			/*!<ISP Command Mask */
N#define FMC_ISPCMD_READ				((uint32_t)0x00000000)			/*!<ISP Command - Read */
N#define FMC_ISPCMD_VECMAP			((uint32_t)0x0000002E)			/*!<ISP Command - Vector Page Re-Map */
N#define FMC_ISPCMD_PROGRAM			((uint32_t)0x00000021)			/*!<ISP Command - Program */
N#define FMC_ISPCMD_PAGE_ERASE		((uint32_t)0x00000022)			/*!<ISP Command - Page Erase */
N#define FMC_ISPCMD_READ_CID			((uint32_t)0x0000000B)			/*!<ISP Command - Read CID */
N#define FMC_ISPCMD_READ_DID			((uint32_t)0x0000000C)			/*!<ISP Command - Read DID */
N#define FMC_ISPCMD_READ_UID			((uint32_t)0x00000004)			/*!<ISP Command - Read UID */
N
N/********************* Bit definition of ISPTRG register **********************/
N#define FMC_ISPTRG_ISPGO			((uint32_t)0x00000001)			/*!<ISP Start Trigger */
N
N/********************* Bit definition of ISPSTA register **********************/
N#define FMC_ISPSTA_ISPBUSY			((uint32_t)0x00000001)			/*!<ISP Busy */
N#define FMC_ISPSTA_CBS_MASK			((uint32_t)0x00000006)			/*!<Boot Selection bit mask */
N#define FMC_ISPSTA_CBS_11			((uint32_t)0x00000006)			/*!<Boot from APROM w/o vecmap */
N#define FMC_ISPSTA_CBS_10			((uint32_t)0x00000004)			/*!<Boot from APROM with vecmap */
N#define FMC_ISPSTA_CBS_01			((uint32_t)0x00000002)			/*!<Boot from LDROM w/o vecmap */
N#define FMC_ISPSTA_CBS_00			((uint32_t)0x00000000)			/*!<Boot from LDROM with vecmap */
N#define FMC_ISPSTA_ISPFF			((uint32_t)0x00000040)			/*!<ISP fail flag */
N#define FMC_ISPSTA_VECMAP_MASK		((uint32_t)0x001FFF00)			/*!<Vector page mapping address mask */
N
N
N/******************************************************************************/
N/*                EBI                                                         */
N/******************************************************************************/
N/********************* Bit definition of EBICON register **********************/
N#define EBI_EBICON_ExtEN			((uint32_t)0x00000001)			/*!<EBI enable */
N#define EBI_EBICON_ExtBW16			((uint32_t)0x00000002)			/*!<EBI data width, 0: 8-bit; 1: 16-bit */
N#define EBI_EBICON_MCLKDIV_MASK		((uint32_t)0x00000700)			/*!<EBI external output clock divider mask */
N#define EBI_EBICON_MCLKDIV_HCLK_1	((uint32_t)0x00000000)			/*!<MCLK = HCLK/1 */
N#define EBI_EBICON_MCLKDIV_HCLK_2	((uint32_t)0x00000100)			/*!<MCLK = HCLK/2 */
N#define EBI_EBICON_MCLKDIV_HCLK_4	((uint32_t)0x00000200)			/*!<MCLK = HCLK/4 */
N#define EBI_EBICON_MCLKDIV_HCLK_8	((uint32_t)0x00000300)			/*!<MCLK = HCLK/8 */
N#define EBI_EBICON_MCLKDIV_HCLK_16	((uint32_t)0x00000400)			/*!<MCLK = HCLK/16 */
N#define EBI_EBICON_MCLKDIV_HCLK_32	((uint32_t)0x00000500)			/*!<MCLK = HCLK/32 */
N#define EBI_EBICON_MCLKEN			((uint32_t)0x00000800)			/*!<External clock enable */
N#define EBI_EBICON_ExtALE_MASK		((uint32_t)0x00070000)			/*!<Expand time of ALE mask */
N
N/********************* Bit definition of EXTIME register **********************/
N#define EBI_EXTIME_ExttAAC_MASK		((uint32_t)0x0000001F)			/*!<Data access time mask */
N#define EBI_EXTIME_ExttAHD_MASK		((uint32_t)0x00000700)			/*!<Data access hold time mask */
N#define EBI_EXTIME_ExtlW2X_MASK		((uint32_t)0x0000F000)			/*!<Idle state cycle of write mask */
N#define EBI_EXTIME_ExtlR2W_MASK		((uint32_t)0x000F0000)			/*!<Idle state cycle between read-write mask */
N#define EBI_EXTIME_ExtlR2R_MASK		((uint32_t)0x0F000000)			/*!<Idle state cycle between read-read mask */
N
N
N/******************************************************************************/
N/*                WDT                                                         */
N/******************************************************************************/
N/********************* Bit definition of CTL register **********************/
N#define WDT_CTL_WTR					((uint32_t)0x00000001)			/*!<Clear Watchdog Timer */
N#define WDT_CTL_WTRE				((uint32_t)0x00000002)			/*!<Watchdog Timer Reset Function Enable */
N#define WDT_CTL_WTWKE				((uint32_t)0x00000004)			/*!<Watchdog Timer Wake-Up Function Enable */
N#define WDT_CTL_WTE					((uint32_t)0x00000008)			/*!<Watchdog Timer Enable */
N#define WDT_CTL_WTIS_2POW4			((uint32_t)0x00000000)			/*!<Watchdog Timer Interval Select ((2 ^ 4) + 1) Clk */
N#define WDT_CTL_WTIS_2POW6			((uint32_t)0x00000010)			/*!<Watchdog Timer Interval Select ((2 ^ 6) + 1) Clk */
N#define WDT_CTL_WTIS_2POW8			((uint32_t)0x00000020)			/*!<Watchdog Timer Interval Select ((2 ^ 8) + 1) Clk */
N#define WDT_CTL_WTIS_2POW10			((uint32_t)0x00000030)			/*!<Watchdog Timer Interval Select ((2 ^ 10) + 1) Clk */
N#define WDT_CTL_WTIS_2POW12			((uint32_t)0x00000040)			/*!<Watchdog Timer Interval Select ((2 ^ 12) + 1) Clk */
N#define WDT_CTL_WTIS_2POW14			((uint32_t)0x00000050)			/*!<Watchdog Timer Interval Select ((2 ^ 14) + 1) Clk */
N#define WDT_CTL_WTIS_2POW16			((uint32_t)0x00000060)			/*!<Watchdog Timer Interval Select ((2 ^ 16) + 1) Clk */
N#define WDT_CTL_WTIS_2POW18			((uint32_t)0x00000070)			/*!<Watchdog Timer Interval Select ((2 ^ 18) + 1) Clk */
N#define WDT_CTL_WTIS_MASK			((uint32_t)0x00000070)			/*!<Watchdog Timer Interval Select Mask */
N#define WDT_CTL_WTRDSEL_1026CLK		((uint32_t)0x00000000)			/*!<Watchdog Reset Delay Period 1026 Clk */
N#define WDT_CTL_WTRDSEL_130CLK		((uint32_t)0x00000100)			/*!<Watchdog Reset Delay Period 130 Clk */
N#define WDT_CTL_WTRDSEL_18CLK		((uint32_t)0x00000200)			/*!<Watchdog Reset Delay Period 18 Clk */
N#define WDT_CTL_WTRDSEL_3CLK		((uint32_t)0x00000300)			/*!<Watchdog Reset Delay Period 3 Clk */
N#define WDT_CTL_WTRDSEL_MASK		((uint32_t)0x00000300)			/*!<Watchdog Reset Delay Period Mask */
N
N/********************* Bit definition of IER register **********************/
N#define WDT_IER_WDTIE				((uint32_t)0x00000001)			/*!<Watchdog Timer Interrupt Enable */
N
N/********************* Bit definition of ISR register **********************/
N#define WDT_ISR_WDTIS				((uint32_t)0x00000001)			/*!<Watchdog Timer Interrupt Enable */
N#define WDT_ISR_WDTRSTIS			((uint32_t)0x00000002)			/*!<Watchdog Timer Reset Status */
N#define WDT_ISR_WDTWAKEIS			((uint32_t)0x00000004)			/*!<Watchdog Timer Wake-Up Status */
N
N/******************************************************************************/
N/*                WWDT                                                        */
N/******************************************************************************/
N/********************* Bit definition of CR register **********************/
N#define WWDT_CR_WWDTEN				((uint32_t)0x00000001)			/*!<Window Watchdog Enable */
N#define WWDT_CR_PERIODSEL_1			((uint32_t)0x00000000)			/*!<WWDT Pre-scale Period Set to 1 */
N#define WWDT_CR_PERIODSEL_2			((uint32_t)0x00000100)			/*!<WWDT Pre-scale Period Set to 2 */
N#define WWDT_CR_PERIODSEL_4			((uint32_t)0x00000200)			/*!<WWDT Pre-scale Period Set to 4 */
N#define WWDT_CR_PERIODSEL_8			((uint32_t)0x00000300)			/*!<WWDT Pre-scale Period Set to 8 */
N#define WWDT_CR_PERIODSEL_16		((uint32_t)0x00000400)			/*!<WWDT Pre-scale Period Set to 16 */
N#define WWDT_CR_PERIODSEL_32		((uint32_t)0x00000500)			/*!<WWDT Pre-scale Period Set to 32 */
N#define WWDT_CR_PERIODSEL_64		((uint32_t)0x00000600)			/*!<WWDT Pre-scale Period Set to 64 */
N#define WWDT_CR_PERIODSEL_128		((uint32_t)0x00000700)			/*!<WWDT Pre-scale Period Set to 128 */
N#define WWDT_CR_PERIODSEL_192		((uint32_t)0x00000800)			/*!<WWDT Pre-scale Period Set to 192 */
N#define WWDT_CR_PERIODSEL_256		((uint32_t)0x00000900)			/*!<WWDT Pre-scale Period Set to 256 */
N#define WWDT_CR_PERIODSEL_384		((uint32_t)0x00000A00)			/*!<WWDT Pre-scale Period Set to 384 */
N#define WWDT_CR_PERIODSEL_512		((uint32_t)0x00000B00)			/*!<WWDT Pre-scale Period Set to 512 */
N#define WWDT_CR_PERIODSEL_768		((uint32_t)0x00000C00)			/*!<WWDT Pre-scale Period Set to 768 */
N#define WWDT_CR_PERIODSEL_1024		((uint32_t)0x00000D00)			/*!<WWDT Pre-scale Period Set to 1024 */
N#define WWDT_CR_PERIODSEL_1536		((uint32_t)0x00000E00)			/*!<WWDT Pre-scale Period Set to 1536 */
N#define WWDT_CR_PERIODSEL_2048		((uint32_t)0x00000F00)			/*!<WWDT Pre-scale Period Set to 2048 */
N#define WWDT_CR_PERIODSEL_MASK		((uint32_t)0x00000F00)			/*!<WWDT Pre-scale Period Select Mask */
N#define WWDT_CR_WINCMP_MASK			((uint32_t)0x003F0000)			/*!<WWDT Window Compare Register */
N#define WWDT_CR_DBGEN				((uint32_t)0x80000000)			/*!<WWDT Debug Enable */
N
N/********************* Bit definition of IER register **********************/
N#define WWDT_IER_IE					((uint32_t)0x00000001)			/*!<WWDT Interrupt Enable */
N
N/********************* Bit definition of STS register **********************/
N#define WWDT_STS_IF					((uint32_t)0x00000001)			/*!<WWDT Compare Match Interrupt Flag */
N#define WWDT_STS_RF					((uint32_t)0x00000002)			/*!<WWDT Reset Flag */
N
N/********************* Bit definition of VAL register **********************/
N#define WWDT_VAL_VAL_MASK			((uint32_t)0x0000003F)			/*!<WWDT Counter Value Mask */
N
N
N/******************************************************************************/
N/*                RTC                                                         */
N/******************************************************************************/
N/********************* Bit definition of AER register **********************/
N#define RTC_AER_AER					((uint32_t)0x0000FFFF)			/*!<RTC Register Access Enable Password (Write only) */
N#define RTC_AER_ENF					((uint32_t)0x00010000)			/*!<RTC Register Access Enable Flag (Read only) */
N/********************* Bit definition of FCR register **********************/
N#define RTC_FCR_FRACTION			((uint32_t)0x0000003F)			/*!<Fraction Part */
N#define RTC_FCR_INTEGER				((uint32_t)0x00000F00)			/*!<Integer Part */
N/********************* Bit definition of TLR register **********************/
N#define RTC_TLR_SEC					((uint32_t)0x0000000F)			/*!<1 Sec Time Digit (0~9) */
N#define RTC_TLR_TEN_SEC				((uint32_t)0x00000070)			/*!<10 Sec Time Digit (0~5) */
N#define RTC_TLR_MIN					((uint32_t)0x00000F00)			/*!<1 Min Time Digit (0~9) */
N#define RTC_TLR_TEN_MIN				((uint32_t)0x00007000)			/*!<10 Min Time Digit (0~5) */
N#define RTC_TLR_HR					((uint32_t)0x000F0000)			/*!<1 Hour Time Digit (0~9) */
N#define RTC_TLR_TEN_HR				((uint32_t)0x00300000)			/*!<10 Hour Time Digit (0~2) */
N/********************* Bit definition of CLR register **********************/
N#define RTC_CLR_DAY					((uint32_t)0x0000000F)			/*!<1 Day Calendar Digit (0~9) */
N#define RTC_CLR_TEN_DAY				((uint32_t)0x00000030)			/*!<10 Day Calendar Digit (0~3) */
N#define RTC_CLR_MON					((uint32_t)0x00000F00)			/*!<1 Month Calendar Digit (0~9) */
N#define RTC_CLR_TEN_MON				((uint32_t)0x00001000)			/*!<10 Month Calendar Digit (0~1) */
N#define RTC_CLR_YEAR				((uint32_t)0x000F0000)			/*!<1 Year Calendar Digit (0~9) */
N#define RTC_CLR_TEN_YEAR			((uint32_t)0x00F00000)			/*!<10 Year Calendar Digit (0~9) */
N/********************* Bit definition of TSSR register **********************/
N#define RTC_TSSR_24hr				((uint32_t)0x00000001)			/*!<24-Hour / 12-Hour Mode Selection */
N/********************* Bit definition of DWR register **********************/
N#define RTC_DWR_DWR					((uint32_t)0x00000007)			/*!<Day of the Week Register */
N/********************* Bit definition of TAR register **********************/
N#define RTC_TAR_SEC					((uint32_t)0x0000000F)			/*!<1 Sec Time Digit of Alarm Setting (0~9) */
N#define RTC_TAR_TEN_SEC				((uint32_t)0x00000070)			/*!<10 Sec Time Digit of Alarm Setting (0~5) */
N#define RTC_TAR_MIN					((uint32_t)0x00000F00)			/*!<1 Min Time Digit of Alarm Setting (0~9) */
N#define RTC_TAR_TEN_MIN				((uint32_t)0x00007000)			/*!<10 Min Time Digit of Alarm Setting (0~5) */
N#define RTC_TAR_HR					((uint32_t)0x000F0000)			/*!<1 Hour Time Digit of Alarm Setting (0~9) */
N#define RTC_TAR_TEN_HR				((uint32_t)0x00300000)			/*!<10 Hour Time Digit of Alarm Setting (0~2) */
N/********************* Bit definition of CAR register **********************/
N#define RTC_CAR_DAY					((uint32_t)0x0000000F)			/*!<1 Day Calendar Digit of Alarm Setting (0~9) */
N#define RTC_CAR_TEN_DAY				((uint32_t)0x00000030)			/*!<10 Day Calendar Digit of Alarm Setting (0~3) */
N#define RTC_CAR_MON					((uint32_t)0x00000F00)			/*!<1 Month Calendar Digit of Alarm Setting (0~9) */
N#define RTC_CAR_TEN_MON				((uint32_t)0x00001000)			/*!<10 Month Calendar Digit of Alarm Setting (0~1) */
N#define RTC_CAR_YEAR				((uint32_t)0x000F0000)			/*!<1 Year Calendar Digit of Alarm Setting (0~9) */
N#define RTC_CAR_TEN_YEAR			((uint32_t)0x00F00000)			/*!<10 Year Calendar Digit of Alarm Setting (0~9) */
N/********************* Bit definition of LIR register **********************/
N#define RTC_LIR_LIR					((uint32_t)0x00000001)			/*!<Leap Year Indication REGISTER (Read only) */
N/********************* Bit definition of RIER register **********************/
N#define RTC_RIER_AIER				((uint32_t)0x00000001)			/*!<Alarm Interrupt Enable */
N#define RTC_RIER_TIER				((uint32_t)0x00000002)			/*!<Time Tick Interrupt and Wake-up by Tick Enable */
N#define RTC_RIER_SNOOPIER			((uint32_t)0x00000004)			/*!<Snooper Pin Event Detection Interrupt Enable */
N/********************* Bit definition of RIIR register **********************/
N#define RTC_RIIR_AIS				((uint32_t)0x00000001)			/*!<RTC Alarm Interrupt Status */
N#define RTC_RIIR_TIS				((uint32_t)0x00000002)			/*!<RTC Time Tick Interrupt Status */
N#define RTC_RIIR_SNOOPIS			((uint32_t)0x00000004)			/*!<Snooper Pin Event Detection Interrupt Status */
N/********************* Bit definition of TTR register **********************/
N#define RTC_TTR_TTR				((uint32_t)0x00000007)			/*!<Time Tick Register */
N#define RTC_TTR_TWKE			((uint32_t)0x00000008)			/*!<RTC Timer Wake-up CPU Function Enable Bit */
N/********************* Bit definition of SPRCTL register **********************/
N#define RTC_SPRCTL_SNOOPEN		((uint32_t)0x00000001)			/*!<Snooper Pin Event Detection Enable */
N#define RTC_SPRCTL_SNOOPEDGE	((uint32_t)0x00000002)			/*!<Snooper Active Edge Selection */
N#define RTC_SPRCTL_SPRRDY		((uint32_t)0x00000080)			/*!<SPR Register Ready */
N
N
N/******************************************************************************/
N/*                TIMER                                                       */
N/******************************************************************************/
N/********************* Bit definition of CTL register **********************/
N#define TIMER_CTL_TMREN				((uint32_t)0x00000001)			/*!<Timer Counter Enable Bit */
N#define TIMER_CTL_SWRST				((uint32_t)0x00000002)			/*!<Software Reset */
N#define TIMER_CTL_WAKEEN			((uint32_t)0x00000004)			/*!<Wake-up Enable */
N#define TIMER_CTL_DBGACKEN			((uint32_t)0x00000005)			/*!<ICE Debug Mode Acknowledge Ineffective Enable */
N#define TIMER_CTL_MODESEL_ONESHOT	((uint32_t)0x00000000)			/*!<Timer Operate in One Shot Mode */
N#define TIMER_CTL_MODESEL_PERIODIC	((uint32_t)0x00000010)			/*!<Timer Operate in Periodic Mode */
N#define TIMER_CTL_MODESEL_TOGGLE	((uint32_t)0x00000020)			/*!<Timer Operate in Toggle Mode */
N#define TIMER_CTL_MODESEL_CONTINUOUS	((uint32_t)0x00000030)		/*!<Timer Operate in Continuous Mode */
N#define TIMER_CTL_MODESEL_MASK		((uint32_t)0x00000030)			/*!<Timer Operating Mode Select Mask */
N#define TIMER_CTL_TMRACT			((uint32_t)0x00000080)			/*!<Timer Active Status Bit */
N#define TIMER_CTL_ADCTEEN			((uint32_t)0x00000100)			/*!<TMR_IS or TCAP_IS Trigger ADC Enable */
N#define TIMER_CTL_DACTEEN			((uint32_t)0x00000200)			/*!<TMR_IS or TCAP_IS Trigger DAC Enable */
N#define TIMER_CTL_PDMA_TEEN			((uint32_t)0x00000400)			/*!<TMR_IS or TCAP_IS Trigger PDMA Enable */
N#define TIMER_CTL_CAPTRGEN			((uint32_t)0x00000800)			/*!<TCAP_IS Trigger Mode Enable */
N#define TIMER_CTL_TIMEOUTTRGEN			((uint32_t)0x00000000)			/*!<TMRS Trigger Mode Enable */
N#define TIMER_CTL_EVNTEN			((uint32_t)0x00001000)			/*!<Event Counting Mode Enable */
N#define TIMER_CTL_EVNTEDGE_R			((uint32_t)0x00002000)			/*!<Event Counting Mode Edge Selection */
N#define TIMER_CTL_EVNTEDGE_F			((uint32_t)0x00000000)			/*!<Event Counting Mode Edge Selection */
N#define TIMER_CTL_EVNTDEBEN			((uint32_t)0x00004000)			/*!<External Event De-bounce Enable */
N#define TIMER_CTL_TKWAKEEN			((uint32_t)0x00008000)			/*!<Wake-up Touch-Key Enable */
N#define TIMER_CTL_TCAPEN			((uint32_t)0x00010000)			/*!<TCapture Pin Functional Enable */
N#define TIMER_CTL_TCAPMODE			((uint32_t)0x00020000)			/*!<TCapture Pin Function Mode Selection */
N#define TIMER_CTL_TCAPEDGE_FF		((uint32_t)0x00000000)			/*!<TCapture Pin Falling-Falling Detect Selection */
N#define TIMER_CTL_TCAPEDGE_RR		((uint32_t)0x00040000)			/*!<TCapture Pin Rising-Rising Detect Selection */
N#define TIMER_CTL_TCAPEDGE_FR		((uint32_t)0x00080000)			/*!<TCapture Pin Falling-Rising Detect Selection */
N#define TIMER_CTL_TCAPEDGE_RF		((uint32_t)0x000C0000)			/*!<TCapture Pin Falling-Rising Detect Selection */
N#define TIMER_CTL_TCAPEDGE_MASK		((uint32_t)0x000C0000)			/*!<TCapture Pin Edge Detect Selection Mask */
N#define TIMER_CTL_CAPCNTMOD			((uint32_t)0x00100000)			/*!<Timer Capture Counting Mode Selection */
N#define TIMER_CTL_CAPCNTMOD_FREE_CNT		((uint32_t)0x00000000)			/*!<Free Counting Mode */
N#define TIMER_CTL_CAPCNTMOD_TRIGGER_CNT		((uint32_t)0x00100000)			/*!<Trigger Counting Mode */
N#define TIMER_CTL_TCAPDEBEN			((uint32_t)0x00400000)			/*!<TCapture Pin De-bounce Enable */
N#define TIMER_CTL_INTRTRGEN			((uint32_t)0x01000000)			/*!<Inter-Timer Trigger Mode Enable */
N
N/********************* Bit definition of PRECNT register **********************/
N#define TIMER_PRECNT_PRESCALECNT_MASK	((uint32_t)0x000000FF)		/*!<Pre-scale Counter */
N
N/********************* Bit definition of CMPR register **********************/
N#define TIMER_CMPR_TMRCMP_MASK		((uint32_t)0x00FFFFFF)			/*!<Timer Compared Value */
N
N/********************* Bit definition of IER register **********************/
N#define TIMER_IER_TMRIE				((uint32_t)0x00000001)			/*!<Timer Interrupt Enable */
N#define TIMER_IER_TCAPIE			((uint32_t)0x00000002)			/*!<Timer Capture Function Interrupt Enable */
N
N/********************* Bit definition of ISR register **********************/
N#define TIMER_ISR_TMRIS				((uint32_t)0x00000001)			/*!<Timer Interrupt Status */
N#define TIMER_ISR_TCAPIS			((uint32_t)0x00000002)			/*!<Timer Capture Function Interrupt Status */
N#define TIMER_ISR_TMRWAKESTS		((uint32_t)0x00000010)			/*!<Timer Wake-up Status */
N#define TIMER_ISR_NCAPDETSTS		((uint32_t)0x00000020)			/*!<New Capture Detected Status */
N
N/********************* Bit definition of DR register **********************/
N#define TIMER_DR_TDR_MASK			((uint32_t)0x00FFFFFF)			/*!<Timer Data Mask */
N
N/********************* Bit definition of TCAP register **********************/
N#define TIMER_TCAP_CAP_MASK			((uint32_t)0x00FFFFFF)			/*!<Timer Capture Data Mask */
N
N
N
N/******************************************************************************/
N/*                I2C                                                         */
N/******************************************************************************/
N/********************* Bit definition of CON register **********************/
N#define I2C_CON_IPEN			((uint32_t)0x00000001)			/*!<I2C Function Enable */
N#define I2C_CON_ACK				((uint32_t)0x00000002)			/*!<Assert Acknowledge Control Bit */
N#define I2C_CON_STOP			((uint32_t)0x00000004)			/*!<I2C STOP Control Bit */
N#define I2C_CON_START			((uint32_t)0x00000008)			/*!<I2C START Control Bit */
N#define I2C_CON_I2C_STS			((uint32_t)0x00000010)			/*!<I2C Status */
N#define I2C_CON_INTEN			((uint32_t)0x00000080)			/*!<Enable Interrupt */
N
N/********************* Bit definition of INTSTS register **********************/
N#define I2C_INTSTS_INTSTS		((uint32_t)0x00000001)			/*!<Interrupt Status */
N#define I2C_INTSTS_TIF			((uint32_t)0x00000002)			/*!<Time Out Status */
N
N/********************* Bit definition of TOUT register **********************/
N#define I2C_TOUT_TOUTEN			((uint32_t)0x00000001)			/*!<Time-Out Enable */
N#define I2C_TOUT_DIV4			((uint32_t)0x00000002)			/*!<Time-Out counter input clock is divided by 4 */
N
N/********************* Bit definition of SADDR0 register **********************/
N#define I2C_SADDR0_GC			((uint32_t)0x00000001)			/*!<General Call Function */
N#define I2C_SADDR0_ADDR_MASK	((uint32_t)0x000000FE)			/*!<I2C Address Register */
N
N/********************* Bit definition of SADDR1 register **********************/
N#define I2C_SADDR1_GC			((uint32_t)0x00000001)			/*!<General Call Function */
N#define I2C_SADDR1_ADDR_MASK	((uint32_t)0x000000FE)			/*!<I2C Address Register */
N
N/********************* Bit definition of WKUPCON register **********************/
N#define I2C_WKUPCON_WKUPEN		((uint32_t)0x00000001)			/*!<I2C Wakeup Enable */
N
N/********************* Bit definition of WKUPSTS register **********************/
N#define I2C_WKUPSTS_WKUPIF		((uint32_t)0x00000001)			/*!<I2C Wakeup Flag */
N
N
N
N/******************************************************************************/
N/*                           SPI                                              */
N/******************************************************************************/
N/********************* Bit definition of SPI_CTL register **********************/
N#define SPI_CTL_GO_BUSY					((uint32_t)0x00000001)			/*!<Go and Busy Status */
N#define SPI_CTL_RX_NEG					((uint32_t)0x00000002)			/*!<Receive on Negative Edge */
N#define SPI_CTL_TX_NEG					((uint32_t)0x00000004)			/*!<Transmit on Negative Edge */
N#define SPI_CTL_TX_BIT_LEN_8BIT			((uint32_t)0x00000040)			/*!<8-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_9BIT			((uint32_t)0x00000048)			/*!<9-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_10BIT		((uint32_t)0x00000050)			/*!<10-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_11BIT		((uint32_t)0x00000058)			/*!<11-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_12BIT		((uint32_t)0x00000060)			/*!<12-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_13BIT		((uint32_t)0x00000068)			/*!<13-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_14BIT		((uint32_t)0x00000070)			/*!<14-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_15BIT		((uint32_t)0x00000078)			/*!<15-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_16BIT		((uint32_t)0x00000080)			/*!<16-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_17BIT		((uint32_t)0x00000088)			/*!<17-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_18BIT		((uint32_t)0x00000090)			/*!<18-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_19BIT		((uint32_t)0x00000098)			/*!<19-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_20BIT		((uint32_t)0x000000A0)			/*!<20-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_21BIT		((uint32_t)0x000000A8)			/*!<21-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_22BIT		((uint32_t)0x000000B0)			/*!<22-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_23BIT		((uint32_t)0x000000B8)			/*!<23-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_24BIT		((uint32_t)0x000000C0)			/*!<24-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_25BIT		((uint32_t)0x000000C8)			/*!<25-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_26BIT		((uint32_t)0x000000D0)			/*!<26-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_27BIT		((uint32_t)0x000000D8)			/*!<27-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_28BIT		((uint32_t)0x000000E0)			/*!<28-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_29BIT		((uint32_t)0x000000E8)			/*!<29-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_30BIT		((uint32_t)0x000000F0)			/*!<30-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_31BIT		((uint32_t)0x000000F8)			/*!<31-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_32BIT		((uint32_t)0x00000000)			/*!<32-bit Transmit Length */
N#define SPI_CTL_TX_BIT_LEN_MASK			((uint32_t)0x000000F8)			/*!<Transmit Bit Length */
N#define SPI_CTL_LSB						((uint32_t)0x00000400)			/*!<Send LSB First */
N#define SPI_CTL_CLKP					((uint32_t)0x00000800)			/*!<Clock Polarity */
N#define SPI_CTL_SP_CYCLE				((uint32_t)0x0000F000)			/*!<Suspend Interval */
N#define SPI_CTL_INTEN					((uint32_t)0x00020000)			/*!<Interrupt Enable */
N#define SPI_CTL_SLAVE					((uint32_t)0x00040000)			/*!<Slave Mode Enable */
N#define SPI_CTL_REORDER					((uint32_t)0x00080000)			/*!<Byte Reorder Function Enable */
N#define SPI_CTL_FIFOM					((uint32_t)0x00200000)			/*!<FIFO Mode Enable */
N#define SPI_CTL_TWOB					((uint32_t)0x00400000)			/*!<Two Bit Transfer Mode Enable */
N#define SPI_CTL_VARCLK_EN				((uint32_t)0x00800000)			/*!<Variable Clock Enable */
N#define SPI_CTL_DUAL_IO_DIR				((uint32_t)0x10000000)			/*!<Dual IO Mode Direction Control */
N#define SPI_CTL_DUAL_IO_EN				((uint32_t)0x20000000)			/*!<Dual IO Mode Enable */
N#define SPI_CTL_WKEUP_EN				((uint32_t)0x80000000)			/*!<Wake-Up Enable */
N
N/********************* Bit definition of STATUS register **********************/
N#define SPI_STATUS_RX_EMPTY				((uint32_t)0x00000001)			/*!<Receive FIFO Buffer Empty Flag */
N#define SPI_STATUS_RX_FULL				((uint32_t)0x00000002)			/*!<Receive FIFO Buffer Full Flag */
N#define SPI_STATUS_TX_EMPTY				((uint32_t)0x00000004)			/*!<Transmit FIFO Buffer Empty Flag */
N#define SPI_STATUS_TX_FULL				((uint32_t)0x00000008)			/*!<Transmit FIFO Buffer Full Flag */
N#define SPI_STATUS_SLV_START_INTSTS		((uint32_t)0x00000040)			/*!<Interrupt Flag */
N#define SPI_STATUS_INTSTS				((uint32_t)0x00000080)			/*!<Slave Start Interrupt Status Flag */
N#define SPI_STATUS_RXINT_STS			((uint32_t)0x00000100)			/*!<Receive FIFO Threshold Interrupt Flag */
N#define SPI_STATUS_RX_OVER_RUN			((uint32_t)0x00000200)			/*!<Receive FIFO Overrun Interrupt Flag */
N#define SPI_STATUS_TXINT_STS			((uint32_t)0x00000400)			/*!<Transmit FIFO Threshold Interrupt Flag */
N#define SPI_STATUS_TIMEOUT_STS			((uint32_t)0x00001000)			/*!<Time-out Interrupt Flag */
N#define SPI_STATUS_RX_FIFO_CNT			((uint32_t)0x000F0000)			/*!<Receive FIFO Data Count */
N#define SPI_STATUS_TX_FIFO_CNT			((uint32_t)0x00F00000)			/*!<Transmit FIFO Data Count */
N
N/********************* Bit definition of CLKDIV register **********************/
N#define SPI_CLKDIV_DIVIDER1_MASK			((uint32_t)0x000000FF)			/*!<Clock Divider 1*/
N#define SPI_CLKDIV_DIVIDER2_MASK			((uint32_t)0x00FF0000)			/*!<Clock Divider 2*/
N
N/********************* Bit definition of SSR register **********************/
N#define SPI_SSR_SSR_SS0					((uint32_t)0x00000001)			/*!<Slave Select Bit 0 */
N#define SPI_SSR_SSR_SS1					((uint32_t)0x00000002)			/*!<Slave Select Bit 1 */
N#define SPI_SSR_SSR_MASK				((uint32_t)0x00000003)			/*!<Slave Select Control */
N#define SPI_SSR_SS_LVL					((uint32_t)0x00000004)			/*!<Slave Select Active Level Setting */
N#define SPI_SSR_AUTOSS					((uint32_t)0x00000008)			/*!<Automatic Slave Select Function Enable */
N#define SPI_SSR_SS_LTRIG				((uint32_t)0x00000010)			/*!<Slave Select Level Trigger */
N#define SPI_SSR_NOSLVSEL				((uint32_t)0x00000020)			/*!<Slave 3-wire Mode Enable */
N#define SPI_SSR_SLV_ABORT				((uint32_t)0x00000100)			/*!<Abort in Slave Mode with No Slave Selected */
N#define SPI_SSR_SSTA_INTEN				((uint32_t)0x00000200)			/*!<Slave Start Interrupt Enable */
N#define SPI_SSR_SS_INT_OPT				((uint32_t)0x00010000)			/*!<Slave Select Interrupt Option */
N
N/********************* Bit definition of PDMA register **********************/
N#define SPI_PDMA_TX_DMA_EN				((uint32_t)0x00000001)			/*!<Transmit PDMA Enable */
N#define SPI_PDMA_RX_DMA_EN				((uint32_t)0x00000002)			/*!<Receive PDMA Enable */
N#define SPI_PDMA_PDMA_RST				((uint32_t)0x00000004)			/*!<PDMA Reset */
N
N/********************* Bit definition of FFCTL register **********************/
N#define SPI_FFCTL_RX_CLR				((uint32_t)0x00000001)			/*!<Clear Receive FIFO Buffer */
N#define SPI_FFCTL_TX_CLR				((uint32_t)0x00000002)			/*!<Clear Transmit FIFO Buffer */
N#define SPI_FFCTL_RXINT_EN				((uint32_t)0x00000004)			/*!<Receive FIFO Threshold Interrupt Enable */
N#define SPI_FFCTL_TXINT_EN				((uint32_t)0x00000008)			/*!<Transmit FIFO Threshold Interrupt Enable */
N#define SPI_FFCTL_RXOV_INTEN			((uint32_t)0x00000010)			/*!<Receive FIFO Overrun Interrupt Enable */
N#define SPI_FFCTL_TIMEOUT_INTEN			((uint32_t)0x00000080)			/*!<Receive FIFO Time-out Interrupt Enable */
N#define SPI_FFCTL_RX_THRESHOLD_L1		((uint32_t)0x01000000)			/*!<Receive FIFO Threshold, Level 1 */
N#define SPI_FFCTL_RX_THRESHOLD_L2		((uint32_t)0x02000000)			/*!<Receive FIFO Threshold, Level 2 */
N#define SPI_FFCTL_RX_THRESHOLD_L3		((uint32_t)0x03000000)			/*!<Receive FIFO Threshold, Level 3 */
N#define SPI_FFCTL_RX_THRESHOLD_L4		((uint32_t)0x04000000)			/*!<Receive FIFO Threshold, Level 4 */
N#define SPI_FFCTL_RX_THRESHOLD_L5		((uint32_t)0x05000000)			/*!<Receive FIFO Threshold, Level 5 */
N#define SPI_FFCTL_RX_THRESHOLD_L6		((uint32_t)0x06000000)			/*!<Receive FIFO Threshold, Level 6 */
N#define SPI_FFCTL_RX_THRESHOLD_L7		((uint32_t)0x07000000)			/*!<Receive FIFO Threshold, Level 7 */
N#define SPI_FFCTL_RX_THRESHOLD_MASK		((uint32_t)0x07000000)			/*!<Receive FIFO Threshold */
N#define SPI_FFCTL_TX_THRESHOLD_L1		((uint32_t)0x10000000)			/*!<Transmit FIFO Threshold, Level 1 */
N#define SPI_FFCTL_TX_THRESHOLD_L2		((uint32_t)0x20000000)			/*!<Transmit FIFO Threshold, Level 2 */
N#define SPI_FFCTL_TX_THRESHOLD_L3		((uint32_t)0x30000000)			/*!<Transmit FIFO Threshold, Level 3 */
N#define SPI_FFCTL_TX_THRESHOLD_L4		((uint32_t)0x40000000)			/*!<Transmit FIFO Threshold, Level 4 */
N#define SPI_FFCTL_TX_THRESHOLD_L5		((uint32_t)0x50000000)			/*!<Transmit FIFO Threshold, Level 5 */
N#define SPI_FFCTL_TX_THRESHOLD_L6		((uint32_t)0x60000000)			/*!<Transmit FIFO Threshold, Level 6 */
N#define SPI_FFCTL_TX_THRESHOLD_L7		((uint32_t)0x70000000)			/*!<Transmit FIFO Threshold, Level 7 */
N#define SPI_FFCTL_TX_THRESHOLD_MASK		((uint32_t)0x70000000)			/*!<Transmit FIFO Threshold */
N
N
N
N/******************************************************************************/
N/*                PWM                                                         */
N/******************************************************************************/
N/********************* Bit definition of PRES register **********************/
N#define PWM_PRES_CP01_MASK			((uint32_t)0x000000FF)			/*!<Clock prescaler 0 for PWM Channel 0 & 1 */
N#define PWM_PRES_CP23_MASK			((uint32_t)0x0000FF00)			/*!<Clock prescaler 2 for PWM Channel 2 & 3 */
N#define PWM_PRES_DZ01_MASK			((uint32_t)0x00FF0000)			/*!<Dead zone interval register for pair of CH0 and CH1 */
N#define PWM_PRES_DZ23_MASK			((uint32_t)0xFF000000)			/*!<Dead zone interval register for pair of CH2 and CH3 */
N
N/********************* Bit definition of CLKSEL register **********************/
N#define PWM_CLKSEL_CLKSEL_DIV2		((uint32_t)0x00000000)			/*!<Input Clock Divided by 2 */
N#define PWM_CLKSEL_CLKSEL_DIV4		((uint32_t)0x00000001)			/*!<Input Clock Divided by 4 */
N#define PWM_CLKSEL_CLKSEL_DIV8		((uint32_t)0x00000002)			/*!<Input Clock Divided by 8 */
N#define PWM_CLKSEL_CLKSEL_DIV16		((uint32_t)0x00000003)			/*!<Input Clock Divided by 16 */
N#define PWM_CLKSEL_CLKSEL_DIV1		((uint32_t)0x00000004)			/*!<Input Clock Divided by 1 */
N#define PWM_CLKSEL_CLKSEL_MASK		((uint32_t)0x0000000F)			/*!<Clock Source Selection Mask */
N
N#define PWM_CLKSEL_CLKSEL0_DIV2		((uint32_t)0x00000000)			/*!<Channel 0 Input Clock Divided by 2 */
N#define PWM_CLKSEL_CLKSEL0_DIV4		((uint32_t)0x00000001)			/*!<Channel 0 Input Clock Divided by 4 */
N#define PWM_CLKSEL_CLKSEL0_DIV8		((uint32_t)0x00000002)			/*!<Channel 0 Input Clock Divided by 8 */
N#define PWM_CLKSEL_CLKSEL0_DIV16	((uint32_t)0x00000003)			/*!<Channel 0 Input Clock Divided by 16 */
N#define PWM_CLKSEL_CLKSEL0_DIV1		((uint32_t)0x00000004)			/*!<Channel 0 Input Clock Divided by 1 */
N#define PWM_CLKSEL_CLKSEL0_MASK		((uint32_t)0x0000000F)			/*!<Channel 0 Clock Source Selection Mask */
N#define PWM_CLKSEL_CLKSEL1_DIV2		((uint32_t)0x00000000)			/*!<Channel 1 Input Clock Divided by 2 */
N#define PWM_CLKSEL_CLKSEL1_DIV4		((uint32_t)0x00000010)			/*!<Channel 1 Input Clock Divided by 4 */
N#define PWM_CLKSEL_CLKSEL1_DIV8		((uint32_t)0x00000020)			/*!<Channel 1 Input Clock Divided by 8 */
N#define PWM_CLKSEL_CLKSEL1_DIV16	((uint32_t)0x00000030)			/*!<Channel 1 Input Clock Divided by 16 */
N#define PWM_CLKSEL_CLKSEL1_DIV1		((uint32_t)0x00000040)			/*!<Channel 1 Input Clock Divided by 1 */
N#define PWM_CLKSEL_CLKSEL1_MASK		((uint32_t)0x000000F0)			/*!<Channel 1 Clock Source Selection Mask  */
N#define PWM_CLKSEL_CLKSEL2_DIV2		((uint32_t)0x00000000)			/*!<Channel 2 Input Clock Divided by 2 */
N#define PWM_CLKSEL_CLKSEL2_DIV4		((uint32_t)0x00000100)			/*!<Channel 2 Input Clock Divided by 4 */
N#define PWM_CLKSEL_CLKSEL2_DIV8		((uint32_t)0x00000200)			/*!<Channel 2 Input Clock Divided by 8 */
N#define PWM_CLKSEL_CLKSEL2_DIV16	((uint32_t)0x00000300)			/*!<Channel 2 Input Clock Divided by 16 */
N#define PWM_CLKSEL_CLKSEL2_DIV1		((uint32_t)0x00000400)			/*!<Channel 2 Input Clock Divided by 1 */
N#define PWM_CLKSEL_CLKSEL2_MASK		((uint32_t)0x00000F00)			/*!<Channel 2 Clock Source Selection Mask  */
N#define PWM_CLKSEL_CLKSEL3_DIV2		((uint32_t)0x00000000)			/*!<Channel 3 Input Clock Divided by 2 */
N#define PWM_CLKSEL_CLKSEL3_DIV4		((uint32_t)0x00001000)			/*!<Channel 3 Input Clock Divided by 4 */
N#define PWM_CLKSEL_CLKSEL3_DIV8		((uint32_t)0x00002000)			/*!<Channel 3 Input Clock Divided by 8 */
N#define PWM_CLKSEL_CLKSEL3_DIV16	((uint32_t)0x00003000)			/*!<Channel 3 Input Clock Divided by 16 */
N#define PWM_CLKSEL_CLKSEL3_DIV1		((uint32_t)0x00004000)			/*!<Channel 3 Input Clock Divided by 1 */
N#define PWM_CLKSEL_CLKSEL3_MASK		((uint32_t)0x0000F000)			/*!<Channel 3 Clock Source Selection Mask  */
N
N/********************* Bit definition of CTL register **********************/
N#define PWM_CTL_CHMOD_AUTO_RELOAD		((uint32_t)0x00000008)			/*!<PWM Auto Reload Mode */
N#define PWM_CTL_CHMOD_ONE_SHOT			((uint32_t)0x00000000)			/*!<PWM One Shot Mode */
N
N
N#define PWM_CTL_CH0EN				((uint32_t)0x00000001)			/*!<PWM Channel 0 Enable/Disable Start Run */
N#define PWM_CTL_CH0INV				((uint32_t)0x00000004)			/*!<PWM Channel 0 Output Inverter ON/OFF */
N#define PWM_CTL_CH0MOD				((uint32_t)0x00000008)			/*!<PWM Channel 0 Continuous/One-Shot Mode */
N#define PWM_CTL_DZEN01				((uint32_t)0x00000010)			/*!<Dead Zone 0 Generator Enable/Disable */
N#define PWM_CTL_DZEN23				((uint32_t)0x00000020)			/*!<Dead Zone 2 Generator Enable/Disable */
N#define PWM_CTL_CH1EN				((uint32_t)0x00000100)			/*!<PWM Channel 1 Enable/Disable Start Run */
N#define PWM_CTL_CH1INV				((uint32_t)0x00000400)			/*!<PWM Channel 1 Output Inverter ON/OFF */
N#define PWM_CTL_CH1MOD				((uint32_t)0x00000800)			/*!<PWM Channel 1 Continuous/One-Shot Mode */
N#define PWM_CTL_CH2EN				((uint32_t)0x00010000)			/*!<PWM Channel 2 Enable/Disable Start Run */
N#define PWM_CTL_CH2INV				((uint32_t)0x00040000)			/*!<PWM Channel 2 Output Inverter ON/OFF */
N#define PWM_CTL_CH2MOD				((uint32_t)0x00080000)			/*!<PWM Channel 2 Continuous/One-Shot Mode */
N#define PWM_CTL_CH3EN				((uint32_t)0x01000000)			/*!<PWM Channel 3 Enable/Disable Start Run */
N#define PWM_CTL_CH3INV				((uint32_t)0x04000000)			/*!<PWM Channel 3 Output Inverter ON/OFF */
N#define PWM_CTL_CH3MOD				((uint32_t)0x08000000)			/*!<PWM Channel 3 Continuous/One-Shot Mode */
N
N/********************* Bit definition of INTEN register **********************/
N#define PWM_INTEN_TMIE0				((uint32_t)0x00000001)			/*!<PWM Channel 0 Interrupt Enable */
N#define PWM_INTEN_TMIE1				((uint32_t)0x00000002)			/*!<PWM Channel 1 Interrupt Enable */
N#define PWM_INTEN_TMIE2				((uint32_t)0x00000004)			/*!<PWM Channel 2 Interrupt Enable */
N#define PWM_INTEN_TMIE3				((uint32_t)0x00000008)			/*!<PWM Channel 3 Interrupt Enable */
N
N/********************* Bit definition of INTSTS register **********************/
N#define PWM_INTSTS_TMINT0			((uint32_t)0x00000001)			/*!<PWM Channel 0 Interrupt Flag */
N#define PWM_INTSTS_TMINT1			((uint32_t)0x00000002)			/*!<PWM Channel 1 Interrupt Flag */
N#define PWM_INTSTS_TMINT2			((uint32_t)0x00000004)			/*!<PWM Channel 2 Interrupt Flag */
N#define PWM_INTSTS_TMINT3			((uint32_t)0x00000008)			/*!<PWM Channel 3 Interrupt Flag */
N#define PWM_INTSTS_DUTY0SYNCFLAG	((uint32_t)0x00000010)			/*!<Duty0 Synchronize Flag */
N#define PWM_INTSTS_DUTY1SYNCFLAG	((uint32_t)0x00000020)			/*!<Duty1 Synchronize Flag */
N#define PWM_INTSTS_DUTY2SYNCFLAG	((uint32_t)0x00000040)			/*!<Duty2 Synchronize Flag */
N#define PWM_INTSTS_DUTY3SYNCFLAG	((uint32_t)0x00000080)			/*!<Duty3 Synchronize Flag */
N#define PWM_INTSTS_PRESSYNCFLAG		((uint32_t)0x00000100)			/*!<Prescale Synchronize Flag */
N
N/********************* Bit definition of OE register **********************/
N#define PWM_OE_CH0					((uint32_t)0x00000001)			/*!<PWM Channel 0 Output Enable */
N#define PWM_OE_CH1					((uint32_t)0x00000002)			/*!<PWM Channel 1 Output Enable */
N#define PWM_OE_CH2					((uint32_t)0x00000004)			/*!<PWM Channel 2 Output Enable */
N#define PWM_OE_CH3					((uint32_t)0x00000008)			/*!<PWM Channel 3 Output Enable */
N
N/********************* Bit definition of DUTY register **********************/
N#define PWM_DUTY_CN_MASK			((uint32_t)0x0000FFFF)			/*!<PWM Counter/Timer Loaded Value */
N#define PWM_DUTY_CM_MASK			((uint32_t)0xFFFF0000)			/*!<PWM Comparator Mask */
N
N/********************* Bit definition of CAPCTL register **********************/
N#define PWM_CAPCTL_PDMACAPMOD_CRL	((uint32_t)0x00000010)			/*!<PDMA Transfer CRL */
N#define PWM_CAPCTL_PDMACAPMOD_CFL	((uint32_t)0x00000020)			/*!<PDMA Transfer CFL*/
N#define PWM_CAPCTL_PDMACAPMOD_BOTH	((uint32_t)0x00000030)			/*!<PDMA Transfer Both CRL and CFL */
N#define PWM_CAPCTL_PDMACAPMOD_MASK	((uint32_t)0x00000030)			/*!<PDMA Transfer Mask*/
N
N#define PWM_CAPCTL_CAPRELOADREN		((uint32_t)0x00000040)			/*!<Reload CNR When Capture Rising Event Comes */
N#define PWM_CAPCTL_CAPRELOADFEN		((uint32_t)0x00000080)			/*!<Reload CNR When Capture Falling Event Comes */
N#define PWM_CAPCTL_CAPRELOAD_MASK	((uint32_t)0x000000C0)			/*!<Reload MASK When Capture Rising Event Comes */
N
N#define PWM_CAPCTL_CHRFORDER_R		((uint32_t)0x00001000)			/*!<Select CRL as First Captured Data PDMA Transferred */
N#define PWM_CAPCTL_CHRFORDER_F		((uint32_t)0x00000000)			/*!<Select CFL as First Captured Data PDMA Transferred */
N
N
N#define PWM_CAPCTL_INV0				((uint32_t)0x00000001)			/*!<Channel 0 Inverter ON/OFF */
N#define PWM_CAPCTL_CAPCH0EN			((uint32_t)0x00000002)			/*!<Capture Channel 0 Transition Enable/Disable */
N#define PWM_CAPCTL_CAPCH0PADEN		((uint32_t)0x00000004)			/*!<Capture Channel 0 Input Enable */
N#define PWM_CAPCTL_CH0PDMAEN		((uint32_t)0x00000008)			/*!<Channel 0 PDMA Enable */
N#define PWM_CAPCTL_PDMACAPMOD0_CRL0	((uint32_t)0x00000010)			/*!<PDMA Transfer CRL0 */
N#define PWM_CAPCTL_PDMACAPMOD0_CFL0	((uint32_t)0x00000020)			/*!<PDMA Transfer CFL0*/
N#define PWM_CAPCTL_PDMACAPMOD0_BOTH	((uint32_t)0x00000030)			/*!<PDMA Transfer Both CRL0 and CFL0 */
N#define PWM_CAPCTL_PDMACAPMOD0_MASK	((uint32_t)0x00000030)			/*!<PDMA Transfer Mask*/
N#define PWM_CAPCTL_CAPRELOADREN0	((uint32_t)0x00000040)			/*!<Reload CNR0 When CH0 Capture Rising Event Comes */
N#define PWM_CAPCTL_CAPRELOADFEN0	((uint32_t)0x00000080)			/*!<Reload CNR0 When CH0 Capture Falling Event Comes */
N#define PWM_CAPCTL_INV1				((uint32_t)0x00000100)			/*!<Channel 1 Inverter ON/OFF */
N#define PWM_CAPCTL_CAPCH1EN			((uint32_t)0x00000200)			/*!<Capture Channel 1 Transition Enable/Disable */
N#define PWM_CAPCTL_CAPCH1PADEN		((uint32_t)0x00000400)			/*!<Capture Channel 1 Input Enable */
N#define PWM_CAPCTL_CH0RFORDER		((uint32_t)0x00001000)			/*!<Select the First Captured Data PDMA Transferred */
N#define PWM_CAPCTL_CH01CASK			((uint32_t)0x00002000)			/*!<Cascade Channel 0 and Channel 1 PWM Timer for Capturing Usage */
N#define PWM_CAPCTL_CAPRELOADREN1	((uint32_t)0x00004000)			/*!<Reload CNR1 When CH1 Capture Rising Event Comes */
N#define PWM_CAPCTL_CAPRELOADFEN1	((uint32_t)0x00008000)			/*!<Reload CNR1 When CH1 Capture Falling Event Comes  */
N#define PWM_CAPCTL_INV2				((uint32_t)0x00010000)			/*!<Channel 2 Inverter ON/OFF */
N#define PWM_CAPCTL_CAPCH2EN			((uint32_t)0x00020000)			/*!<Capture Channel 2 Transition Enable/Disable */
N#define PWM_CAPCTL_CAPCH2PADEN		((uint32_t)0x00040000)			/*!<Capture Channel 2 Input Enable */
N#define PWM_CAPCTL_CH2PDMAEN		((uint32_t)0x00080000)			/*!<Channel 2 PDMA Enable */
N#define PWM_CAPCTL_PDMACAPMOD2_CRL2	((uint32_t)0x00100000)			/*!<PDMA Transfer CRL2 */
N#define PWM_CAPCTL_PDMACAPMOD2_CFL2	((uint32_t)0x00200000)			/*!<PDMA Transfer CFL2*/
N#define PWM_CAPCTL_PDMACAPMOD2_BOTH	((uint32_t)0x00300000)			/*!<PDMA Transfer Both CRL2 and CFL2 */
N#define PWM_CAPCTL_PDMACAPMOD2_MASK	((uint32_t)0x00300000)			/*!<PDMA Transfer Mask*/
N#define PWM_CAPCTL_CAPRELOADREN2	((uint32_t)0x00400000)			/*!<Reload CNR2 When CH2 Capture Rising Event Comes */
N#define PWM_CAPCTL_CAPRELOADFEN2	((uint32_t)0x00800000)			/*!<Reload CNR2 When CH2 Capture Falling Event Comes */
N#define PWM_CAPCTL_INV3				((uint32_t)0x01000000)			/*!<Channel 3 Inverter ON/OFF */
N#define PWM_CAPCTL_CAPCH3EN			((uint32_t)0x02000000)			/*!<Capture Channel 3 Transition Enable/Disable */
N#define PWM_CAPCTL_CAPCH3PADEN		((uint32_t)0x04000000)			/*!<Capture Channel 3 Input Enable */
N#define PWM_CAPCTL_CH3RFORDER		((uint32_t)0x10000000)			/*!<Select the First Captured Data PDMA Transferred */
N#define PWM_CAPCTL_CH23CASK			((uint32_t)0x20000000)			/*!<Cascade Channel 2 and Channel 3 PWM Timer for Capturing Usage */
N#define PWM_CAPCTL_CAPRELOADREN3	((uint32_t)0x40000000)			/*!<Reload CNR1 When CH3 Capture Rising Event Comes */
N#define PWM_CAPCTL_CAPRELOADFEN3	((uint32_t)0x80000000)			/*!<Reload CNR1 When CH3 capture Falling Event Comesg  */
N
N/********************* Bit definition of CAPINTEN register **********************/
N#define PWM_CAPINTEN_CRLIE			((uint32_t)0x00000001)			/*!<Rising Latch Interrupt Enable ON/OFF */
N#define PWM_CAPINTEN_CFLIE			((uint32_t)0x00000002)			/*!<Falling Latch Interrupt Enable ON/OFF */
N
N#define PWM_CAPINTEN_CRLIE0			((uint32_t)0x00000001)			/*!<Channel 0 Rising Latch Interrupt Enable ON/OFF */
N#define PWM_CAPINTEN_CFLIE0			((uint32_t)0x00000002)			/*!<Channel 0 Falling Latch Interrupt Enable ON/OFF */
N#define PWM_CAPINTEN_CRLIE1			((uint32_t)0x00000100)			/*!<Channel 1 Rising Latch Interrupt Enable ON/OFF */
N#define PWM_CAPINTEN_CFLIE1			((uint32_t)0x00000200)			/*!<Channel 1 Falling Latch Interrupt Enable ON/OFF */
N#define PWM_CAPINTEN_CRLIE2			((uint32_t)0x00010000)			/*!<Channel 2 Rising Latch Interrupt Enable ON/OFF */
N#define PWM_CAPINTEN_CFLIE2			((uint32_t)0x00020000)			/*!<Channel 2 Falling Latch Interrupt Enable ON/OFF */
N#define PWM_CAPINTEN_CRLIE3			((uint32_t)0x01000000)			/*!<Channel 3 Rising Latch Interrupt Enable ON/OFF */
N#define PWM_CAPINTEN_CFLIE3			((uint32_t)0x02000000)			/*!<Channel 3 Falling Latch Interrupt Enable ON/OFF */
N
N/********************* Bit definition of CAPINTSTS register **********************/
N#define PWM_CAPINTSTS_CRLI			((uint32_t)0x00000002)			/*!<PWM_CRL Latched Indicator Bit */
N#define PWM_CAPINTSTS_CFLI			((uint32_t)0x00000004)			/*!<PWM_CFL Latched Indicator Bit */
N
N#define PWM_CAPINTSTS_CAPIF0		((uint32_t)0x00000001)			/*!<Capture 0 Interrupt Indication Flag */
N#define PWM_CAPINTSTS_CRLI0			((uint32_t)0x00000002)			/*!<PWM_CRL0 Latched Indicator Bit */
N#define PWM_CAPINTSTS_CFLI0			((uint32_t)0x00000004)			/*!<PWM_CFL0 Latched Indicator Bit */
N#define PWM_CAPINTSTS_CAPOVR0		((uint32_t)0x00000008)			/*!<Capture Rising Flag over run for channel 0 */
N#define PWM_CAPINTSTS_CAPOVF0		((uint32_t)0x00000010)			/*!<Capture Falling Flag over run for channel 0 */
N#define PWM_CAPINTSTS_CAPIF1		((uint32_t)0x00000100)			/*!<Capture 1 Interrupt Indication Flag */
N#define PWM_CAPINTSTS_CRLI1			((uint32_t)0x00000200)			/*!<PWM_CRL1 Latched Indicator Bit */
N#define PWM_CAPINTSTS_CFLI1			((uint32_t)0x00000400)			/*!<PWM_CFL1 Latched Indicator Bit */
N#define PWM_CAPINTSTS_CAPOVR1		((uint32_t)0x00000800)			/*!<Capture Rising Flag over run for channel 1 */
N#define PWM_CAPINTSTS_CAPOVF1		((uint32_t)0x00001000)			/*!<Capture Falling Flag over run for channel 1 */
N#define PWM_CAPINTSTS_CAPIF2		((uint32_t)0x00010000)			/*!<Capture 2 Interrupt Indication Flag */
N#define PWM_CAPINTSTS_CRLI2			((uint32_t)0x00020000)			/*!<PWM_CRL2 Latched Indicator Bit */
N#define PWM_CAPINTSTS_CFLI2			((uint32_t)0x00040000)			/*!<PWM_CFL2 Latched Indicator Bit */
N#define PWM_CAPINTSTS_CAPOVR2		((uint32_t)0x00080000)			/*!<Capture Rising Flag over run for channel 2 */
N#define PWM_CAPINTSTS_CAPOVF2		((uint32_t)0x00100000)			/*!<Capture Falling Flag over run for channel 2 */
N#define PWM_CAPINTSTS_CAPIF3		((uint32_t)0x01000000)			/*!<Capture 3 Interrupt Indication Flag */
N#define PWM_CAPINTSTS_CRLI3			((uint32_t)0x02000000)			/*!<PWM_CRL3 Latched Indicator Bit */
N#define PWM_CAPINTSTS_CFLI3			((uint32_t)0x04000000)			/*!<PWM_CFL3 Latched Indicator Bit */
N#define PWM_CAPINTSTS_CAPOVR3		((uint32_t)0x08000000)			/*!<Capture Rising Flag over run for channel 3 */
N#define PWM_CAPINTSTS_CAPOVF3		((uint32_t)0x10000000)			/*!<Capture Falling Flag over run for channel 3 */
N
N
N
N
N/******************************************************************************/
N/*                UART                                                        */
N/******************************************************************************/
N/********************* Bit definition of CTL register **********************/
N#define UART_CTL_RX_RST				((uint32_t)0x00000001)			/*!<RX Software Reset */
N#define UART_CTL_TX_RST				((uint32_t)0x00000002)			/*!<TX Software Reset */
N#define UART_CTL_RX_DIS				((uint32_t)0x00000004)			/*!<Receiver Disable Register */
N#define UART_CTL_TX_DIS				((uint32_t)0x00000008)			/*!<Transfer Disable Register */
N#define UART_CTL_AUTO_RTS_EN		((uint32_t)0x00000010)			/*!<RTS Auto-Flow Control Enable */
N#define UART_CTL_AUTO_CTS_EN		((uint32_t)0x00000020)			/*!<CTS Auto-Flow Control Enable */
N#define UART_CTL_DMA_RX_EN			((uint32_t)0x00000040)			/*!<RX DMA Enable */
N#define UART_CTL_DMA_TX_EN			((uint32_t)0x00000080)			/*!<TX DMA Enable */
N#define UART_CTL_WAKE_CTS_EN		((uint32_t)0x00000100)			/*!<CTS Wake-Up Function Enable */
N#define UART_CTL_ABAUD_EN			((uint32_t)0x00001000)			/*!<Auto-Baud Rate Detect Enable */
N/********************* Bit definition of TLCTL register **********************/
N#define UART_TLCTL_DATA_LEN			((uint32_t)0x00000003)			/*!<Data Length */
N#define UART_TLCTL_NSB				((uint32_t)0x00000004)			/*!<Number of STOP Bit Length */
N#define UART_TLCTL_PBE				((uint32_t)0x00000008)			/*!<Parity Bit Enable */
N#define UART_TLCTL_EPE				((uint32_t)0x00000010)			/*!<Even Parity Enable */
N#define UART_TLCTL_SPE				((uint32_t)0x00000020)			/*!<Stick Parity Enable */
N#define UART_TLCTL_BCB				((uint32_t)0x00000040)			/*!<Break Control Bit */
N#define UART_TLCTL_RFITL			((uint32_t)0x00000300)			/*!<RX-FIFO Interrupt (INT_RDA) Trigger Level */
N#define UART_TLCTL_RTS_TRI_LEV		((uint32_t)0x00003000)			/*!<RTSn Trigger Level (For Auto-flow Control Use) */
N/********************* Bit definition of IER register **********************/
N#define UART_IER_RDA_IE				((uint32_t)0x00000001)			/*!<Receive Data Available Interrupt Enable */
N#define UART_IER_THRE_IE			((uint32_t)0x00000002)			/*!<Transmit Holding Register Empty Interrupt Enable */
N#define UART_IER_RLS_IE				((uint32_t)0x00000004)			/*!<Receive Line Status Interrupt Enable */
N#define UART_IER_MODEM_IE			((uint32_t)0x00000008)			/*!<Modem Status Interrupt Enable */
N#define UART_IER_RTO_IE				((uint32_t)0x00000010)			/*!<RX Time-Out Interrupt Enable */
N#define UART_IER_BUF_ERR_IE			((uint32_t)0x00000020)			/*!<Buffer Error Interrupt Enable */
N#define UART_IER_WAKE_IE			((uint32_t)0x00000040)			/*!<Wake-Up Interrupt Enable */
N#define UART_IER_ABAUD_IE			((uint32_t)0x00000080)			/*!<Auto-Baud Rate Interrupt Enable */
N#define UART_IER_LIN_IE				((uint32_t)0x00000100)			/*!<LIN Interrupt Enable */
N/********************* Bit definition of ISR register **********************/
N#define UART_ISR_RDA_IS				((uint32_t)0x00000001)			/*!<Receive Data Available Interrupt Flag (Read Only) */
N#define UART_ISR_THRE_IS			((uint32_t)0x00000002)			/*!<Transmit Holding Register Empty Interrupt Flag (Read Only) */
N#define UART_ISR_RLS_IS				((uint32_t)0x00000004)			/*!<Receive Line Interrupt Status Flag (Read Only) */
N#define UART_ISR_MODEM_IS			((uint32_t)0x00000008)			/*!<MODEM Interrupt Status Flag (Read Only) */
N#define UART_ISR_RTO_IS				((uint32_t)0x00000010)			/*!<RX Time-Out Interrupt Status Flag (Read Only) */
N#define UART_ISR_BUF_ERR_IS			((uint32_t)0x00000020)			/*!<Buffer Error Interrupt Status Flag (Read Only) */
N#define UART_ISR_WAKE_IS			((uint32_t)0x00000040)			/*!<Wake-Up Interrupt Status Flag (Read Only) */
N#define UART_ISR_ABAUD_IS			((uint32_t)0x00000080)			/*!<Auto-Baud Rate Interrupt Status Flag (Read Only) */
N#define UART_ISR_LIN_IS				((uint32_t)0x00000100)			/*!<LIN Interrupt Status Flag (Read Only) */
N/********************* Bit definition of TRSR register **********************/
N#define UART_TRSR_RS485_ADDET_F		((uint32_t)0x00000001)			/*!<RS-485 Address Byte Detection Status Flag (Read Only) */
N#define UART_TRSR_ABAUD_F			((uint32_t)0x00000002)			/*!<Auto-Baud Rate Interrupt (Read Only) */
N#define UART_TRSR_ABAUD_TOUT_F		((uint32_t)0x00000004)			/*!<Auto-Baud Rate Time-Out Interrupt (Read Only) */
N#define UART_TRSR_LIN_TX_F			((uint32_t)0x00000008)			/*!<LIN TX Interrupt Flag (Read Only) */
N#define UART_TRSR_LIN_RX_F			((uint32_t)0x00000010)			/*!<LIN RX Interrupt Flag (Read Only) */
N#define UART_TRSR_BIT_ERR_F			((uint32_t)0x00000020)			/*!<Bit Error Detect Status Flag (Read Only) */
N#define UART_TRSR_LIN_RX_SYNC_ERR_F	((uint32_t)0x00000100)			/*!<LIN RX SYNC Error Flag (Read Only) */
N/********************* Bit definition of FSR register **********************/
N#define UART_FSR_RX_OVER_F			((uint32_t)0x00000001)			/*!<RX Overflow Error Status Flag (Read Only) */
N#define UART_FSR_RX_EMPTY_F			((uint32_t)0x00000002)			/*!<Receiver FIFO Empty (Read Only) */
N#define UART_FSR_RX_FULL_F			((uint32_t)0x00000004)			/*!<Receiver FIFO Full (Read Only) */
N#define UART_FSR_PE_F				((uint32_t)0x00000010)			/*!<Parity Error State Status Flag (Read Only) */
N#define UART_FSR_FE_F				((uint32_t)0x00000020)			/*!<Framing Error Status Flag (Read Only) */
N#define UART_FSR_BI_F				((uint32_t)0x00000040)			/*!<Break Status Flag (Read Only) */
N#define UART_FSR_TX_OVER_F			((uint32_t)0x00000100)			/*!<TX Overflow Error Interrupt Status Flag (Read Only) */
N#define UART_FSR_TX_EMPTY_F			((uint32_t)0x00000200)			/*!<Transmitter FIFO Empty  (Read Only) */
N#define UART_FSR_TX_FULL_F			((uint32_t)0x00000400)			/*!<Transmitter FIFO Full  (Read Only) */
N#define UART_FSR_TE_F				((uint32_t)0x00000800)			/*!<Transmitter Empty Status Flag (Read Only) */
N#define UART_FSR_RX_POINTER_F		((uint32_t)0x001F0000)			/*!<RX-FIFO Pointer (Read Only) */
N#define UART_FSR_TX_POINTER_F		((uint32_t)0x1F000000)			/*!<TX-FIFO Pointer (Read Only) */
N/********************* Bit definition of MCSR register **********************/
N#define UART_MCSR_LEV_RTS			((uint32_t)0x00000001)			/*!<RTS Trigger Level */
N#define UART_MCSR_RTS_ST			((uint32_t)0x00000002)			/*!<RTS Pin State (Read Only) */
N#define UART_MCSR_LEV_CTS			((uint32_t)0x00010000)			/*!<CTS Trigger Level */
N#define UART_MCSR_CTS_ST			((uint32_t)0x00020000)			/*!<CTS Pin Status (Read Only) */
N#define UART_MCSR_DCT_F				((uint32_t)0x00040000)			/*!<Detect CTS State Change Status Flag (Read Only) */
N/********************* Bit definition of TMCTL register **********************/
N#define UART_TMCTL_TOIC				((uint32_t)0x000001FF)			/*!<Time-Out Comparator */
N#define UART_TMCTL_DLY				((uint32_t)0x00FF0000)			/*!<TX Delay Time Value */
N/********************* Bit definition of BAUD register **********************/
N#define UART_BAUD_BRD				((uint32_t)0x0000FFFF)			/*!<Baud Rate Divider */
N#define UART_BAUD_DIV_16_EN			((uint32_t)0x80000000)			/*!<Divider 16 Enable */
N/********************* Bit definition of IRCR register **********************/
N#define UART_IRCR_TX_SELECT			((uint32_t)0x00000002)			/*!<TX_SELECT */
N#define UART_IRCR_INV_TX			((uint32_t)0x00000020)			/*!<Inverse TX output signal */
N#define UART_IRCR_INV_RX			((uint32_t)0x00000040)			/*!<Inverse RX input signal */
N/********************* Bit definition of ALT_CTL register **********************/
N#define UART_ALT_CTL_LIN_TX_BCNT	((uint32_t)0x00000007)			/*!<LIN TX Break Field Count Register */
N#define UART_ALT_CTL_LIN_HEAD_SEL	((uint32_t)0x00000030)			/*!<LIN Header Selection */
N#define UART_ALT_CTL_LIN_RX_EN		((uint32_t)0x00000040)			/*!<LIN RX Enable */
N#define UART_ALT_CTL_LIN_TX_EN		((uint32_t)0x00000080)			/*!<LIN TX Header Trigger Enable */
N#define UART_ALT_CTL_BIT_ERR_EN		((uint32_t)0x00000100)			/*!<Bit Error Detect Enable */
N#define UART_ALT_CTL_RS485_NMM		((uint32_t)0x00010000)			/*!<RS-485 Normal Multi-Drop Operation Mode (RS-485 NMM Mode) */
N#define UART_ALT_CTL_RS485_AAD		((uint32_t)0x00020000)			/*!<RS-485 Auto Address Detection Operation Mode (RS-485 AAD Mode) */
N#define UART_ALT_CTL_RS485_AUD		((uint32_t)0x00040000)			/*!<RS-485 Auto Direction Mode (RS-485 AUD Mode) */
N#define UART_ALT_CTL_RS485_ADD_EN	((uint32_t)0x00080000)			/*!<RS-485 Address Detection Enable */
N#define UART_ALT_CTL_ADDR_PID_MATCH	((uint32_t)0xFF000000)			/*!<Address / PID Match Value Register */
N/********************* Bit definition of FUN_SEL register **********************/
N#define UART_FUN_SEL_FUN_SEL		((uint32_t)0x00000003)			/*!<Function Select Enable */
N
N
N/******************************************************************************/
N/*                USB                                                         */
N/******************************************************************************/
N/********************* Bit definition of CTRL register **********************/
N#define USB_CTRL_USB_EN				((uint32_t)0x00000001)			/*!<USB Function Enable */
N#define USB_CTRL_PHY_EN				((uint32_t)0x00000002)			/*!<PHY Transceiver Enable */
N#define USB_CTRL_PWRDB				((uint32_t)0x00000004)			/*!<Power down PHY Transceiver, Low Active */
N#define USB_CTRL_DPPU_EN			((uint32_t)0x00000008)			/*!<Pull-Up Resistor on USB_DP Enable */
N#define USB_CTRL_DRVSE0				((uint32_t)0x00000010)			/*!<Force USB PHY Transceiver to Drive SE0 */
N#define USB_CTRL_RWAKEUP			((uint32_t)0x00000100)			/*!<Force USB bus to K state, used for remote wake-up */
N#define USB_CTRL_WAKEUP_EN			((uint32_t)0x00000200)			/*!<Wake-Up Function Enable */
N
N/********************* Bit definition of BUSSTS register **********************/
N#define USB_BUSSTS_USBRST			((uint32_t)0x00000001)			/*!<USB Reset Status */
N#define USB_BUSSTS_SUSPEND			((uint32_t)0x00000002)			/*!<USB Suspend Status */
N#define USB_BUSSTS_RESUME			((uint32_t)0x00000004)			/*!<USB Resume Status */
N#define USB_BUSSTS_TIMEOUT			((uint32_t)0x00000008)			/*!<USB Time Out Flag */
N#define USB_BUSSTS_FLDET_IN			((uint32_t)0x00000010)			/*!<USB Device Floating Detection - plug-in */
N#define USB_BUSSTS_FLDET_OUT		((uint32_t)0x00000000)			/*!<USB Device Floating Detection - plug-out */
N
N/********************* Bit definition of INTEN register **********************/
N#define USB_INTEN_BUSEVT			((uint32_t)0x00000001)			/*!<USB Bus Event Interrupt Enable */
N#define USB_INTEN_USBEVT			((uint32_t)0x00000002)			/*!<USB Event Interrupt Enable */
N#define USB_INTEN_FLDET				((uint32_t)0x00000004)			/*!<USB Floating Detect Interrupt Enable */
N#define USB_INTEN_WAKEUP			((uint32_t)0x00000008)			/*!<USB Wake-up Interrupt Enable */
N
N/********************* Bit definition of INTSTS register **********************/
N#define USB_INTSTS_BUS_STS			((uint32_t)0x00000001)			/*!<USB BUS Interrupt Status */
N#define USB_INTSTS_USB_STS			((uint32_t)0x00000002)			/*!<USB USB Interrupt Status */
N#define USB_INTSTS_FLD_STS			((uint32_t)0x00000004)			/*!<USB Floating Interrupt Status */
N#define USB_INTSTS_WKEUP_STS		((uint32_t)0x00000008)			/*!<USB Wake-up Interrupt Status */
N#define USB_INTSTS_EPEVT0			((uint32_t)0x00010000)			/*!<USB Event Status on EP0 */
N#define USB_INTSTS_EPEVT1			((uint32_t)0x00020000)			/*!<USB Event Status on EP1 */
N#define USB_INTSTS_EPEVT2			((uint32_t)0x00040000)			/*!<USB Event Status on EP2 */
N#define USB_INTSTS_EPEVT3			((uint32_t)0x00080000)			/*!<USB Event Status on EP3 */
N#define USB_INTSTS_EPEVT4			((uint32_t)0x00100000)			/*!<USB Event Status on EP4 */
N#define USB_INTSTS_EPEVT5			((uint32_t)0x00200000)			/*!<USB Event Status on EP5 */
N#define USB_INTSTS_EPEVT6			((uint32_t)0x00400000)			/*!<USB Event Status on EP6 */
N#define USB_INTSTS_EPEVT7			((uint32_t)0x00800000)			/*!<USB Event Status on EP7 */
N#define USB_INTSTS_SETUP			((uint32_t)0x80000000)			/*!<USB Setup Event Status */
N
N/********************* Bit definition of DADDR register **********************/
N#define USB_DADDR_MASK				((uint32_t)0x0000007F)			/*!<USB devices function address Mask */
N
N/********************* Bit definition of EPSTS register **********************/
N#define USB_EPSTS_EPSTS0_INACK		((uint32_t)0x00000100)			/*!<USB Endpoint 0 Bus Status - In Ack */
N#define USB_EPSTS_EPSTS0_OUTD0ACK	((uint32_t)0x00000200)			/*!<USB Endpoint 0 Bus Status - Out Data0 Ack */
N#define USB_EPSTS_EPSTS0_OUTD1ACK	((uint32_t)0x00000600)			/*!<USB Endpoint 0 Bus Status - Out Data1 Ack */
N#define USB_EPSTS_EPSTS0_SETUPACK	((uint32_t)0x00000300)			/*!<USB Endpoint 0 Bus Status - Setup Ack */
N#define USB_EPSTS_EPSTS0_ISOEND		((uint32_t)0x00000700)			/*!<USB Endpoint 0 Bus Status - Isochronous transfer end */
N
N#define USB_EPSTS_EPSTS1_INACK		((uint32_t)0x00001000)			/*!<USB Endpoint 1 Bus Status - In Ack */
N#define USB_EPSTS_EPSTS1_OUTD0ACK	((uint32_t)0x00002000)			/*!<USB Endpoint 1 Bus Status - Out Data0 Ack */
N#define USB_EPSTS_EPSTS1_OUTD1ACK	((uint32_t)0x00006000)			/*!<USB Endpoint 1 Bus Status - Out Data1 Ack */
N#define USB_EPSTS_EPSTS1_SETUPACK	((uint32_t)0x00003000)			/*!<USB Endpoint 1 Bus Status - Setup Ack */
N#define USB_EPSTS_EPSTS1_ISOEND		((uint32_t)0x00007000)			/*!<USB Endpoint 1 Bus Status - Isochronous transfer end */
N
N#define USB_EPSTS_EPSTS2_INACK		((uint32_t)0x00010000)			/*!<USB Endpoint 2 Bus Status - In Ack */
N#define USB_EPSTS_EPSTS2_OUTD0ACK	((uint32_t)0x00020000)			/*!<USB Endpoint 2 Bus Status - Out Data0 Ack */
N#define USB_EPSTS_EPSTS2_OUTD1ACK	((uint32_t)0x00060000)			/*!<USB Endpoint 2 Bus Status - Out Data1 Ack */
N#define USB_EPSTS_EPSTS2_SETUPACK	((uint32_t)0x00030000)			/*!<USB Endpoint 2 Bus Status - Setup Ack */
N#define USB_EPSTS_EPSTS2_ISOEND		((uint32_t)0x00070000)			/*!<USB Endpoint 2 Bus Status - Isochronous transfer end */
N
N#define USB_EPSTS_EPSTS3_INACK		((uint32_t)0x00100000)			/*!<USB Endpoint 3 Bus Status - In Ack */
N#define USB_EPSTS_EPSTS3_OUTD0ACK	((uint32_t)0x00200000)			/*!<USB Endpoint 3 Bus Status - Out Data0 Ack */
N#define USB_EPSTS_EPSTS3_OUTD1ACK	((uint32_t)0x00600000)			/*!<USB Endpoint 3 Bus Status - Out Data1 Ack */
N#define USB_EPSTS_EPSTS3_SETUPACK	((uint32_t)0x00300000)			/*!<USB Endpoint 3 Bus Status - Setup Ack */
N#define USB_EPSTS_EPSTS3_ISOEND		((uint32_t)0x00700000)			/*!<USB Endpoint 3 Bus Status - Isochronous transfer end */
N
N#define USB_EPSTS_EPSTS4_INACK		((uint32_t)0x01000000)			/*!<USB Endpoint 4 Bus Status - In Ack */
N#define USB_EPSTS_EPSTS4_OUTD0ACK	((uint32_t)0x02000000)			/*!<USB Endpoint 4 Bus Status - Out Data0 Ack */
N#define USB_EPSTS_EPSTS4_OUTD1ACK	((uint32_t)0x06000000)			/*!<USB Endpoint 4 Bus Status - Out Data1 Ack */
N#define USB_EPSTS_EPSTS4_SETUPACK	((uint32_t)0x03000000)			/*!<USB Endpoint 4 Bus Status - Setup Ack */
N#define USB_EPSTS_EPSTS4_ISOEND		((uint32_t)0x07000000)			/*!<USB Endpoint 4 Bus Status - Isochronous transfer end */
N
N#define USB_EPSTS_EPSTS5_INACK		((uint32_t)0x10000000)			/*!<USB Endpoint 5 Bus Status - In Ack */
N#define USB_EPSTS_EPSTS5_OUTD0ACK	((uint32_t)0x20000000)			/*!<USB Endpoint 5 Bus Status - Out Data0 Ack */
N#define USB_EPSTS_EPSTS5_OUTD1ACK	((uint32_t)0x60000000)			/*!<USB Endpoint 5 Bus Status - Out Data1 Ack */
N#define USB_EPSTS_EPSTS5_SETUPACK	((uint32_t)0x30000000)			/*!<USB Endpoint 5 Bus Status - Setup Ack */
N#define USB_EPSTS_EPSTS5_ISOEND		((uint32_t)0x70000000)			/*!<USB Endpoint 5 Bus Status - Isochronous transfer end */
N
N/********************* Bit definition of EPSTS2 register **********************/
N#define USB_EPSTS_EPSTS6_INACK		((uint32_t)0x00000001)			/*!<USB Endpoint 6 Bus Status - In Ack */
N#define USB_EPSTS_EPSTS6_OUTD0ACK	((uint32_t)0x00000002)			/*!<USB Endpoint 6 Bus Status - Out Data0 Ack */
N#define USB_EPSTS_EPSTS6_OUTD1ACK	((uint32_t)0x00000006)			/*!<USB Endpoint 6 Bus Status - Out Data1 Ack */
N#define USB_EPSTS_EPSTS6_SETUPACK	((uint32_t)0x00000003)			/*!<USB Endpoint 6 Bus Status - Setup Ack */
N#define USB_EPSTS_EPSTS6_ISOEND		((uint32_t)0x00000007)			/*!<USB Endpoint 6 Bus Status - Isochronous transfer end */
N
N#define USB_EPSTS_EPSTS7_INACK		((uint32_t)0x00000010)			/*!<USB Endpoint 7 Bus Status - In Ack */
N#define USB_EPSTS_EPSTS7_OUTD0ACK	((uint32_t)0x00000020)			/*!<USB Endpoint 7 Bus Status - Out Data0 Ack */
N#define USB_EPSTS_EPSTS7_OUTD1ACK	((uint32_t)0x00000060)			/*!<USB Endpoint 7 Bus Status - Out Data1 Ack */
N#define USB_EPSTS_EPSTS7_SETUPACK	((uint32_t)0x00000030)			/*!<USB Endpoint 7 Bus Status - Setup Ack */
N#define USB_EPSTS_EPSTS7_ISOEND		((uint32_t)0x00000070)			/*!<USB Endpoint 7 Bus Status - Isochronous transfer end */
N
N
N/********************* Bit definition of CFG register **********************/
N#define USB_CFG_EPNUM_MASK			((uint32_t)0x0000000F)			/*!<USB Endpoint Number Mask */
N#define USB_CFG_ISOCH				((uint32_t)0x00000010)			/*!<USB Isochronous Endpoint */
N#define USB_CFG_EPMODE_DISABLE		((uint32_t)0x00000000)			/*!<USB Endpoint is disabled */
N#define USB_CFG_EPMODE_OUT			((uint32_t)0x00000020)			/*!<USB Out endpoint */
N#define USB_CFG_EPMODE_IN			((uint32_t)0x00000040)			/*!<USB In endpoint */
N#define USB_CFG_DSQ_SYNC_DATA0		((uint32_t)0x00000000)			/*!<USB Data Sequence Synchronization - Data0 */
N#define USB_CFG_DSQ_SYNC_DATA1		((uint32_t)0x00000080)			/*!<USB Data Sequence Synchronization - Data1 */
N#define USB_CFG_CSTALL				((uint32_t)0x00000100)			/*!<Clear the device to response STALL handshake in setup stage */
N#define USB_CFG_SSTALL				((uint32_t)0x00000200)			/*!<Set the device to respond STALL automatically */
N
N/********************* Bit definition of PDMA register **********************/
N#define USB_PDMA_MEM2USB			((uint32_t)0x00000000)			/*!<The PDMA will read data from memory to USB buffer */
N#define USB_PDMA_USB2MEM			((uint32_t)0x00000001)			/*!<The PDMA will read data from USB buffer to memory */
N#define USB_PDMA_PDMA_TRG			((uint32_t)0x00000002)			/*!<Active PDMA Function */
N#define USB_PDMA_BYTEM_BYTE			((uint32_t)0x00000004)			/*!<CPU access USB SRAM Size Mode Select - Byte mode */
N#define USB_PDMA_BYTEM_WORD			((uint32_t)0x00000000)			/*!<CPU access USB SRAM Size Mode Select - Word mode */
N#define USB_PDMA_PDMA_RST			((uint32_t)0x00000008)			/*!<PDMA Reset */
N
N
N/******************************************************************************/
N/*                DAC                                                         */
N/******************************************************************************/
N/********************* Bit definition of CTL register **********************/
N#define DAC_CTL_EN					((uint32_t)0x00000001)			/*!<DAC Enable */
N#define DAC_CTL_IE					((uint32_t)0x00000002)			/*!<DAC Interrupt Enable */
N#define DAC_CTL_LSEL_DATA_WRITE		((uint32_t)0x00000000)			/*!<DAC Loads on DACx_DAT Write */
N#define DAC_CTL_LSEL_PDMA			((uint32_t)0x00000010)			/*!<DAC Loads on PDMa ACK */
N#define DAC_CTL_LSEL_TIMER0_CH0		((uint32_t)0x00000020)			/*!<DAC Loads on Timer0 Ch0 Event */
N#define DAC_CTL_LSEL_TIMER0_CH1		((uint32_t)0x00000030)			/*!<DAC Loads on Timer0 Ch1 Event */
N#define DAC_CTL_LSEL_TIMER1_CH0		((uint32_t)0x00000040)			/*!<DAC Loads on Timer1 Ch0 Event */
N#define DAC_CTL_LSEL_TIMER1_CH1		((uint32_t)0x00000050)			/*!<DAC Loads on Timer1 Ch1 Event */
N#define DAC_CTL_LSEL_MASK			((uint32_t)0x000000F0)			/*!<DAC Load Select Mask */
N#define DAC_CTL_PWONSTBCNT_MASK		((uint32_t)0x003FFF00)			/*!<DAC Power on Stable Count Mask */
N
N/********************* Bit definition of DATA register **********************/
N#define DAC_DATA_DATA_MASK			((uint32_t)0x00000FFF)			/*!<DAC Data Mask */
N
N/********************* Bit definition of STS register **********************/
N#define DAC_STS_IFG					((uint32_t)0x00000001)			/*!<DAC Interrupt Flag */
N#define DAC_STS_STFG				((uint32_t)0x00000002)			/*!<DAC Start Flag */
N#define DAC_STS_BUSY  				((uint32_t)0x00000004)			/*!<DAC Loads Busy Bit */
N
N/********************* Bit definition of COMCTL register **********************/
N#define DAC_COMCTL_WAITDACCONV_MASK	((uint32_t)0x000000FF)			/*!<Wait DAC Conversion Complete Count */
N#define DAC_COMCTL_GRP				((uint32_t)0x00000100)			/*!<Group DAC0 and DAC1 */
N#define DAC_COMCTL_REFSEL_AVDD		((uint32_t)0x00000000)			/*!<AVDDReference Voltage */
N#define DAC_COMCTL_REFSEL_INT_VREF	((uint32_t)0x00000200)			/*!<Internal VREF as Reference Voltage */
N#define DAC_COMCTL_REFSEL_VREF		((uint32_t)0x00000400)			/*!<VREF as Reference Voltage */
N#define DAC_COMCTL_REFSEL_MASK		((uint32_t)0x00000600)			/*!<Reference Voltage Selection Mask */
N
N
N
N/******************************************************************************/
N/*                LCD                                                         */
N/******************************************************************************/
N/********************* Bit definition of CTL register **********************/
N#define LCD_CTL_EN					((uint32_t)0x00000001)			/*!<LCD Enable */
N#define LCD_CTL_MUX					((uint32_t)0x0000000E)			/*!<Mux select */
N#define LCD_CTL_FREQ 				((uint32_t)0x00000070)			/*!<LCD Frequency Selection */
N#define LCD_CTL_BLINK				((uint32_t)0x00000080)			/*!<LCD Blinking Enable */
N#define LCD_CTL_PDDISP_EN			((uint32_t)0x00000100)			/*!<Power Down Display Enable */
N#define LCD_CTL_PDINT_EN			((uint32_t)0x00000200)			/*!<Power Down Interrupt Enable */
N/********************* Bit definition of DISPCTL register **********************/
N#define LCD_DISPCTL_CPUMP_EN		((uint32_t)0x00000001)			/*!<Charge Pump Enable */
N#define LCD_DISPCTL_BIAS_SEL		((uint32_t)0x00000006)			/*!<Bias Selection */
N#define LCD_DISPCTL_IBRL_EN			((uint32_t)0x00000010)			/*!<Internal bias reference ladder enable */
N#define LCD_DISPCTL_BV_SEL			((uint32_t)0x00000040)			/*!<Bias Voltage type select */
N#define LCD_DISPCTL_CPUMP_VOL_SET	((uint32_t)0x00000700)			/*!<Charge Pump Voltage select */
N#define LCD_DISPCTL_CPUMP_FREQ		((uint32_t)0x00003800)			/*!<Charge Pump Frequency select */
N/********************* Bit definition of MEM_0 register **********************/
N#define LCD_MEM_0_SEG_0				((uint32_t)0x0000003F)			/*!<SEG0 DATA for COM */
N#define LCD_MEM_0_SEG_1				((uint32_t)0x00003F00)			/*!<SEG1 DATA for COM */
N#define LCD_MEM_0_SEG_2				((uint32_t)0x003F0000)			/*!<SEG2 DATA for COM */
N#define LCD_MEM_0_SEG_3				((uint32_t)0x3F000000)			/*!<SEG3 DATA for COM */
N/********************* Bit definition of MEM_1 register **********************/
N#define LCD_MEM_1_SEG_4				((uint32_t)0x0000003F)			/*!<SEG4 DATA for COM */
N#define LCD_MEM_1_SEG_5				((uint32_t)0x00003F00)			/*!<SEG5 DATA for COM */
N#define LCD_MEM_1_SEG_6				((uint32_t)0x003F0000)			/*!<SEG6 DATA for COM */
N#define LCD_MEM_1_SEG_7				((uint32_t)0x3F000000)			/*!<SEG7 DATA for COM */
N/********************* Bit definition of MEM_2 register **********************/
N#define LCD_MEM_2_SEG_8				((uint32_t)0x0000003F)			/*!<SEG8 DATA for COM */
N#define LCD_MEM_2_SEG_9				((uint32_t)0x00003F00)			/*!<SEG9 DATA for COM */
N#define LCD_MEM_2_SEG_10			((uint32_t)0x003F0000)			/*!<SEG10 DATA for COM */
N#define LCD_MEM_2_SEG_11			((uint32_t)0x3F000000)			/*!<SEG11 DATA for COM */
N/********************* Bit definition of MEM_3 register **********************/
N#define LCD_MEM_3_SEG_12			((uint32_t)0x0000003F)			/*!<SEG12 DATA for COM */
N#define LCD_MEM_3_SEG_13			((uint32_t)0x00003F00)			/*!<SEG13 DATA for COM */
N#define LCD_MEM_3_SEG_14			((uint32_t)0x003F0000)			/*!<SEG14 DATA for COM */
N#define LCD_MEM_3_SEG_15			((uint32_t)0x3F000000)			/*!<SEG15 DATA for COM */
N/********************* Bit definition of MEM_4 register **********************/
N#define LCD_MEM_4_SEG_16			((uint32_t)0x0000003F)			/*!<SEG16 DATA for COM */
N#define LCD_MEM_4_SEG_17			((uint32_t)0x00003F00)			/*!<SEG17 DATA for COM */
N#define LCD_MEM_4_SEG_18			((uint32_t)0x003F0000)			/*!<SEG18 DATA for COM */
N#define LCD_MEM_4_SEG_19			((uint32_t)0x3F000000)			/*!<SEG19 DATA for COM */
N/********************* Bit definition of MEM_5 register **********************/
N#define LCD_MEM_5_SEG_20			((uint32_t)0x0000003F)			/*!<SEG20 DATA for COM */
N#define LCD_MEM_5_SEG_21			((uint32_t)0x00003F00)			/*!<SEG21 DATA for COM */
N#define LCD_MEM_5_SEG_22			((uint32_t)0x003F0000)			/*!<SEG22 DATA for COM */
N#define LCD_MEM_5_SEG_23			((uint32_t)0x3F000000)			/*!<SEG23 DATA for COM */
N/********************* Bit definition of MEM_6 register **********************/
N#define LCD_MEM_6_SEG_24			((uint32_t)0x0000003F)			/*!<SEG24 DATA for COM */
N#define LCD_MEM_6_SEG_25			((uint32_t)0x00003F00)			/*!<SEG25 DATA for COM */
N#define LCD_MEM_6_SEG_26			((uint32_t)0x003F0000)			/*!<SEG26 DATA for COM */
N#define LCD_MEM_6_SEG_27			((uint32_t)0x3F000000)			/*!<SEG27 DATA for COM */
N/********************* Bit definition of MEM_7 register **********************/
N#define LCD_MEM_7_SEG_28			((uint32_t)0x0000003F)			/*!<SEG28 DATA for COM */
N#define LCD_MEM_7_SEG_29			((uint32_t)0x00003F00)			/*!<SEG29 DATA for COM */
N#define LCD_MEM_7_SEG_30			((uint32_t)0x003F0000)			/*!<SEG30 DATA for COM */
N#define LCD_MEM_7_SEG_31			((uint32_t)0x3F000000)			/*!<SEG31 DATA for COM */
N/********************* Bit definition of MEM_8 register **********************/
N#define LCD_MEM_8_SEG_32			((uint32_t)0x0000003F)			/*!<SEG32 DATA for COM */
N#define LCD_MEM_8_SEG_33			((uint32_t)0x00003F00)			/*!<SEG33 DATA for COM */
N#define LCD_MEM_8_SEG_34			((uint32_t)0x003F0000)			/*!<SEG34 DATA for COM */
N#define LCD_MEM_8_SEG_35			((uint32_t)0x3F000000)			/*!<SEG35 DATA for COM */
N/********************* Bit definition of MEM_9 register **********************/
N#define LCD_MEM_9_SEG_36			((uint32_t)0x0000003F)			/*!<SEG36 DATA for COM */
N#define LCD_MEM_9_SEG_37			((uint32_t)0x00003F00)			/*!<SEG37 DATA for COM */
N#define LCD_MEM_9_SEG_38			((uint32_t)0x003F0000)			/*!<SEG38 DATA for COM */
N#define LCD_MEM_9_SEG_39			((uint32_t)0x3F000000)			/*!<SEG39 DATA for COM */
N/********************* Bit definition of FCR register **********************/
N#define LCD_FCR_FCEN				((uint32_t)0x00000001)			/*!<LCD Frame Counter Enable */
N#define LCD_FCR_FCINTEN				((uint32_t)0x00000002)			/*!<LCD Frame Counter Interrupt Enable */
N#define LCD_FCR_PRESCL				((uint32_t)0x0000000C)			/*!<Frame Counter Pre-scaler Value */
N#define LCD_FCR_FCV					((uint32_t)0x000003F0)			/*!<Frame Counter Top Value */
N/********************* Bit definition of FCSTS register **********************/
N#define LCD_FCSTS_FCSTS				((uint32_t)0x00000001)			/*!<LCD Frame Counter Status */
N#define LCD_FCSTS_PDSTS				((uint32_t)0x00000002)			/*!<Power-down Interrupt Status */
N
N
N/******************************************************************************/
N/*                TK                                                          */
N/******************************************************************************/
N/********************* Bit definition of CTL1 register **********************/
N#define TK_CTL1_SEL_TK8_0			((uint32_t)0x00000001)			/*!<TK8/TK0 Scan Select */
N#define TK_CTL1_SEL_TK9_1			((uint32_t)0x00000002)			/*!<TK9/TK1 Scan Select */
N#define TK_CTL1_SEL_TK10_2			((uint32_t)0x00000004)			/*!<TK10/TK2 Scan Select */
N#define TK_CTL1_SEL_TK11_3			((uint32_t)0x00000008)			/*!<TK11/TK3 Scan Select */
N#define TK_CTL1_SEL_TK12_4			((uint32_t)0x00000010)			/*!<TK12/TK4 Scan Select */
N#define TK_CTL1_SEL_TK13_5			((uint32_t)0x00000020)			/*!<TK13/TK5 Scan Select */
N#define TK_CTL1_SEL_TK14_6			((uint32_t)0x00000040)			/*!<TK14/TK6 Scan Select */
N#define TK_CTL1_SEL_TK15_7			((uint32_t)0x00000080)			/*!<TK15/TK7 Scan Select */
N#define TK_CTL1_EN_TK8_0			((uint32_t)0x00000100)			/*!<TK8/TK0 Scan Enable */
N#define TK_CTL1_EN_TK9_1			((uint32_t)0x00000200)			/*!<TK9/TK1 Scan Enable */
N#define TK_CTL1_EN_TK10_2			((uint32_t)0x00000400)			/*!<TK10/TK2 Scan Enable */
N#define TK_CTL1_EN_TK11_3			((uint32_t)0x00000800)			/*!<TK11/TK3 Scan Enable */
N#define TK_CTL1_EN_TK12_4			((uint32_t)0x00001000)			/*!<TK12/TK4 Scan Enable */
N#define TK_CTL1_EN_TK13_5			((uint32_t)0x00002000)			/*!<TK13/TK5 Scan Enable */
N#define TK_CTL1_EN_TK14_6			((uint32_t)0x00004000)			/*!<TK14/TK6 Scan Enable */
N#define TK_CTL1_EN_TK15_7			((uint32_t)0x00008000)			/*!<TK15/TK7 Scan Enable */
N#define TK_CTL1_START_BY_SW			((uint32_t)0x00010000)			/*!<Start Scan By Software */
N#define TK_CTL1_START_BY_TMR		((uint32_t)0x00020000)			/*!<Start Scan By Timer Enable */
N#define TK_CTL1_SEN_SEL_10BIT		((uint32_t)0x00000000)			/*!<Touch Key 10 Bit Sensitivity */
N#define TK_CTL1_SEN_SEL_12BIT		((uint32_t)0x20000000)			/*!<Touch Key 12 Bit Sensitivity */
N#define TK_CTL1_SEN_SEL_14BIT		((uint32_t)0x40000000)			/*!<Touch Key 14 Bit Sensitivity */
N#define TK_CTL1_SEN_SEL_16BIT		((uint32_t)0x60000000)			/*!<Touch Key 16 Bit Sensitivity */
N#define TK_CTL1_SEN_SEL_MASK		((uint32_t)0x60000000)			/*!<Touch Key Sensitivity Mask */
N#define TK_CTL1_EN					((uint32_t)0x80000000)			/*!<Touch Key Scan Enable Bit */
N
N/********************* Bit definition of CTL2 register **********************/
N#define TK_CTL2_TK8_0_CLKDIV_MASK	((uint32_t)0x0000000F)			/*!<TK8/TK0 Time-Base Clock Frequency Select Mask */
N#define TK_CTL2_TK8_0_CURCTL_MASK	((uint32_t)0x000000F0)			/*!<TK8/TK0 Charge/Discharge Current Control Mask*/
N#define TK_CTL2_TK9_1_CLKDIV_MASK	((uint32_t)0x00000F00)			/*!<TK9/TK1 Time-Base Clock Frequency Select Mask */
N#define TK_CTL2_TK9_1_CURCTL_MASK	((uint32_t)0x0000F000)			/*!<TK9/TK1 Charge/Discharge Current Control Mask */
N#define TK_CTL2_TK10_2_CLKDIV_MASK	((uint32_t)0x000F0000)			/*!<TK10/TK2 Time-Base Clock Frequency Select Mask */
N#define TK_CTL2_TK10_2_CURCTL_MASK	((uint32_t)0x00F00000)			/*!<TK10/TK2 Charge/Discharge Current Control Mask */
N#define TK_CTL2_TK11_3_CLKDIV_MASK	((uint32_t)0x0F000000)			/*!<TK11/TK3 Time-Base Clock Frequency Select Mask */
N#define TK_CTL2_TK11_3_CURCTL_MASK	((uint32_t)0xF0000000)			/*!<TK11/TK3 Charge/Discharge Current Control Mask */
N
N/********************* Bit definition of CTL3 register **********************/
N#define TK_CTL3_TK12_4_CLKDIV_MASK	((uint32_t)0x0000000F)			/*!<TK12/TK4 Time-Base Clock Frequency Select Mask */
N#define TK_CTL3_TK12_4_CURCTL_MASK	((uint32_t)0x000000F0)			/*!<TK12/TK4 Charge/Discharge Current Control Mask*/
N#define TK_CTL3_TK13_5_CLKDIV_MASK	((uint32_t)0x00000F00)			/*!<TK13/TK5 Time-Base Clock Frequency Select Mask */
N#define TK_CTL3_TK13_5_CURCTL_MASK	((uint32_t)0x0000F000)			/*!<TK13/TK5 Charge/Discharge Current Control Mask */
N#define TK_CTL3_TK14_6_CLKDIV_MASK	((uint32_t)0x000F0000)			/*!<TK14/TK6 Time-Base Clock Frequency Select Mask */
N#define TK_CTL3_TK14_6_CURCTL_MASK	((uint32_t)0x00F00000)			/*!<TK14/TK6 Charge/Discharge Current Control Mask */
N#define TK_CTL3_TK15_7_CLKDIV_MASK	((uint32_t)0x0F000000)			/*!<TK15/TK7 Time-Base Clock Frequency Select Mask */
N#define TK_CTL3_TK15_7_CURCTL_MASK	((uint32_t)0xF0000000)			/*!<TK15/TK7 Charge/Discharge Current Control Mask */
N
N/********************* Bit definition of STAT register **********************/
N#define TK_STAT_BUSY				((uint32_t)0x00000001)			/*!<Touch Key Busy */
N#define TK_STAT_COMPLETE			((uint32_t)0x00000002)			/*!<Touch Key Scan Complete */
N#define TK_STAT_SEN_MATCH_LEVEL_MASK	((uint32_t)0x000000F0)		/*!<Sensitivity Match Level Mask */
N#define TK_STAT_TK8_0_SEN_FAIL		((uint32_t)0x00000100)			/*!<TK8/TK0 Sensing Fail */
N#define TK_STAT_TK9_1_SEN_FAIL		((uint32_t)0x00000200)			/*!<TK9/TK1 Sensing Fail */
N#define TK_STAT_TK10_2_SEN_FAIL		((uint32_t)0x00000400)			/*!<TK10/TK2 Sensing Fail */
N#define TK_STAT_TK11_3_SEN_FAIL		((uint32_t)0x00000800)			/*!<TK11/TK3 Sensing Fail */
N#define TK_STAT_TK12_4_SEN_FAIL		((uint32_t)0x00001000)			/*!<TK12/TK4 Sensing Fail */
N#define TK_STAT_TK13_5_SEN_FAIL		((uint32_t)0x00002000)			/*!<TK13/TK5 Sensing Fail */
N#define TK_STAT_TK14_6_SEN_FAIL		((uint32_t)0x00004000)			/*!<TK14/TK6 Sensing Fail */
N#define TK_STAT_TK15_7_SEN_FAIL		((uint32_t)0x00008000)			/*!<TK15/TK7 Sensing Fail */
N#define TK_STAT_TK8_0_THC_INT		((uint32_t)0x00010000)			/*!<TK8/TK0 Threshold Control Status */
N#define TK_STAT_TK9_1_THC_INT		((uint32_t)0x00020000)			/*!<TK9/TK1 Threshold Control Status */
N#define TK_STAT_TK10_2_THC_INT		((uint32_t)0x00040000)			/*!<TK10/TK2 Threshold Control Status */
N#define TK_STAT_TK11_3_THC_INT		((uint32_t)0x00080000)			/*!<TK11/TK3 Threshold Control Status */
N#define TK_STAT_TK12_4_THC_INT		((uint32_t)0x00100000)			/*!<TK12/TK4 Threshold Control Status */
N#define TK_STAT_TK13_5_THC_INT		((uint32_t)0x00200000)			/*!<TK13/TK5 Threshold Control Status */
N#define TK_STAT_TK14_6_THC_INT		((uint32_t)0x00400000)			/*!<TK14/TK6 Threshold Control Status */
N#define TK_STAT_TK15_7_THC_INT		((uint32_t)0x00800000)			/*!<TK15/TK7 Threshold Control Status */
N
N/********************* Bit definition of DATA1 register **********************/
N#define TK_DATA1_TK8_0_DATA			((uint32_t)0x0000FFFF)			/*!<TK8/TK0 Sensing Result Data Mask */
N#define TK_DATA1_TK9_1_DATA			((uint32_t)0xFFFF0000)			/*!<TK9/TK1 Sensing Result Data Mask */
N
N/********************* Bit definition of DATA2 register **********************/
N#define TK_DATA2_TK10_2_DATA		((uint32_t)0x0000FFFF)			/*!<TK10/TK2 Sensing Result Data Mask */
N#define TK_DATA2_TK11_3_DATA		((uint32_t)0xFFFF0000)			/*!<TK11/TK3 Sensing Result Data Mask */
N
N/********************* Bit definition of DATA3 register **********************/
N#define TK_DATA3_TK12_4_DATA		((uint32_t)0x0000FFFF)			/*!<TK12/TK4 Sensing Result Data Mask */
N#define TK_DATA3_TK13_5_DATA		((uint32_t)0xFFFF0000)			/*!<TK13/TK5 Sensing Result Data Mask */
N
N/********************* Bit definition of DATA4 register **********************/
N#define TK_DATA4_TK14_6_DATA		((uint32_t)0x0000FFFF)			/*!<TK14/TK6 Sensing Result Data Mask */
N#define TK_DATA4_TK15_7_DATA		((uint32_t)0xFFFF0000)			/*!<TK15/TK7 Sensing Result Data Mask */
N
N/********************* Bit definition of INTEN register **********************/
N#define TK_INTEN_SCAN_THC			((uint32_t)0x00000001)			/*!<Touch Key Scan Complete with Threshold Interrupt Enable */
N#define TK_INTEN_SCAN_COMPLETE		((uint32_t)0x00000002)			/*!<Touch Key Scan Complete Interrupt Enable */
N#define TK_INTEN_SEN_FAIL			((uint32_t)0x00000004)			/*!<Touch Key Sensing Fail Interrupt Enable */
N
N/********************* Bit definition of THC register **********************/
N#define TK_THC_LOW_MASK				((uint32_t)0x0000FFFF)			/*!<Low Threshold Control Data */
N#define TK_THC_HIGH_MASK			((uint32_t)0xFFFF0000)			/*!<High Threshold Control Data */
N
N
N/******************************************************************************/
N/*                ADC                                                         */
N/******************************************************************************/
N/********************* Bit definition of RESULT register **********************/
N#define ADC_RESULT_RSLT_MASK		((uint32_t)0x00000FFF)			/*!<A/D Conversion Result Mask */
N#define ADC_RESULT_VALID			((uint32_t)0x00010000)			/*!<Data Valid Flag */
N#define ADC_RESULT_OVERRUN			((uint32_t)0x00020000)			/*!<Over Run Flag */
N
N/********************* Bit definition of CR register **********************/
N#define ADC_CR_ADEN					((uint32_t)0x00000001)			/*!<A/D Converter Enable */
N#define ADC_CR_ADIE					((uint32_t)0x00000002)			/*!<A/D Interrupt Enable */
N#define ADC_CR_ADMD_SINGEL			((uint32_t)0x00000000)			/*!<A/D Converter Single Mode */
N#define ADC_CR_ADMD_S_CYCLE			((uint32_t)0x00000008)			/*!<A/D Converter Single Cycle Mode */
N#define ADC_CR_ADMD_CONTINUOUS		((uint32_t)0x0000000C)			/*!<A/D Converter Continuous Mode */
N#define ADC_CR_ADMD_MASK			((uint32_t)0x0000000C)			/*!<A/D Converter Operation Mode Mask */
N#define ADC_CR_TRGCOND_L_LEV		((uint32_t)0x00000000)			/*!<External Low Level Trigger */
N#define ADC_CR_TRGCOND_H_LEV		((uint32_t)0x00000040)			/*!<External High Level Trigger */
N#define ADC_CR_TRGCOND_F_EDGE		((uint32_t)0x00000080)			/*!<External Falling Edge Trigger */
N#define ADC_CR_TRGCOND_R_EDGE		((uint32_t)0x000000C0)			/*!<External Rising Edge Trigger */
N#define ADC_CR_TRGCOND_MASK			((uint32_t)0x000000C0)			/*!<External Trigger Condition Mask */
N#define ADC_CR_TRGEN				((uint32_t)0x00000100)			/*!<External Trigger Enable */
N#define ADC_CR_PTEN					((uint32_t)0x00000200)			/*!<PDMA Transfer Enable */
N#define ADC_CR_DIFF					((uint32_t)0x00000400)			/*!<Differential mode select */
N#define ADC_CR_SINGLE_END				((uint32_t)0x00000000)			/*!<Single end mode select */
N#define ADC_CR_ADST					((uint32_t)0x00000800)			/*!<A/D Conversion Start */
N#define ADC_CR_TMSEL_TMR0_CH0		((uint32_t)0x00000000)			/*!<Select TMR0 CH0 as A/D Trigger Source */
N#define ADC_CR_TMSEL_TMR0_CH1		((uint32_t)0x00001000)			/*!<Select TMR0 CH1 as A/D Trigger Source */
N#define ADC_CR_TMSEL_TMR1_CH0		((uint32_t)0x00002000)			/*!<Select TMR1 CH0 as A/D Trigger Source */
N#define ADC_CR_TMSEL_TMR1_CH1		((uint32_t)0x00003000)			/*!<Select TMR1 CH1 as A/D Trigger Source */
N#define ADC_CR_TMSEL_MASK			((uint32_t)0x00003000)			/*!<Timer Trigger Source Mask */
N#define ADC_CR_TMTRGMOD				((uint32_t)0x00008000)			/*!<Timer Event Trigger ADC Conversion */
N#define ADC_CR_REFSEL_AVDD			((uint32_t)0x00000000)			/*!<AVDD as Reference */
N#define ADC_CR_REFSEL_INT_REF		((uint32_t)0x00010000)			/*!<INT VREF as Reference */
N#define ADC_CR_REFSEL_VREF			((uint32_t)0x00020000)			/*!<VREF as Reference */
N#define ADC_CR_REFSEL_MASK			((uint32_t)0x00030000)			/*!<Reference Voltage Source Selection Mask*/
N#define ADC_CR_RESSEL_6BIT			((uint32_t)0x00000000)			/*!<ADC 6 Bit Resolution */
N#define ADC_CR_RESSEL_8BIT			((uint32_t)0x00040000)			/*!<ADC 8 Bit Resolution */
N#define ADC_CR_RESSEL_10BIT			((uint32_t)0x00080000)			/*!<ADC 10 Bit Resolution */
N#define ADC_CR_RESSEL_12BIT			((uint32_t)0x000C0000)			/*!<ADC 12 Bit Resolution */
N#define ADC_CR_RESSEL_MASK			((uint32_t)0x000C0000)			/*!<Resolution Selection Mask */
N#define ADC_CR_TMPDMACNT_MASK		((uint32_t)0xFF000000)			/*!<PDMA Count Mask */
N
N/********************* Bit definition of CHER register **********************/
N#define ADC_CHER_CHEN_0				((uint32_t)0x00000001)			/*!<Analog Input Channel 0 Enable (PA.0) */
N#define ADC_CHER_CHEN_1				((uint32_t)0x00000002)			/*!<Analog Input Channel 1 Enable (PA.1) */
N#define ADC_CHER_CHEN_2				((uint32_t)0x00000004)			/*!<Analog Input Channel 2 Enable (PA.2) */
N#define ADC_CHER_CHEN_3				((uint32_t)0x00000008)			/*!<Analog Input Channel 3 Enable (PA.3) */
N#define ADC_CHER_CHEN_4				((uint32_t)0x00000010)			/*!<Analog Input Channel 4 Enable (PA.4) */
N#define ADC_CHER_CHEN_5				((uint32_t)0x00000020)			/*!<Analog Input Channel 5 Enable (PA.5) */
N#define ADC_CHER_CHEN_6				((uint32_t)0x00000040)			/*!<Analog Input Channel 6 Enable (PA.6) */
N#define ADC_CHER_CHEN_7				((uint32_t)0x00000080)			/*!<Analog Input Channel 7 Enable (PA.7) */
N#define ADC_CHER_CHEN_8				((uint32_t)0x00000100)			/*!<Analog Input Channel 8 Enable (PD.0) */
N#define ADC_CHER_CHEN_9				((uint32_t)0x00000200)			/*!<Analog Input Channel 9 Enable (PD.1) */
N#define ADC_CHER_CHEN_10			((uint32_t)0x00000400)			/*!<Analog Input Channel 10 Enable (PD.2) */
N#define ADC_CHER_CHEN_11			((uint32_t)0x00000800)			/*!<Analog Input Channel 11 Enable (PD.3) */
N#define ADC_CHER_CHEN_12			((uint32_t)0x00001000)			/*!<Analog Input Channel 12 Enable (DAC0) */
N#define ADC_CHER_CHEN_13			((uint32_t)0x00002000)			/*!<Analog Input Channel 13 Enable (DAC1) */
N#define ADC_CHER_CHEN_14			((uint32_t)0x00004000)			/*!<Analog Input Channel 14 Enable (VTEMP) */
N#define ADC_CHER_CHEN_15			((uint32_t)0x00008000)			/*!<Analog Input Channel 15 Enable (Int_VREF) */
N#define ADC_CHER_CHEN_16			((uint32_t)0x00010000)			/*!<Analog Input Channel 16 Enable (AVDD) */
N#define ADC_CHER_CHEN_17			((uint32_t)0x00020000)			/*!<Analog Input Channel 17 Enable (AVSS) */
N
N/********************* Bit definition of CMPR register **********************/
N#define ADC_CMPR_CMPEN				((uint32_t)0x00000001)			/*!<Compare Enable */
N#define ADC_CMPR_CMPIE				((uint32_t)0x00000002)			/*!<Compare Interrupt Enable */
N#define ADC_CMPR_CMPCOND_GE			((uint32_t)0x00000004)			/*!<Compare Condition Greater or Equal To*/
N#define ADC_CMPR_CMPCOND_LT			((uint32_t)0x00000000)			/*!<Compare Condition Less Than*/
N#define ADC_CMPR_CMPCH_MASK			((uint32_t)0x000000F8)			/*!<Compare Channel Selection Mask */
N#define ADC_CMPR_CMPMATCNT_MASK		((uint32_t)0x00000F00)			/*!<Compare Match Count Mask */
N#define ADC_CMPR_CMPD_DATA_MASK			((uint32_t)0x0FFF0000)			/*!<Comparison Data Mask */
N
N/********************* Bit definition of SR register **********************/
N#define ADC_SR_ADF					((uint32_t)0x00000001)			/*!<A/D Conversion End Flag */
N#define ADC_SR_CMPF0				((uint32_t)0x00000002)			/*!<Compare Complete Flag 0 */
N#define ADC_SR_CMPF1				((uint32_t)0x00000004)			/*!<Compare Complete Flag 1 */
N#define ADC_SR_BUSY					((uint32_t)0x00000008)			/*!<Busy/Idle State */
N#define ADC_SR_CHANNEL_MASK			((uint32_t)0x000001F0)			/*!<Current Conversion Channel Mask */
N#define ADC_SR_INITRDY				((uint32_t)0x00010000)			/*!<ADC Power Up Sequence Is Complete */
N
N/********************* Bit definition of PDMA register **********************/
N#define ADC_SR_PDMA_DATA_MASK	((uint32_t)0x00000FFF)				/*!<ADC PDMA Current Transfer Data Register Mask */
N
N/********************* Bit definition of PWRCTL register **********************/
N#define ADC_PWRCTL_PUPRDY			((uint32_t)0x00000001)			/*!<ADC Power Up Sequence Is Completed and Ready for Conversion */
N#define ADC_PWRCTL_PWDCALEN			((uint32_t)0x00000002)			/*!<Power Up Calibration Function Enable */
N#define ADC_PWRCTL_PWDCALDIS			((uint32_t)0x00000000)			/*!<Power Up Calibration Function Disable */
N#define ADC_PWRCTL_PWDMOD_PD		((uint32_t)0x00000000)			/*!<Power Down Mode */
N#define ADC_PWRCTL_PWDMOD_STBY		((uint32_t)0x00000008)			/*!<Stand By Mode */
N
N/********************* Bit definition of CALEN register **********************/
N#define ADC_CALCTL_CALEN			((uint32_t)0x00000001)			/*!<Enable Calibraion Function  */
N#define ADC_CALCTL_CALSTART			((uint32_t)0x00000002)			/*!<Start Calibration Functional Blcok */
N#define ADC_CALCTL_CALDONE			((uint32_t)0x00000004)			/*!<Calibrate Functional Block Complete */
N#define ADC_CALCTL_CALSEL			((uint32_t)0x00000008)			/*!<Select Calibration Functional Block */
N#define ADC_CALCTL_LOAD				((uint32_t)0x00000000)			/*!<Select Laod Calibration Word */
N
N/********************* Bit definition of CALWORD register **********************/
N#define ADC_CALWORD_WORD_MASK		((uint32_t)0x0000003F)			/*!<Calibration Word Mask */
N
N/********************* Bit definition of SMPLCNT0 register **********************/
N#define ADC_SMPLCNT_0CLK		((uint32_t)0x00000000)			/*!<Sampling Count 0 Clock */
N#define ADC_SMPLCNT_1CLK		((uint32_t)0x00000001)			/*!<Sampling Count 1 Clock */
N#define ADC_SMPLCNT_2CLK		((uint32_t)0x00000002)			/*!<Sampling Count 2 Clock */
N#define ADC_SMPLCNT_4CLK		((uint32_t)0x00000003)			/*!<Sampling Count 4 Clock */
N#define ADC_SMPLCNT_8CLK		((uint32_t)0x00000004)			/*!<Sampling Count 8 Clock */
N#define ADC_SMPLCNT_16CLK		((uint32_t)0x00000005)			/*!<Sampling Count 16 Clock */
N#define ADC_SMPLCNT_32CLK		((uint32_t)0x00000006)			/*!<Sampling Count 32 Clock */
N#define ADC_SMPLCNT_64CLK		((uint32_t)0x00000007)			/*!<Sampling Count 64 Clock */
N#define ADC_SMPLCNT_128CLK		((uint32_t)0x00000008)			/*!<Sampling Count 128 Clock */
N#define ADC_SMPLCNT_256CLK		((uint32_t)0x00000009)			/*!<Sampling Count 256 Clock */
N#define ADC_SMPLCNT_512CLK		((uint32_t)0x0000000A)			/*!<Sampling Count 512 Clock */
N#define ADC_SMPLCNT_1024CLK		((uint32_t)0x0000000B)			/*!<Sampling Count 1024 Clock */
N#define ADC_SMPLCNT_Mask		((uint32_t)0x0000000F)			/*!<Sampling Count Mask */
N#define ADC_SMPLCNT0_CH0_0CLK		((uint32_t)0x00000000)			/*!<Channel 0 Sampling Count 0 Clock */
N#define ADC_SMPLCNT0_CH0_1CLK		((uint32_t)0x00000001)			/*!<Channel 0 Sampling Count 1 Clock */
N#define ADC_SMPLCNT0_CH0_2CLK		((uint32_t)0x00000002)			/*!<Channel 0 Sampling Count 2 Clock */
N#define ADC_SMPLCNT0_CH0_4CLK		((uint32_t)0x00000003)			/*!<Channel 0 Sampling Count 4 Clock */
N#define ADC_SMPLCNT0_CH0_8CLK		((uint32_t)0x00000004)			/*!<Channel 0 Sampling Count 8 Clock */
N#define ADC_SMPLCNT0_CH0_16CLK		((uint32_t)0x00000005)			/*!<Channel 0 Sampling Count 16 Clock */
N#define ADC_SMPLCNT0_CH0_32CLK		((uint32_t)0x00000006)			/*!<Channel 0 Sampling Count 32 Clock */
N#define ADC_SMPLCNT0_CH0_64CLK		((uint32_t)0x00000007)			/*!<Channel 0 Sampling Count 64 Clock */
N#define ADC_SMPLCNT0_CH0_128CLK		((uint32_t)0x00000008)			/*!<Channel 0 Sampling Count 128 Clock */
N#define ADC_SMPLCNT0_CH0_256CLK		((uint32_t)0x00000009)			/*!<Channel 0 Sampling Count 256 Clock */
N#define ADC_SMPLCNT0_CH0_512CLK		((uint32_t)0x0000000A)			/*!<Channel 0 Sampling Count 512 Clock */
N#define ADC_SMPLCNT0_CH0_1024CLK	((uint32_t)0x0000000B)			/*!<Channel 0 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT0_CH1_0CLK		((uint32_t)0x00000000)			/*!<Channel 1 Sampling Count 0 Clock */
N#define ADC_SMPLCNT0_CH1_1CLK		((uint32_t)0x00000010)			/*!<Channel 1 Sampling Count 1 Clock */
N#define ADC_SMPLCNT0_CH1_2CLK		((uint32_t)0x00000020)			/*!<Channel 1 Sampling Count 2 Clock */
N#define ADC_SMPLCNT0_CH1_4CLK		((uint32_t)0x00000030)			/*!<Channel 1 Sampling Count 4 Clock */
N#define ADC_SMPLCNT0_CH1_8CLK		((uint32_t)0x00000040)			/*!<Channel 1 Sampling Count 8 Clock */
N#define ADC_SMPLCNT0_CH1_16CLK		((uint32_t)0x00000050)			/*!<Channel 1 Sampling Count 16 Clock */
N#define ADC_SMPLCNT0_CH1_32CLK		((uint32_t)0x00000060)			/*!<Channel 1 Sampling Count 32 Clock */
N#define ADC_SMPLCNT0_CH1_64CLK		((uint32_t)0x00000070)			/*!<Channel 1 Sampling Count 64 Clock */
N#define ADC_SMPLCNT0_CH1_128CLK		((uint32_t)0x00000080)			/*!<Channel 1 Sampling Count 128 Clock */
N#define ADC_SMPLCNT0_CH1_256CLK		((uint32_t)0x00000090)			/*!<Channel 1 Sampling Count 256 Clock */
N#define ADC_SMPLCNT0_CH1_512CLK		((uint32_t)0x000000A0)			/*!<Channel 1 Sampling Count 512 Clock */
N#define ADC_SMPLCNT0_CH1_1024CLK	((uint32_t)0x000000B0)			/*!<Channel 1 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT0_CH2_0CLK		((uint32_t)0x00000000)			/*!<Channel 2 Sampling Count 0 Clock */
N#define ADC_SMPLCNT0_CH2_1CLK		((uint32_t)0x00000100)			/*!<Channel 2 Sampling Count 1 Clock */
N#define ADC_SMPLCNT0_CH2_2CLK		((uint32_t)0x00000200)			/*!<Channel 2 Sampling Count 2 Clock */
N#define ADC_SMPLCNT0_CH2_4CLK		((uint32_t)0x00000300)			/*!<Channel 2 Sampling Count 4 Clock */
N#define ADC_SMPLCNT0_CH2_8CLK		((uint32_t)0x00000400)			/*!<Channel 2 Sampling Count 8 Clock */
N#define ADC_SMPLCNT0_CH2_16CLK		((uint32_t)0x00000500)			/*!<Channel 2 Sampling Count 16 Clock */
N#define ADC_SMPLCNT0_CH2_32CLK		((uint32_t)0x00000600)			/*!<Channel 2 Sampling Count 32 Clock */
N#define ADC_SMPLCNT0_CH2_64CLK		((uint32_t)0x00000700)			/*!<Channel 2 Sampling Count 64 Clock */
N#define ADC_SMPLCNT0_CH2_128CLK		((uint32_t)0x00000800)			/*!<Channel 2 Sampling Count 128 Clock */
N#define ADC_SMPLCNT0_CH2_256CLK		((uint32_t)0x00000900)			/*!<Channel 2 Sampling Count 256 Clock */
N#define ADC_SMPLCNT0_CH2_512CLK		((uint32_t)0x00000A00)			/*!<Channel 2 Sampling Count 512 Clock */
N#define ADC_SMPLCNT0_CH2_1024CLK	((uint32_t)0x00000B00)			/*!<Channel 2 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT0_CH3_0CLK		((uint32_t)0x00000000)			/*!<Channel 3 Sampling Count 0 Clock */
N#define ADC_SMPLCNT0_CH3_1CLK		((uint32_t)0x00001000)			/*!<Channel 3 Sampling Count 1 Clock */
N#define ADC_SMPLCNT0_CH3_2CLK		((uint32_t)0x00002000)			/*!<Channel 3 Sampling Count 2 Clock */
N#define ADC_SMPLCNT0_CH3_4CLK		((uint32_t)0x00003000)			/*!<Channel 3 Sampling Count 4 Clock */
N#define ADC_SMPLCNT0_CH3_8CLK		((uint32_t)0x00004000)			/*!<Channel 3 Sampling Count 8 Clock */
N#define ADC_SMPLCNT0_CH3_16CLK		((uint32_t)0x00005000)			/*!<Channel 3 Sampling Count 16 Clock */
N#define ADC_SMPLCNT0_CH3_32CLK		((uint32_t)0x00006000)			/*!<Channel 3 Sampling Count 32 Clock */
N#define ADC_SMPLCNT0_CH3_64CLK		((uint32_t)0x00007000)			/*!<Channel 3 Sampling Count 64 Clock */
N#define ADC_SMPLCNT0_CH3_128CLK		((uint32_t)0x00008000)			/*!<Channel 3 Sampling Count 128 Clock */
N#define ADC_SMPLCNT0_CH3_256CLK		((uint32_t)0x00009000)			/*!<Channel 3 Sampling Count 256 Clock */
N#define ADC_SMPLCNT0_CH3_512CLK		((uint32_t)0x0000A000)			/*!<Channel 3 Sampling Count 512 Clock */
N#define ADC_SMPLCNT0_CH3_1024CLK	((uint32_t)0x0000B000)			/*!<Channel 3 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT0_CH4_0CLK		((uint32_t)0x00000000)			/*!<Channel 4 Sampling Count 0 Clock */
N#define ADC_SMPLCNT0_CH4_1CLK		((uint32_t)0x00010000)			/*!<Channel 4 Sampling Count 1 Clock */
N#define ADC_SMPLCNT0_CH4_2CLK		((uint32_t)0x00020000)			/*!<Channel 4 Sampling Count 2 Clock */
N#define ADC_SMPLCNT0_CH4_4CLK		((uint32_t)0x00030000)			/*!<Channel 4 Sampling Count 4 Clock */
N#define ADC_SMPLCNT0_CH4_8CLK		((uint32_t)0x00040000)			/*!<Channel 4 Sampling Count 8 Clock */
N#define ADC_SMPLCNT0_CH4_16CLK		((uint32_t)0x00050000)			/*!<Channel 4 Sampling Count 16 Clock */
N#define ADC_SMPLCNT0_CH4_32CLK		((uint32_t)0x00060000)			/*!<Channel 4 Sampling Count 32 Clock */
N#define ADC_SMPLCNT0_CH4_64CLK		((uint32_t)0x00070000)			/*!<Channel 4 Sampling Count 64 Clock */
N#define ADC_SMPLCNT0_CH4_128CLK		((uint32_t)0x00080000)			/*!<Channel 4 Sampling Count 128 Clock */
N#define ADC_SMPLCNT0_CH4_256CLK		((uint32_t)0x00090000)			/*!<Channel 4 Sampling Count 256 Clock */
N#define ADC_SMPLCNT0_CH4_512CLK		((uint32_t)0x000A0000)			/*!<Channel 4 Sampling Count 512 Clock */
N#define ADC_SMPLCNT0_CH4_1024CLK	((uint32_t)0x000B0000)			/*!<Channel 4 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT0_CH5_0CLK		((uint32_t)0x00000000)			/*!<Channel 5 Sampling Count 0 Clock */
N#define ADC_SMPLCNT0_CH5_1CLK		((uint32_t)0x00100000)			/*!<Channel 5 Sampling Count 1 Clock */
N#define ADC_SMPLCNT0_CH5_2CLK		((uint32_t)0x00200000)			/*!<Channel 5 Sampling Count 2 Clock */
N#define ADC_SMPLCNT0_CH5_4CLK		((uint32_t)0x00300000)			/*!<Channel 5 Sampling Count 4 Clock */
N#define ADC_SMPLCNT0_CH5_8CLK		((uint32_t)0x00400000)			/*!<Channel 5 Sampling Count 8 Clock */
N#define ADC_SMPLCNT0_CH5_16CLK		((uint32_t)0x00500000)			/*!<Channel 5 Sampling Count 16 Clock */
N#define ADC_SMPLCNT0_CH5_32CLK		((uint32_t)0x00600000)			/*!<Channel 5 Sampling Count 32 Clock */
N#define ADC_SMPLCNT0_CH5_64CLK		((uint32_t)0x00700000)			/*!<Channel 5 Sampling Count 64 Clock */
N#define ADC_SMPLCNT0_CH5_128CLK		((uint32_t)0x00800000)			/*!<Channel 5 Sampling Count 128 Clock */
N#define ADC_SMPLCNT0_CH5_256CLK		((uint32_t)0x00900000)			/*!<Channel 5 Sampling Count 256 Clock */
N#define ADC_SMPLCNT0_CH5_512CLK		((uint32_t)0x00A00000)			/*!<Channel 5 Sampling Count 512 Clock */
N#define ADC_SMPLCNT0_CH5_1024CLK	((uint32_t)0x00B00000)			/*!<Channel 5 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT0_CH6_0CLK		((uint32_t)0x00000000)			/*!<Channel 6 Sampling Count 0 Clock */
N#define ADC_SMPLCNT0_CH6_1CLK		((uint32_t)0x01000000)			/*!<Channel 6 Sampling Count 1 Clock */
N#define ADC_SMPLCNT0_CH6_2CLK		((uint32_t)0x02000000)			/*!<Channel 6 Sampling Count 2 Clock */
N#define ADC_SMPLCNT0_CH6_4CLK		((uint32_t)0x03000000)			/*!<Channel 6 Sampling Count 4 Clock */
N#define ADC_SMPLCNT0_CH6_8CLK		((uint32_t)0x04000000)			/*!<Channel 6 Sampling Count 8 Clock */
N#define ADC_SMPLCNT0_CH6_16CLK		((uint32_t)0x05000000)			/*!<Channel 6 Sampling Count 16 Clock */
N#define ADC_SMPLCNT0_CH6_32CLK		((uint32_t)0x06000000)			/*!<Channel 6 Sampling Count 32 Clock */
N#define ADC_SMPLCNT0_CH6_64CLK		((uint32_t)0x07000000)			/*!<Channel 6 Sampling Count 64 Clock */
N#define ADC_SMPLCNT0_CH6_128CLK		((uint32_t)0x08000000)			/*!<Channel 6 Sampling Count 128 Clock */
N#define ADC_SMPLCNT0_CH6_256CLK		((uint32_t)0x09000000)			/*!<Channel 6 Sampling Count 256 Clock */
N#define ADC_SMPLCNT0_CH6_512CLK		((uint32_t)0x0A000000)			/*!<Channel 6 Sampling Count 512 Clock */
N#define ADC_SMPLCNT0_CH6_1024CLK	((uint32_t)0x0B000000)			/*!<Channel 6 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT0_CH7_0CLK		((uint32_t)0x00000000)			/*!<Channel 7 Sampling Count 0 Clock */
N#define ADC_SMPLCNT0_CH7_1CLK		((uint32_t)0x10000000)			/*!<Channel 7 Sampling Count 1 Clock */
N#define ADC_SMPLCNT0_CH7_2CLK		((uint32_t)0x20000000)			/*!<Channel 7 Sampling Count 2 Clock */
N#define ADC_SMPLCNT0_CH7_4CLK		((uint32_t)0x30000000)			/*!<Channel 7 Sampling Count 4 Clock */
N#define ADC_SMPLCNT0_CH7_8CLK		((uint32_t)0x40000000)			/*!<Channel 7 Sampling Count 8 Clock */
N#define ADC_SMPLCNT0_CH7_16CLK		((uint32_t)0x50000000)			/*!<Channel 7 Sampling Count 16 Clock */
N#define ADC_SMPLCNT0_CH7_32CLK		((uint32_t)0x60000000)			/*!<Channel 7 Sampling Count 32 Clock */
N#define ADC_SMPLCNT0_CH7_64CLK		((uint32_t)0x70000000)			/*!<Channel 7 Sampling Count 64 Clock */
N#define ADC_SMPLCNT0_CH7_128CLK		((uint32_t)0x80000000)			/*!<Channel 7 Sampling Count 128 Clock */
N#define ADC_SMPLCNT0_CH7_256CLK		((uint32_t)0x90000000)			/*!<Channel 7 Sampling Count 256 Clock */
N#define ADC_SMPLCNT0_CH7_512CLK		((uint32_t)0xA0000000)			/*!<Channel 7 Sampling Count 512 Clock */
N#define ADC_SMPLCNT0_CH7_1024CLK	((uint32_t)0xB0000000)			/*!<Channel 7 Sampling Count 1024 Clock */
N
N/********************* Bit definition of SMPLCNT1 register **********************/
N#define ADC_SMPLCNT1_CH8_0CLK		((uint32_t)0x00000000)			/*!<Channel 8 Sampling Count 0 Clock */
N#define ADC_SMPLCNT1_CH8_1CLK		((uint32_t)0x00000001)			/*!<Channel 8 Sampling Count 1 Clock */
N#define ADC_SMPLCNT1_CH8_2CLK		((uint32_t)0x00000002)			/*!<Channel 8 Sampling Count 2 Clock */
N#define ADC_SMPLCNT1_CH8_4CLK		((uint32_t)0x00000003)			/*!<Channel 8 Sampling Count 4 Clock */
N#define ADC_SMPLCNT1_CH8_8CLK		((uint32_t)0x00000004)			/*!<Channel 8 Sampling Count 8 Clock */
N#define ADC_SMPLCNT1_CH8_16CLK		((uint32_t)0x00000005)			/*!<Channel 8 Sampling Count 16 Clock */
N#define ADC_SMPLCNT1_CH8_32CLK		((uint32_t)0x00000006)			/*!<Channel 8 Sampling Count 32 Clock */
N#define ADC_SMPLCNT1_CH8_64CLK		((uint32_t)0x00000007)			/*!<Channel 8 Sampling Count 64 Clock */
N#define ADC_SMPLCNT1_CH8_128CLK		((uint32_t)0x00000008)			/*!<Channel 8 Sampling Count 128 Clock */
N#define ADC_SMPLCNT1_CH8_256CLK		((uint32_t)0x00000009)			/*!<Channel 8 Sampling Count 256 Clock */
N#define ADC_SMPLCNT1_CH8_512CLK		((uint32_t)0x0000000A)			/*!<Channel 8 Sampling Count 512 Clock */
N#define ADC_SMPLCNT1_CH8_1024CLK	((uint32_t)0x0000000B)			/*!<Channel 8 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT1_CH9_0CLK		((uint32_t)0x00000000)			/*!<Channel 9 Sampling Count 0 Clock */
N#define ADC_SMPLCNT1_CH9_1CLK		((uint32_t)0x00000010)			/*!<Channel 9 Sampling Count 1 Clock */
N#define ADC_SMPLCNT1_CH9_2CLK		((uint32_t)0x00000020)			/*!<Channel 9 Sampling Count 2 Clock */
N#define ADC_SMPLCNT1_CH9_4CLK		((uint32_t)0x00000030)			/*!<Channel 9 Sampling Count 4 Clock */
N#define ADC_SMPLCNT1_CH9_8CLK		((uint32_t)0x00000040)			/*!<Channel 9 Sampling Count 8 Clock */
N#define ADC_SMPLCNT1_CH9_16CLK		((uint32_t)0x00000050)			/*!<Channel 9 Sampling Count 16 Clock */
N#define ADC_SMPLCNT1_CH9_32CLK		((uint32_t)0x00000060)			/*!<Channel 9 Sampling Count 32 Clock */
N#define ADC_SMPLCNT1_CH9_64CLK		((uint32_t)0x00000070)			/*!<Channel 9 Sampling Count 64 Clock */
N#define ADC_SMPLCNT1_CH9_128CLK		((uint32_t)0x00000080)			/*!<Channel 9 Sampling Count 128 Clock */
N#define ADC_SMPLCNT1_CH9_256CLK		((uint32_t)0x00000090)			/*!<Channel 9 Sampling Count 256 Clock */
N#define ADC_SMPLCNT1_CH9_512CLK		((uint32_t)0x000000A0)			/*!<Channel 9 Sampling Count 512 Clock */
N#define ADC_SMPLCNT1_CH9_1024CLK	((uint32_t)0x000000B0)			/*!<Channel 9 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT1_CH10_0CLK		((uint32_t)0x00000000)			/*!<Channel 10 Sampling Count 0 Clock */
N#define ADC_SMPLCNT1_CH10_1CLK		((uint32_t)0x00000100)			/*!<Channel 10 Sampling Count 1 Clock */
N#define ADC_SMPLCNT1_CH10_2CLK		((uint32_t)0x00000200)			/*!<Channel 10 Sampling Count 2 Clock */
N#define ADC_SMPLCNT1_CH10_4CLK		((uint32_t)0x00000300)			/*!<Channel 10 Sampling Count 4 Clock */
N#define ADC_SMPLCNT1_CH10_8CLK		((uint32_t)0x00000400)			/*!<Channel 10 Sampling Count 8 Clock */
N#define ADC_SMPLCNT1_CH10_16CLK		((uint32_t)0x00000500)			/*!<Channel 10 Sampling Count 16 Clock */
N#define ADC_SMPLCNT1_CH10_32CLK		((uint32_t)0x00000600)			/*!<Channel 10 Sampling Count 32 Clock */
N#define ADC_SMPLCNT1_CH10_64CLK		((uint32_t)0x00000700)			/*!<Channel 10 Sampling Count 64 Clock */
N#define ADC_SMPLCNT1_CH10_128CLK	((uint32_t)0x00000800)			/*!<Channel 10 Sampling Count 128 Clock */
N#define ADC_SMPLCNT1_CH10_256CLK	((uint32_t)0x00000900)			/*!<Channel 10 Sampling Count 256 Clock */
N#define ADC_SMPLCNT1_CH10_512CLK	((uint32_t)0x00000A00)			/*!<Channel 10 Sampling Count 512 Clock */
N#define ADC_SMPLCNT1_CH10_1024CLK	((uint32_t)0x00000B00)			/*!<Channel 10 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT1_CH11_0CLK		((uint32_t)0x00000000)			/*!<Channel 11 Sampling Count 0 Clock */
N#define ADC_SMPLCNT1_CH11_1CLK		((uint32_t)0x00001000)			/*!<Channel 11 Sampling Count 1 Clock */
N#define ADC_SMPLCNT1_CH11_2CLK		((uint32_t)0x00002000)			/*!<Channel 11 Sampling Count 2 Clock */
N#define ADC_SMPLCNT1_CH11_4CLK		((uint32_t)0x00003000)			/*!<Channel 11 Sampling Count 4 Clock */
N#define ADC_SMPLCNT1_CH11_8CLK		((uint32_t)0x00004000)			/*!<Channel 11 Sampling Count 8 Clock */
N#define ADC_SMPLCNT1_CH11_16CLK		((uint32_t)0x00005000)			/*!<Channel 11 Sampling Count 16 Clock */
N#define ADC_SMPLCNT1_CH11_32CLK		((uint32_t)0x00006000)			/*!<Channel 11 Sampling Count 32 Clock */
N#define ADC_SMPLCNT1_CH11_64CLK		((uint32_t)0x00007000)			/*!<Channel 11 Sampling Count 64 Clock */
N#define ADC_SMPLCNT1_CH11_128CLK	((uint32_t)0x00008000)			/*!<Channel 11 Sampling Count 128 Clock */
N#define ADC_SMPLCNT1_CH11_256CLK	((uint32_t)0x00009000)			/*!<Channel 11 Sampling Count 256 Clock */
N#define ADC_SMPLCNT1_CH11_512CLK	((uint32_t)0x0000A000)			/*!<Channel 11 Sampling Count 512 Clock */
N#define ADC_SMPLCNT1_CH11_1024CLK	((uint32_t)0x0000B000)			/*!<Channel 11 Sampling Count 1024 Clock */
N#define ADC_SMPLCNT1_CHINT_0CLK		((uint32_t)0x00000000)			/*!<Internal Channels Sampling Count 0 Clock */
N#define ADC_SMPLCNT1_CHINT_1CLK		((uint32_t)0x00010000)			/*!<Internal Channels Sampling Count 1 Clock */
N#define ADC_SMPLCNT1_CHINT_2CLK		((uint32_t)0x00020000)			/*!<Internal Channels Sampling Count 2 Clock */
N#define ADC_SMPLCNT1_CHINT_4CLK		((uint32_t)0x00030000)			/*!<Internal Channels Sampling Count 4 Clock */
N#define ADC_SMPLCNT1_CHINT_8CLK		((uint32_t)0x00040000)			/*!<Internal Channels Sampling Count 8 Clock */
N#define ADC_SMPLCNT1_CHINT_16CLK	((uint32_t)0x00050000)			/*!<Internal Channels Sampling Count 16 Clock */
N#define ADC_SMPLCNT1_CHINT_32CLK	((uint32_t)0x00060000)			/*!<Internal Channels Sampling Count 32 Clock */
N#define ADC_SMPLCNT1_CHINT_64CLK	((uint32_t)0x00070000)			/*!<Internal Channels Sampling Count 64 Clock */
N#define ADC_SMPLCNT1_CHINT_128CLK	((uint32_t)0x00080000)			/*!<Internal Channels Sampling Count 128 Clock */
N#define ADC_SMPLCNT1_CHINT_256CLK	((uint32_t)0x00090000)			/*!<Internal Channels Sampling Count 256 Clock */
N#define ADC_SMPLCNT1_CHINT_512CLK	((uint32_t)0x000A0000)			/*!<Internal Channels Sampling Count 512 Clock */
N#define ADC_SMPLCNT1_CHINT_1024CLK	((uint32_t)0x000B0000)			/*!<Internal Channels Sampling Count 1024 Clock */
N
N
N/******************************************************************************/
N/*                SC                                                          */
N/******************************************************************************/
N/********************* Bit definition of RBR register **********************/
N#define SC_RBR_RBR_MASK				((uint32_t)0x000000FF)			/*!<Receive Buffer Register */
N/********************* Bit definition of THR register **********************/
N#define SC_THR_THR_MASK				((uint32_t)0x000000FF)			/*!<Transmit Holding Register */
N
N/********************* Bit definition of CTL register **********************/
N#define SC_CTL_SC_CEN				((uint32_t)0x00000001)			/*!<SC Engine Enable */
N#define SC_CTL_DIS_RX				((uint32_t)0x00000002)			/*!<Disable RX transition */
N#define SC_CTL_DIS_TX				((uint32_t)0x00000004)			/*!<Disable TX transition */
N#define SC_CTL_AUTO_CON_EN			((uint32_t)0x00000008)			/*!<Auto Convention Enable */
N#define SC_CTL_CON_SEL_DIRECT_CON	((uint32_t)0x00000000)			/*!<Convention Select */
N#define SC_CTL_CON_SEL_INVERSE_CON	((uint32_t)0x00000030)			/*!<Convention Select */
N#define SC_CTL_CON_SEL_MASK			((uint32_t)0x00000030)			/*!<Convention Select mask*/
N#define SC_CTL_RX_FTRI_LEV_1BYTE	((uint32_t)0x00000000)			/*!<RX Buffer Trigger Level 1 byte*/
N#define SC_CTL_RX_FTRI_LEV_2BYTES	((uint32_t)0x00000040)			/*!<RX Buffer Trigger Level 2 bytes*/
N#define SC_CTL_RX_FTRI_LEV_3BYTES	((uint32_t)0x00000080)			/*!<RX Buffer Trigger Level 3 bytes*/
N#define SC_CTL_RX_FTRI_LEV_MASK		((uint32_t)0x000000C0)			/*!<RX Buffer Trigger Level Mask*/
N#define SC_CTL_BGT_MASK				((uint32_t)0x00001F00)			/*!<Block Guard Time Mask*/
N#define SC_CTL_TMR_SEL_DISABLE		((uint32_t)0x00000000)			/*!<Timer Selection. Disable all internal timer function */
N#define SC_CTL_TMR_SEL_24_BITS		((uint32_t)0x00002000)			/*!<Timer Selection. Enable internal 24 bits timer */
N#define SC_CTL_TMR_SEL_24_8_BITS	((uint32_t)0x00004000)			/*!<Timer Selection. Enable internal 24 bits timer and 8 bits internal timer */
N#define SC_CTL_TMR_SEL_24_8_8_BITS	((uint32_t)0x00006000)			/*!<Timer Selection. Enable internal 24 bits timer and two 8 bits timers */
N#define SC_CTL_TMR_SEL_MASK			((uint32_t)0x00006000)			/*!<Timer Selection Mask */
N#define SC_CTL_SLEN					((uint32_t)0x00008000)			/*!<Stop Bit Length */
N#define SC_CTL_RX_ERETRY_MASK		((uint32_t)0x00070000)			/*!<RX Error Retry Register */
N#define SC_CTL_RX_ERETRY_EN			((uint32_t)0x00080000)			/*!<RX Error Retry Enable Register */
N#define SC_CTL_TX_ERETRY_MASK		((uint32_t)0x00700000)			/*!<TX Error Retry Register */
N#define SC_CTL_TX_ERETRY_EN			((uint32_t)0x00800000)			/*!<TX Error Retry Enable Register */
N#define SC_CTL_CD_DEB_SEL_IN_384_REMOVAL_128 ((uint32_t)0x00000000)			/*!<Card Detect De-Bounce Select Register. Card insert once per 384 engine clocks and de-bounce sample card removal once per 128 engine clocks.*/
N#define SC_CTL_CD_DEB_SEL_IN_192_REMOVAL_64	 ((uint32_t)0x01000000)			/*!<Card Detect De-Bounce Select Register. Card insert once per 192 engine clocks and de-bounce sample card removal once per 64 engine clocks. */
N#define SC_CTL_CD_DEB_SEL_IN_96_REMOVAL_32	 ((uint32_t)0x02000000)			/*!<Card Detect De-Bounce Select Register. Card insert once per 96 engine clocks and de-bounce sample card removal once per 32 engine clocks. */
N#define SC_CTL_CD_DEB_SEL_IN_48_REMOVAL_16	 ((uint32_t)0x03000000)			/*!<Card Detect De-Bounce Select Register. Card insert once per 48 engine clocks and de-bounce sample card removal once per 16 engine clocks. */
N#define SC_CTL_CD_DEB_SEL_MASK				 ((uint32_t)0x03000000)			/*!<Card Detect De-Bounce Select Register Mask */
N
N/********************* Bit definition of ALTCTL register **********************/
N#define SC_ALTCTL_TX_RST			((uint32_t)0x00000001)			/*!<TX Software Reset */
N#define SC_ALTCTL_RX_RST			((uint32_t)0x00000002)			/*!<RX Software Reset */
N#define SC_ALTCTL_DACT_EN			((uint32_t)0x00000004)			/*!<Deactivation Sequence Generator Enable */
N#define SC_ALTCTL_ACT_EN			((uint32_t)0x00000008)			/*!<Activation Sequence Generator Enable */
N#define SC_ALTCTL_WARST_EN			((uint32_t)0x00000010)			/*!<Warm Reset Sequence Generator Enable */
N#define SC_ALTCTL_TMR0_SEN			((uint32_t)0x00000020)			/*!<Internal Timer0 Start Enable */
N#define SC_ALTCTL_TMR1_SEN			((uint32_t)0x00000040)			/*!<Internal Timer1 Start Enable */
N#define SC_ALTCTL_TMR2_SEN			((uint32_t)0x00000080)			/*!<Internal Timer2 Start Enable */
N#define SC_ALTCTL_INIT_SEL_MASK		((uint32_t)0x00000300)			/*!<Initial Timing Selection Mask*/
N#define SC_ALTCTL_RX_BGT_EN			((uint32_t)0x00001000)			/*!<Receiver Block Guard Time Function Enable */
N#define SC_ALTCTL_TMR0_ATV			((uint32_t)0x00002000)			/*!<Internal Timer0 Active State (Read Only) */
N#define SC_ALTCTL_TMR1_ATV			((uint32_t)0x00004000)			/*!<Internal Timer1 Active State (Read Only) */
N#define SC_ALTCTL_TMR2_ATV			((uint32_t)0x00008000)			/*!<Internal Timer2 Active State (Read Only) */
N
N/********************* Bit definition of EGTR register **********************/
N#define SC_EGTR_EGT_MASK			((uint32_t)0x000000FF)			/*!<Extended Guard Time Mask */
N
N/********************* Bit definition of RFTMR register **********************/
N#define SC_RFTMR_RFTM_MASK			((uint32_t)0x000001FF)			/*!<SC Receiver Buffer Time-Out Register (ETU Base) Mask */
N
N/********************* Bit definition of ETUCR register **********************/
N#define SC_ETUCR_ETU_RDIV_MASK		((uint32_t)0x00000FFF)			/*!<ETU Rate Divider Mask*/
N#define SC_ETUCR_COMPEN_EN			((uint32_t)0x00008000)			/*!<Compensation Mode Enable */
N
N/********************* Bit definition of IER register **********************/
N#define SC_IER_RDA_IE				((uint32_t)0x00000001)			/*!<Receive Data Reach Interrupt Enable */
N#define SC_IER_TBE_IE				((uint32_t)0x00000002)			/*!<Transmit Buffer Empty Interrupt Enable */
N#define SC_IER_TERR_IE				((uint32_t)0x00000004)			/*!<Transfer Error Interrupt Enable */
N#define SC_IER_TMR0_IE				((uint32_t)0x00000008)			/*!<Timer0 Interrupt Enable */
N#define SC_IER_TMR1_IE				((uint32_t)0x00000010)			/*!<Timer1 Interrupt Enable */
N#define SC_IER_TMR2_IE				((uint32_t)0x00000020)			/*!<Timer2 Interrupt Enable */
N#define SC_IER_BGT_IE				((uint32_t)0x00000040)			/*!<Block Guard Time Interrupt Enable */
N#define SC_IER_CD_IE				((uint32_t)0x00000080)			/*!<Card Detect Interrupt Enable */
N#define SC_IER_INIT_IE				((uint32_t)0x00000100)			/*!<Initial End Interrupt Enable */
N#define SC_IER_RTMR_IE				((uint32_t)0x00000200)			/*!<Receiver Buffer Time-Out Interrupt Enable  */
N#define SC_IER_ACON_ERR_IE			((uint32_t)0x00000400)			/*!<Auto convention Error Interrupt Enable */
N
N/********************* Bit definition of ISR register **********************/
N#define SC_ISR_RDA_IS				((uint32_t)0x00000001)			/*!<Receive Data Reach Interrupt Status Flag (Read Only) */
N#define SC_ISR_TBE_IS				((uint32_t)0x00000002)			/*!<Transmit Buffer Empty Interrupt Status Flag (Read Only) */
N#define SC_ISR_TERR_IS				((uint32_t)0x00000004)			/*!<Transfer Error Interrupt Status Flag (Read Only) */
N#define SC_ISR_TMR0_IS				((uint32_t)0x00000008)			/*!<Timer0 Interrupt Status Flag (Read Only) */
N#define SC_ISR_TMR1_IS				((uint32_t)0x00000010)			/*!<Timer1 Interrupt Status Flag (Read Only) */
N#define SC_ISR_TMR2_IS				((uint32_t)0x00000020)			/*!<Timer2 Interrupt Status Flag (Read Only) */
N#define SC_ISR_BGT_IS				((uint32_t)0x00000040)			/*!<Block Guard Time Interrupt Status Flag (Read Only) */
N#define SC_ISR_CD_IS				((uint32_t)0x00000080)			/*!<Card Detect Interrupt Status Flag (Read Only) */
N#define SC_ISR_INIT_IS				((uint32_t)0x00000100)			/*!<Initial End Interrupt Status Flag (Read Only) */
N#define SC_ISR_RTMR_IS				((uint32_t)0x00000200)			/*!<Receiver buffer Time-Out Interrupt Status Flag (Read Only) */
N#define SC_ISR_ACON_ERR_IS			((uint32_t)0x00000400)			/*!<Auto Convention Error Interrupt Status Flag (Read Only) */
N
N/********************* Bit definition of TRSR register **********************/
N#define SC_TRSR_RX_OVER_F			((uint32_t)0x00000001)			/*!<RX Overflow Error Status Flag (Read Only)  */
N#define SC_TRSR_RX_EMPTY_F			((uint32_t)0x00000002)			/*!<Receiver Buffer Empty Status Flag(Read Only) */
N#define SC_TRSR_RX_FULL_F			((uint32_t)0x00000004)			/*!<Receiver Buffer Full Status Flag (Read Only) */
N#define SC_TRSR_RX_EPA_F			((uint32_t)0x00000010)			/*!<Receiver Parity Error Status Flag (Read Only) */
N#define SC_TRSR_RX_EFR_F			((uint32_t)0x00000020)			/*!<Receiver Frame Error Status Flag (Read Only) */
N#define SC_TRSR_RX_EBR_F			((uint32_t)0x00000040)			/*!<Receiver Break Error Status Flag (Read Only) */
N#define SC_TRSR_TX_OVER_F			((uint32_t)0x00000100)			/*!<TX Overflow Error Interrupt Status Flag (Read Only) */
N#define SC_TRSR_TX_EMPTY_F			((uint32_t)0x00000200)			/*!<Transmit buffer Empty Status Flag (Read Only) */
N#define SC_TRSR_TX_FULL_F			((uint32_t)0x00000400)			/*!<Transmit buffer Full Status flag (Read Only) */
N#define SC_TRSR_RX_POINT_F_MASK		((uint32_t)0x00070000)			/*!<Receiver Buffer Pointer Status Flag (Read Only) Mask */
N#define SC_TRSR_RX_ERETRY_F			((uint32_t)0x00200000)			/*!<Receiver Retry Error (Read Only) */
N#define SC_TRSR_RX_OVER_ERETRY		((uint32_t)0x00400000)			/*!<Receiver Over Retry Error (Read Only) */
N#define SC_TRSR_RX_ATV				((uint32_t)0x00800000)			/*!<Receiver In Active Status Flag (Read Only) */
N#define SC_TRSR_TX_POINT_F_MASK		((uint32_t)0x07000000)			/*!<Transmit Buffer Pointer Status Flag (Read Only) Mask */
N#define SC_TRSR_TX_ERETRY_F			((uint32_t)0x20000000)			/*!<Transmitter Retry Error (Read Only) */
N#define SC_TRSR_TX_OVER_ERETRY		((uint32_t)0x40000000)			/*!<Transmitter Over Retry Error (Read Only) */
N#define SC_TRSR_TX_ATV				((uint32_t)0x80000000)			/*!<Transmit In Active Status Flag (Read Only) */
N
N/********************* Bit definition of PINCSR register **********************/
N#define SC_PINCSR_POW_EN			((uint32_t)0x00000001)			/*!<SC_POW_EN Pin Signal */
N#define SC_PINCSR_SC_RST			((uint32_t)0x00000002)			/*!<SC_RST Pin Signal */
N#define SC_PINCSR_CD_REM_F			((uint32_t)0x00000004)			/*!<Card Detect Removal Status Of SC_CD Pin (Read Only) */
N#define SC_PINCSR_CD_INS_F			((uint32_t)0x00000008)			/*!<Card Detect Insert Status Of SC_CD Pin (Read Only) */
N#define SC_PINCSR_CD_PIN_ST			((uint32_t)0x00000010)			/*!<Card Detect Status Of SC_CD Pin Status (Read Only) */
N#define SC_PINCSR_CLK_STOP_LEV		((uint32_t)0x00000020)			/*!<SC Clock Stop Level */
N#define SC_PINCSR_CLK_KEEP			((uint32_t)0x00000040)			/*!<SC Clock Enable  */
N#define SC_PINCSR_ADAC_CD_EN		((uint32_t)0x00000080)			/*!<Auto Deactivation When Card Removal */
N#define SC_PINCSR_SC_OEN_ST			((uint32_t)0x00000100)			/*!<SC Data Output Enable Pin Status (Read Only) */
N#define SC_PINCSR_SC_DATA_O			((uint32_t)0x00000200)			/*!<SC Data Output Pin */
N#define SC_PINCSR_CD_LEV			((uint32_t)0x00000400)			/*!<Card Detect Level */
N#define SC_PINCSR_POW_INV			((uint32_t)0x00000800)			/*!<SC_POW Pin Inverse */
N#define SC_PINCSR_SC_DATA_I_ST		((uint32_t)0x00010000)			/*!<SC Data Input Pin Status (Read Only) */
N
N/********************* Bit definition of TMR0 register **********************/
N#define SC_TMR_MODE_DC				((uint32_t)0x00000000)		        /*!<Timer Operation Mode 0 */
N#define SC_TMR_MODE_DC_S_TO			((uint32_t)0x01000000)		        /*!<Timer Operation Mode 1 */
N#define SC_TMR_MODE_DC_RX_S_TO			((uint32_t)0x02000000)		        /*!<Timer Operation Mode 2 */
N#define SC_TMR_MODE_DC_INITIAL_END		((uint32_t)0x03000000)		        /*!<Timer Operation Mode 3 */
N#define SC_TMR_MODE_DC_RELOAD			((uint32_t)0x04000000)		        /*!<Timer Operation Mode 4 */
N#define SC_TMR_MODE_DC_RELOAD_S_TO		((uint32_t)0x05000000)		        /*!<Timer Operation Mode 5 */
N#define SC_TMR_MODE_DC_RELOAD_RX_S_TO		((uint32_t)0x06000000)		        /*!<Timer Operation Mode 6 */
N#define SC_TMR_MODE_DC_RELOAD_S_S		((uint32_t)0x07000000)		        /*!<Timer Operation Mode 7 */
N#define SC_TMR_MODE_UC				((uint32_t)0x08000000)		        /*!<Timer Operation Mode 8 */
N#define SC_TMR_MODE_DC_RELOAD_C_S		((uint32_t)0x0F000000)		        /*!<Timer Operation Mode 15 */
N#define SC_TMR0_CNT_MASK			((uint32_t)0x00FFFFFF)			/*!<Timer 0 Counter Value Register (ETU Base) Mask*/
N#define SC_TMR0_MODE_MASK			((uint32_t)0x0F000000)			/*!<Timer 0 Operation Mode Selection Mask */
N
N/********************* Bit definition of TMR1 register **********************/
N#define SC_TMR1_CNT_MASK			((uint32_t)0x000000FF)			/*!<Timer 1 Counter Value Register (ETU Base) Mask */
N#define SC_TMR1_MODE_MASK			((uint32_t)0x0F000000)			/*!<Timer 1 Operation Mode Selection Mask */
N
N/********************* Bit definition of TMR2 register **********************/
N#define SC_TMR2_CNT_MASK			((uint32_t)0x000000FF)			/*!<Timer 2 Counter Value Register (ETU Base) Mask */
N#define SC_TMR2_MODE_MASK			((uint32_t)0x0F000000)			/*!<Timer 2 Operation Mode Selection Mask */
N
N/********************* Bit definition of UACTL register **********************/
N#define SC_UACTL_UA_MODE_EN			((uint32_t)0x00000001)			/*!<UART Mode Enable */
N#define SC_UACTL_DATA_LEN_8_BITS	((uint32_t)0x00000000)			/*!<Data Length 8 bits */
N#define SC_UACTL_DATA_LEN_7_BITS	((uint32_t)0x00000010)			/*!<Data Length 7 bits */
N#define SC_UACTL_DATA_LEN_6_BITS	((uint32_t)0x00000020)			/*!<Data Length 6 bits */
N#define SC_UACTL_DATA_LEN_5_BITS	((uint32_t)0x00000030)			/*!<Data Length 5 bits */
N#define SC_UACTL_DATA_LEN_MASK		((uint32_t)0x00000030)			/*!<Data Length Mask */
N#define SC_UACTL_PBDIS				((uint32_t)0x00000040)			/*!<Parity Bit Disable */
N#define SC_UACTL_OPE				((uint32_t)0x00000080)			/*!<Odd Parity Enable */
N
N/********************* Bit definition of TDRA register **********************/
N#define SC_TDRA_TDR0_MASK			((uint32_t)0x00FFFFFF)			/*!<Timer0 Current Data Register Mask(Read Only) */
N
N/********************* Bit definition of TDRB register **********************/
N#define SC_TDRB_TDR1_MASK			((uint32_t)0x000000FF)			/*!<Timer1 Current Data Register Mask(Read Only) */
N#define SC_TDRB_TDR2_MASK			((uint32_t)0x0000FF00)			/*!<Timer2 Current Data Register Mask(Read Only) */
N
N
N/******************************************************************************/
N/*                I2S                                                         */
N/******************************************************************************/
N/********************* Bit definition of CON register **********************/
N#define	I2S_CON_I2SEN				((uint32_t)0x00000001)			/*!<I2S enable */
N#define	I2S_CON_TXEN				((uint32_t)0x00000002)			/*!<Data transmit enable */
N#define	I2S_CON_RXEN				((uint32_t)0x00000004)			/*!<Data receive enable */
N#define	I2S_CON_MUTE				((uint32_t)0x00000008)			/*!<Transmit mute enable */
N#define	I2S_CON_WORDWIDTH_8BIT		((uint32_t)0x00000000)			/*!<Word length, 8-bit */
N#define	I2S_CON_WORDWIDTH_16BIT		((uint32_t)0x00000010)			/*!<Word length, 16-bit */
N#define	I2S_CON_WORDWIDTH_24BIT		((uint32_t)0x00000020)			/*!<Word length, 24-bit */
N#define	I2S_CON_WORDWIDTH_32BIT		((uint32_t)0x00000030)			/*!<Word length, 32-bit */
N#define	I2S_CON_WORDWIDTH_MASK		((uint32_t)0x00000030)			/*!<Word length Mask */
N#define	I2S_CON_MONO				((uint32_t)0x00000040)			/*!<Stereo or mono format select */
N#define	I2S_CON_FORMAT				((uint32_t)0x00000080)			/*!<I2S or MSB-justified format select */
N#define	I2S_CON_SLAVE				((uint32_t)0x00000100)			/*!<Slave or master mode */
N#define	I2S_CON_TXTH_1_WORD			((uint32_t)0x00000200)			/*!<Transmit FIFO threshold level, 1 WORD */
N#define	I2S_CON_TXTH_2_WORD			((uint32_t)0x00000400)			/*!<Transmit FIFO threshold level, 2 WORD */
N#define	I2S_CON_TXTH_3_WORD			((uint32_t)0x00000600)			/*!<Transmit FIFO threshold level, 3 WORD */
N#define	I2S_CON_TXTH_4_WORD			((uint32_t)0x00000800)			/*!<Transmit FIFO threshold level, 4 WORD */
N#define	I2S_CON_TXTH_5_WORD			((uint32_t)0x00000A00)			/*!<Transmit FIFO threshold level, 5 WORD */
N#define	I2S_CON_TXTH_6_WORD			((uint32_t)0x00000C00)			/*!<Transmit FIFO threshold level, 6 WORD */
N#define	I2S_CON_TXTH_7_WORD			((uint32_t)0x00000E00)			/*!<Transmit FIFO threshold level, 7 WORD */
N#define	I2S_CON_TXTH_MASK			((uint32_t)0x00000E00)			/*!<Transmit FIFO threshold level Mask */
N#define	I2S_CON_RXTH_1_WORD			((uint32_t)0x00001000)			/*!<Receive FIFO threshold level, 1 WORD */
N#define	I2S_CON_RXTH_2_WORD			((uint32_t)0x00002000)			/*!<Receive FIFO threshold level, 2 WORD */
N#define	I2S_CON_RXTH_3_WORD			((uint32_t)0x00003000)			/*!<Receive FIFO threshold level, 3 WORD */
N#define	I2S_CON_RXTH_4_WORD			((uint32_t)0x00004000)			/*!<Receive FIFO threshold level, 4 WORD */
N#define	I2S_CON_RXTH_5_WORD			((uint32_t)0x00005000)			/*!<Receive FIFO threshold level, 5 WORD */
N#define	I2S_CON_RXTH_6_WORD			((uint32_t)0x00006000)			/*!<Receive FIFO threshold level, 6 WORD */
N#define	I2S_CON_RXTH_7_WORD			((uint32_t)0x00007000)			/*!<Receive FIFO threshold level, 7 WORD */
N#define	I2S_CON_RXTH_MASK			((uint32_t)0x00007000)			/*!<Receive FIFO threshold level Mask */
N#define	I2S_CON_MCLKEN				((uint32_t)0x00008000)			/*!<Master clock enable */
N#define	I2S_CON_RCHZCEN				((uint32_t)0x00010000)			/*!<Right channel zero-cross detection enable */
N#define	I2S_CON_LCHZCEN				((uint32_t)0x00020000)			/*!<Left channel zero-cross detect enable */
N#define	I2S_CON_CLR_TXFIFO			((uint32_t)0x00040000)			/*!<Clear transmit FIFO */
N#define	I2S_CON_CLR_RXFIFO			((uint32_t)0x00080000)			/*!<Clear receive FIFO */
N#define	I2S_CON_TXDMA				((uint32_t)0x00100000)			/*!<Enable transmit DMA */
N#define	I2S_CON_RXDMA				((uint32_t)0x00200000)			/*!<Enable receive DMA */
N#define	I2S_CON_RXLCH				((uint32_t)0x00800000)			/*!<Select Mono Source Channel */
N
N/********************* Bit definition of CLKDIV register **********************/
N#define	I2S_CLKDIV_MCLK_DIV_MASK	((uint32_t)0x00000007)			/*!<Master clock divider Mask */
N#define	I2S_CLKDIV_BCLK_DIV_MASK	((uint32_t)0x0000FF00)			/*!<Bit clock divider Mask */
N
N/********************* Bit definition of INTEN register **********************/
N#define	I2S_IE_RXUDFIE				((uint32_t)0x00000001)			/*!<Receive FIFO underflow interrupt enable */
N#define	I2S_IE_RXOVFIE				((uint32_t)0x00000002)			/*!<Receive FIFO overflow interrupt enable */
N#define	I2S_IE_RXTHIE				((uint32_t)0x00000004)			/*!<Receive FIFO threshold level interrupt enable */
N#define	I2S_IE_TXUDFIE				((uint32_t)0x00000100)			/*!<Transmit FIFO underflow interrupt enable */
N#define	I2S_IE_TXOVFIE				((uint32_t)0x00000200)			/*!<Transmit FIFO overflow interrupt enable */
N#define	I2S_IE_TXTHIE				((uint32_t)0x00000400)			/*!<Transmit FIFO threshold level interrupt enable */
N#define	I2S_IE_RZCIE				((uint32_t)0x00000800)			/*!<Right channel zero-cross interrupt enable */
N#define	I2S_IE_LZCIE				((uint32_t)0x00001000)			/*!<Left channel zero-cross interrupt enable */
N
N/********************* Bit definition of I2S_STATUS register **********************/
N#define	I2S_STATUS_I2SINT			((uint32_t)0x00000001)			/*!<I2S interrupt flag */
N#define	I2S_STATUS_I2SRXINT			((uint32_t)0x00000002)			/*!<Receive interrupt flag */
N#define	I2S_STATUS_I2STXINT			((uint32_t)0x00000004)			/*!<Transmit interrupt flag */
N#define	I2S_STATUS_RIGHT			((uint32_t)0x00000008)			/*!<Right or left channel select */
N#define	I2S_STATUS_RXUDF			((uint32_t)0x00000100)			/*!<Receive FIFO underflow flag */
N#define	I2S_STATUS_RXOVF			((uint32_t)0x00000200)			/*!<Receive FIFO overflow flag */
N#define	I2S_STATUS_RXTHF			((uint32_t)0x00000400)			/*!<Receive FIFO threshold flag */
N#define	I2S_STATUS_RXFULL			((uint32_t)0x00000800)			/*!<Receive FIFO full flag */
N#define	I2S_STATUS_RXEMPTY			((uint32_t)0x00001000)			/*!<Receive FIFO empty flag */
N#define	I2S_STATUS_TXUDF			((uint32_t)0x00010000)			/*!<Transmit FIFO underflow flag */
N#define	I2S_STATUS_TXOVF			((uint32_t)0x00020000)			/*!<Transmit FIFO overflow flag */
N#define	I2S_STATUS_TXTHF			((uint32_t)0x00040000)			/*!<Transmit FIFO threshold flag */
N#define	I2S_STATUS_TXFULL			((uint32_t)0x00080000)			/*!<Transmit FIFO full flag */
N#define	I2S_STATUS_TXEMPTY			((uint32_t)0x00100000)			/*!<Transmit FIFO empty flag */
N#define	I2S_STATUS_TXBUSY			((uint32_t)0x00200000)			/*!<Transmit under busy */
N#define	I2S_STATUS_RZCF				((uint32_t)0x00400000)			/*!<Right channnel zero-cross flag */
N#define	I2S_STATUS_LZCF				((uint32_t)0x00800000)			/*!<Left channnel zero-cross flag */
N#define	I2S_STATUS_RX_LEVEL_MASK	((uint32_t)0x0F000000)			/*!<Receive FIFO level Mask */
N#define	I2S_STATUS_TX_LEVEL_MASK	((uint32_t)0xF0000000)			/*!<Transmit FIFO level Mask */
N
N/*@}*/ /* end of group NANO1xx_Exported_Constants */
N
N
N/******************************************************************************/
N/*                Device Specific Macros                                      */
N/******************************************************************************/
N/** @addtogroup NANO1xx_Exported_Macros NANO1xx Exported Macros
N  NANO1xx Device Specific Macros
N  @{
N*/
N#define UNLOCKREG(x)				{GCR->RegLockAddr = 0x59; GCR->RegLockAddr = 0x16; GCR->RegLockAddr = 0x88;}  /*!< Unlock protected register */
N#define LOCKREG(x)          		GCR->RegLockAddr = 0x00  /*!< Lock protected register */  
N
N/******************************************************************************/
N/*                Multi-Function Pin                                          */
N/******************************************************************************/
N/*!PortA14->UART0 TX; PortA15->UART0 RX */
N#define MFP_UART0_TO_PORTA()		(GCR->PA_H_MFP = GCR->PA_H_MFP &~(PA15_MFP_MASK|PA14_MFP_MASK) | (PA15_MFP_UART0_TX|PA14_MFP_UART0_RX))
N
N/*!<PortA3->UART1 TX; PortA2->UART1 RX */
N#define MFP_UART1_TO_PORTA()		(GCR->PA_L_MFP = GCR->PA_L_MFP &~(PA3_MFP_MASK|PA2_MFP_MASK)|(PA2_MFP_UART1_TX|PA3_MFP_UART1_RX))
N
N/*!<PortB0->UART0 RX; PortB1->UART0 TX */
N#define MFP_UART0_TO_PORTB()		(GCR->PB_L_MFP = GCR->PB_L_MFP &~(PB0_MFP_MASK|PB1_MFP_MASK)|(PB0_MFP_UART0_RX|PB1_MFP_UART0_TX))
N/*!<PortB0->UART0 RX; PortB1->UART0 TX; PortB2->RTS; PortB3->CTS */
N#define MFP_FULL_UART0_TO_PORTB()	(GCR->PB_L_MFP = GCR->PB_L_MFP &~0x0000ffff|0x00001111)
N
N/*!<PortB4->UART1 RX; PortB5->UART1 TX */
N#define MFP_UART1_TO_PORTB()		(GCR->PB_L_MFP = GCR->PB_L_MFP &~(PB4_MFP_MASK|PB5_MFP_MASK)|(PB4_MFP_UART1_RX|PB5_MFP_UART1_TX))
N/*!<PortB4->UART0 RX; PortB5->UART0 TX; PortB6->RTS; PortB7->CTS */
N#define MFP_FULL_UART1_TO_PORTB()	(GCR->PB_L_MFP = GCR->PB_L_MFP &~0xffff0000|0x11110000)
N
N/*!Enable 8-BIT EBI: PA6~7->AD7~6, PA10->nWE, PA11->nRE, PB6->ALE, PB7->nCS, PB12~13->AD0~1, PC6~7->AD4~5, PC14~15->AD2~3, PC8->XCLK */
N#define MFP_8BIT_EBI()		{ \
N								GCR->PA_L_MFP = GCR->PA_L_MFP &~(PA6_MFP_MASK|PA7_MFP_MASK)|(PA6_MFP_EBI_AD7|PA7_MFP_EBI_AD6); \
N                             	GCR->PA_H_MFP = GCR->PA_H_MFP &~(PA10_MFP_MASK|PA11_MFP_MASK)|(PA10_MFP_EBI_NWE|PA11_MFP_EBI_NRE); \
N							 	GCR->PB_L_MFP = GCR->PB_L_MFP &~(PB6_MFP_MASK|PB7_MFP_MASK)|(PB6_MFP_EBI_ALE|PB7_MFP_EBI_NCS); \
N							 	GCR->PB_H_MFP = GCR->PB_H_MFP &~(PB12_MFP_MASK|PB13_MFP_MASK)|(PB12_MFP_EBI_AD0|PB13_MFP_EBI_AD1); \
N							 	GCR->PC_L_MFP = GCR->PC_L_MFP &~(PC6_MFP_MASK|PC7_MFP_MASK)|(PC6_MFP_EBI_AD4|PC7_MFP_EBI_AD5); \
N							 	GCR->PC_H_MFP = GCR->PC_H_MFP &~0xff00000f|0x22000002; \
N							}
X#define MFP_8BIT_EBI()		{ 								GCR->PA_L_MFP = GCR->PA_L_MFP &~(PA6_MFP_MASK|PA7_MFP_MASK)|(PA6_MFP_EBI_AD7|PA7_MFP_EBI_AD6);                              	GCR->PA_H_MFP = GCR->PA_H_MFP &~(PA10_MFP_MASK|PA11_MFP_MASK)|(PA10_MFP_EBI_NWE|PA11_MFP_EBI_NRE); 							 	GCR->PB_L_MFP = GCR->PB_L_MFP &~(PB6_MFP_MASK|PB7_MFP_MASK)|(PB6_MFP_EBI_ALE|PB7_MFP_EBI_NCS); 							 	GCR->PB_H_MFP = GCR->PB_H_MFP &~(PB12_MFP_MASK|PB13_MFP_MASK)|(PB12_MFP_EBI_AD0|PB13_MFP_EBI_AD1); 							 	GCR->PC_L_MFP = GCR->PC_L_MFP &~(PC6_MFP_MASK|PC7_MFP_MASK)|(PC6_MFP_EBI_AD4|PC7_MFP_EBI_AD5); 							 	GCR->PC_H_MFP = GCR->PC_H_MFP &~0xff00000f|0x22000002; 							}
N
N/*!Enable 16-BIT EBI:  PA6~7->AD7~6, PA10->nWE, PA11->nRE, PB6->ALE, PB7->nCS, PB12~13->AD0~1, PC6~7->AD4~5, PC14~15->AD2~3, PC8->XCLK
N                       PA1~5->AD12~8, PA12~14->AD13~15, PB2->nWRL, PB3->nWRH */
N#define MFP_16BIT_EBI()		{ \
N								GCR->PA_L_MFP = GCR->PA_L_MFP &~0xfffffff0|0x22222220; \
N								GCR->PA_H_MFP = GCR->PA_H_MFP &~0x0fffff00|0x02222200; \
N								GCR->PB_L_MFP = GCR->PB_L_MFP &~0xff00ff00|0x22002200; \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~(PB12_MFP_MASK|PB13_MFP_MASK)|(PB12_MFP_EBI_AD0|PB13_MFP_EBI_AD1); \
N								GCR->PC_L_MFP = GCR->PC_L_MFP &~(PC6_MFP_MASK|PC7_MFP_MASK)|(PC6_MFP_EBI_AD4|PC7_MFP_EBI_AD5); \
N								GCR->PC_H_MFP = GCR->PC_H_MFP &~0xff00000f|0x22000002; \
N							}
X#define MFP_16BIT_EBI()		{ 								GCR->PA_L_MFP = GCR->PA_L_MFP &~0xfffffff0|0x22222220; 								GCR->PA_H_MFP = GCR->PA_H_MFP &~0x0fffff00|0x02222200; 								GCR->PB_L_MFP = GCR->PB_L_MFP &~0xff00ff00|0x22002200; 								GCR->PB_H_MFP = GCR->PB_H_MFP &~(PB12_MFP_MASK|PB13_MFP_MASK)|(PB12_MFP_EBI_AD0|PB13_MFP_EBI_AD1); 								GCR->PC_L_MFP = GCR->PC_L_MFP &~(PC6_MFP_MASK|PC7_MFP_MASK)|(PC6_MFP_EBI_AD4|PC7_MFP_EBI_AD5); 								GCR->PC_H_MFP = GCR->PC_H_MFP &~0xff00000f|0x22000002; 							}
N
N/*!<Enable SmartCard0: PA8->CLK, PA9->DAT, PA10->PWR, PA11->RST, PB4->Card Detection */
N#define MFP_SC0_TO_PORTA()	{ \
N								GCR->PA_H_MFP = GCR->PA_H_MFP &~0x0000ffff|0x00003333; \
N								GCR->PB_L_MFP = GCR->PB_L_MFP &~PB4_MFP_MASK|PB4_MFP_SC0_CD; \
N							}
X#define MFP_SC0_TO_PORTA()	{ 								GCR->PA_H_MFP = GCR->PA_H_MFP &~0x0000ffff|0x00003333; 								GCR->PB_L_MFP = GCR->PB_L_MFP &~PB4_MFP_MASK|PB4_MFP_SC0_CD; 							}
N
N/*!<Enable SmartCard1: PC0->CLK, PC1->DAT, PC2->PWR, PC3->RST, PC6->Card Detection */
N#define MFP_SC1_TO_PORTC()	(GCR->PC_L_MFP = GCR->PC_L_MFP &~0x0f00ffff|0x04004444)
N
N/*!<Enable SmartCard1: PD0->CLK, PD1->DAT, PD2->PWR, PD3->RST, PD4->Card Detection */
N#define MFP_SC1_TO_PORTD()	(GCR->PD_L_MFP = GCR->PD_L_MFP &~0x000fffff|0x00044444)
N
N/*!<Enable SmartCard2: PA0->Card Detection, PA4->PWR, PA5->RST, PA6->CLK, PA7->DAT */
N#define MFP_SC2_TO_PORTA()	(GCR->PA_L_MFP = GCR->PA_L_MFP &~0xffff000f|0x44440004)
N
N/*!<Enable SmartCard2: PB8->PWR, PB9->RST, PB10->CLK, PB11->DAT, PB14->Card Detection */
N#define MFP_SC2_TO_PORTB()	(GCR->PB_H_MFP = GCR->PB_H_MFP &~0x0f00ffff|0x04004444)
N
N/*!<Enable I2S: GPA15->mclk; GPC0->ws, GPC1->bclk, GPC2->din, GPC3->dout */
N#define MFP_I2S_TO_PORTC()	{ \
N								GCR->PA_H_MFP = GCR->PA_H_MFP &~PA15_MFP_MASK|PA15_MFP_I2S_MCLK; \
N								GCR->PC_L_MFP = GCR->PC_L_MFP &~0x0000ffff|0x00002222; \
N							}
X#define MFP_I2S_TO_PORTC()	{ 								GCR->PA_H_MFP = GCR->PA_H_MFP &~PA15_MFP_MASK|PA15_MFP_I2S_MCLK; 								GCR->PC_L_MFP = GCR->PC_L_MFP &~0x0000ffff|0x00002222; 							}
N
N/*!<Enable I2S: GPE0->mclk; GPD2->ws, GPD3->bclk, GPD4->din, GPD5->dout */
N#define MFP_I2S_TO_PORTD()	{ \
N								GCR->PE_L_MFP = GCR->PE_L_MFP &~PE0_MFP_MASK|PE0_MFP_I2S_MCLK; \
N								GCR->PD_L_MFP = GCR->PD_L_MFP & ~0x00ffff00|0x00222200; \
N							}
X#define MFP_I2S_TO_PORTD()	{ 								GCR->PE_L_MFP = GCR->PE_L_MFP &~PE0_MFP_MASK|PE0_MFP_I2S_MCLK; 								GCR->PD_L_MFP = GCR->PD_L_MFP & ~0x00ffff00|0x00222200; 							}
N
N/*!<Enable GPB14->EXT0 */
N#define MFP_EXT_INT0_TO_PB14()	(GCR->PB_H_MFP = GCR->PB_H_MFP & ~PB14_MFP_MASK | PB14_MFP_EXT_INT0)
N
N/*!<Enable GPB9->EXT0 */
N#define MFP_EXT_INT0_TO_PB9()	(GCR->PB_H_MFP = GCR->PB_H_MFP & ~PB9_MFP_MASK | PB9_MFP_EXT_INT0)
N
N/*!<Enable GPB8->EXT0 */
N#define MFP_EXT_INT0_TO_PB8()	(GCR->PB_H_MFP = GCR->PB_H_MFP & ~PB8_MFP_MASK | PB8_MFP_EXT_INT0)
N
N/*!<Enable GPC12->EXT0 */
N#define MFP_EXT_INT0_TO_PC12()	(GCR->PC_H_MFP = GCR->PC_H_MFP & ~PC12_MFP_MASK | PC12_MFP_EXT_INT0)
N
N/*!<Enable GPF0->EXT0 */
N#define MFP_EXT_INT0_TO_PF0()	(GCR->PF_L_MFP = GCR->PF_L_MFP & ~PF0_MFP_MASK | PF0_MFP_EXT_INT0)
N
N/*!<Enable GPB15->EXT1 */
N#define MFP_EXT_INT1_TO_PB15()	(GCR->PB_H_MFP = GCR->PB_H_MFP & ~PB15_MFP_MASK | PB15_MFP_EXT_INT1)
N
N/*!<Enable GPC13->EXT1 */
N#define MFP_EXT_INT1_TO_PC13()	(GCR->PC_H_MFP = GCR->PC_H_MFP & ~PC13_MFP_MASK | PC13_MFP_EXT_INT1)
N
N/*!<Enable GPF1->EXT1 */
N#define MFP_EXT_INT1_TO_PF1()	(GCR->PF_L_MFP = GCR->PF_L_MFP & ~PF1_MFP_MASK | PF1_MFP_EXT_INT1)
N
N/*!<Enable SPI0: GPB10->SS1, GPC0->SS0; GPC1->CLK, GPC2->MISO0, GPC3->MOSI0, GPC4->MISO1, GPC5->MOSI1 */
N#define MFP_SPI0_TO_PORTC1(){ \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB10_MFP_MASK|PB10_MFP_SPI0_SS1; \
N								GCR->PC_L_MFP = GCR->PC_L_MFP & ~0x00ffffff|0x00111111; \
N							}
X#define MFP_SPI0_TO_PORTC1(){ 								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB10_MFP_MASK|PB10_MFP_SPI0_SS1; 								GCR->PC_L_MFP = GCR->PC_L_MFP & ~0x00ffffff|0x00111111; 							}
N
N/*!<Enable SPI0: GPB10->MOSI0, GPB11->MISO0, GPC0->SS0; GPC1->CLK, GPC4->MISO1, GPC5->MOSI1, NO SS1 */
N#define MFP_SPI0_TO_PORTC2(){ \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~(PB10_MFP_MASK|PB11_MFP_MASK)|(PB10_MFP_SPI0_MOSI0|PB11_MFP_SPI0_MISO0); \
N								GCR->PC_L_MFP = GCR->PC_L_MFP & ~0x00ff00ff|0x00110011; \
N							}
X#define MFP_SPI0_TO_PORTC2(){ 								GCR->PB_H_MFP = GCR->PB_H_MFP &~(PB10_MFP_MASK|PB11_MFP_MASK)|(PB10_MFP_SPI0_MOSI0|PB11_MFP_SPI0_MISO0); 								GCR->PC_L_MFP = GCR->PC_L_MFP & ~0x00ff00ff|0x00110011; 							}
N
N/*!<Enable SPI0: GPB10->SS1, GPE1->SS0; GPE2->CLK, GPE3->MISO0, GPE4->MOSI0, GPC4->MISO1, GPC5->MOSI1 */
N#define MFP_SPI0_TO_PORTE()	{ \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB10_MFP_MASK|PB10_MFP_SPI0_SS1; \
N								GCR->PC_L_MFP = GCR->PC_L_MFP & ~0x00ff0000|0x00110000; \
N								GCR->PE_L_MFP = GCR->PE_L_MFP & ~0x000ffff0|0x00066660; \
N							}
X#define MFP_SPI0_TO_PORTE()	{ 								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB10_MFP_MASK|PB10_MFP_SPI0_SS1; 								GCR->PC_L_MFP = GCR->PC_L_MFP & ~0x00ff0000|0x00110000; 								GCR->PE_L_MFP = GCR->PE_L_MFP & ~0x000ffff0|0x00066660; 							}
N
N/*!<Enable SPI1: GPB0->MOSI0, GPB1->MISO0; GPB2->CLK, GPB3->SS0, GPB9->SS1, GPC12->MISO1, GPC13->MOSI1 */
N#define MFP_SPI1_TO_PORTB()	{ \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB9_MFP_MASK|PB9_MFP_SPI1_SS1; \
N								GCR->PB_L_MFP = GCR->PB_L_MFP & ~0x0000ffff|0x00003333; \
N								GCR->PC_H_MFP = GCR->PC_H_MFP & ~0x00ff0000|0x00110000; \
N							}
X#define MFP_SPI1_TO_PORTB()	{ 								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB9_MFP_MASK|PB9_MFP_SPI1_SS1; 								GCR->PB_L_MFP = GCR->PB_L_MFP & ~0x0000ffff|0x00003333; 								GCR->PC_H_MFP = GCR->PC_H_MFP & ~0x00ff0000|0x00110000; 							}
N
N/*!<Enable SPI1: GPB0->MOSI0, GPB1->MISO0; GPB2->CLK, GPB3->SS0 */
N#define MFP_SPI1_SS0_TO_PORTB()	{ \
N								GCR->PB_L_MFP = GCR->PB_L_MFP & ~0x0000ffff|0x00003333; \
N							}
X#define MFP_SPI1_SS0_TO_PORTB()	{ 								GCR->PB_L_MFP = GCR->PB_L_MFP & ~0x0000ffff|0x00003333; 							}
N
N/*!<Enable SPI1: GPB9->SS1, GPC8->SS0; GPC9->CLK, GPC10->MISO0, GPC11->MOSI0, GPC12->MISO1, GPC13->MOSI1 */
N#define MFP_SPI1_TO_PORTC()	{ \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB9_MFP_MASK|PB9_MFP_SPI1_SS1; \
N								GCR->PC_H_MFP = GCR->PC_L_MFP & ~0x00ffffff|0x00111111; \
N							}
X#define MFP_SPI1_TO_PORTC()	{ 								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB9_MFP_MASK|PB9_MFP_SPI1_SS1; 								GCR->PC_H_MFP = GCR->PC_L_MFP & ~0x00ffffff|0x00111111; 							}
N
N/*!<Enable SPI2: GPA9->CLK, GPA8->SS0, GPA10->MISO0, GPA11->MOSI0, GPD4->MISO1, GPD5->MOSI1, GPB14->SS1 */
N#define MFP_SPI2_TO_PORTA()	{ \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB14_MFP_MASK|PB14_MFP_SPI2_SS1; \
N								GCR->PD_L_MFP = GCR->PD_L_MFP & ~0x00ff0000|0x00330000; \
N								GCR->PA_H_MFP = GCR->PA_H_MFP & ~0x0000ffff|0x00004444; \
N							}
X#define MFP_SPI2_TO_PORTA()	{ 								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB14_MFP_MASK|PB14_MFP_SPI2_SS1; 								GCR->PD_L_MFP = GCR->PD_L_MFP & ~0x00ff0000|0x00330000; 								GCR->PA_H_MFP = GCR->PA_H_MFP & ~0x0000ffff|0x00004444; 							}
N
N/*!<Enable SPI2: GPB5->CLK, GPB4->SS0, GPB6->MISO0, GPB7->MOSI0, GPD4->MISO1, GPD5->MOSI1, GPB14->SS1 */
N#define MFP_SPI2_TO_PORTB()	{ \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB14_MFP_MASK|PB14_MFP_SPI2_SS1; \
N								GCR->PD_L_MFP = GCR->PD_L_MFP & ~0x00ff0000|0x00330000; \
N								GCR->PB_L_MFP = GCR->PB_L_MFP & ~0xffff0000|0x44440000; \
N							}
X#define MFP_SPI2_TO_PORTB()	{ 								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB14_MFP_MASK|PB14_MFP_SPI2_SS1; 								GCR->PD_L_MFP = GCR->PD_L_MFP & ~0x00ff0000|0x00330000; 								GCR->PB_L_MFP = GCR->PB_L_MFP & ~0xffff0000|0x44440000; 							}
N
N/*!<Enable SPI2: GPD1->CLK, GPD0->SS0, GPD2->MISO0, GPD3->MOSI0, GPD4->MISO1, GPD5->MOSI1, GPB14->SS1 */
N#define MFP_SPI2_TO_PORTD()	{ \
N								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB14_MFP_MASK|PB14_MFP_SPI2_SS1; \
N								GCR->PD_L_MFP = GCR->PD_L_MFP & ~0x00ffffff|0x00333333; \
N							}
X#define MFP_SPI2_TO_PORTD()	{ 								GCR->PB_H_MFP = GCR->PB_H_MFP &~PB14_MFP_MASK|PB14_MFP_SPI2_SS1; 								GCR->PD_L_MFP = GCR->PD_L_MFP & ~0x00ffffff|0x00333333; 							}
N
N/*!<Enable LCD for 100/128-Pin Package */
N#define MFP_LCD_TYPEA()	{ \
N							GCR->PA_L_MFP |= 0x77770000;	/* seg 36 ~ 39 */\
N							GCR->PA_H_MFP |= 0x7777;		/* seg 20 ~ 23 */\
N							GCR->PB_L_MFP = 0x77777777;		/* seg 10 ~ 13, 4 ~ 7 */\
N							GCR->PB_H_MFP = 0x77777777;		/* LCD V1 ~ V3, seg 30 ~ 31, 24 ~ 26 */\
N							GCR->PC_L_MFP |= 0x777777;		/* LCD COM3 ~ COM0, DH1/DH2 */\
N							GCR->PC_H_MFP |= 0x77000000;	/* seg 32 ~ 33 */\
N							GCR->PD_L_MFP |= 0x77770000;	/* seg 2 ~ 3, 34 ~ 35 */\
N							GCR->PD_H_MFP = 0x77777777;		/* seg 0 ~ 1, 14 ~ 19 */\
N							GCR->PE_L_MFP |= 0x70000000;	/* seg 8 */\
N							GCR->PE_H_MFP |= 0x77700007;	/* seg 9, 27 ~ 29 */\
N							GPIOB->OFFD |= 0xE000000;	/* V1, V2 and V3 */\
N							GPIOC->OFFD |= 0x30000;	/* DH1 and DH2 */\
N							GPIOC->OFFD |= 0x3C0000;	/* COM0~3 */\
N							GPIOA->OFFD |= 0x0FF00000;	/* SEG0~39 */\
N							GPIOB->OFFD |= 0xF1FF0000;\
N							GPIOC->OFFD |= 0xC0000000;\
N							GPIOD->OFFD |= 0xFFF00000;\
N							GPIOE->OFFD |= 0xE1800000;\
N						}
X#define MFP_LCD_TYPEA()	{ 							GCR->PA_L_MFP |= 0x77770000;	 							GCR->PA_H_MFP |= 0x7777;		 							GCR->PB_L_MFP = 0x77777777;		 							GCR->PB_H_MFP = 0x77777777;		 							GCR->PC_L_MFP |= 0x777777;		 							GCR->PC_H_MFP |= 0x77000000;	 							GCR->PD_L_MFP |= 0x77770000;	 							GCR->PD_H_MFP = 0x77777777;		 							GCR->PE_L_MFP |= 0x70000000;	 							GCR->PE_H_MFP |= 0x77700007;	 							GPIOB->OFFD |= 0xE000000;	 							GPIOC->OFFD |= 0x30000;	 							GPIOC->OFFD |= 0x3C0000;	 							GPIOA->OFFD |= 0x0FF00000;	 							GPIOB->OFFD |= 0xF1FF0000;							GPIOC->OFFD |= 0xC0000000;							GPIOD->OFFD |= 0xFFF00000;							GPIOE->OFFD |= 0xE1800000;						}
N
N/*!<Enable LCD for 64-Pin Package */
N#define MFP_LCD_TYPEB()	{ \
N							GCR->PA_L_MFP |= 0x77777700;	/* seg 18 ~ 23 */\
N							GCR->PA_H_MFP = 0x77777777;		/* seg 6 ~ 9, 24 ~ 27 */\
N							GCR->PB_L_MFP = 0x77777777;		/* COM2, COM3, seg 0 ~ 5 */\
N							GCR->PB_H_MFP = 0x77777777;		/* LCD V1 ~ V3, seg 10 ~ 14 */\
N							GCR->PC_L_MFP |= 0x70007777;	/* LCD COM1 ~ COM0, DH1/DH2, seg 17 */\
N							GCR->PC_H_MFP |= 0x77007777;	/* seg 28 ~ 31, 15 ~ 16 */\
N							GPIOB->OFFD |= 0xE000000;	/* V1, V2 and V3 */\
N							GPIOC->OFFD |= 0x30000;	/* DH1 and DH2 */\
N							GPIOC->OFFD |= 0xC0000;	/* COM0~3 */\
N							GPIOB->OFFD |= 0xC0000;\
N							GPIOA->OFFD |= 0xFFFC0000;	/* SEG0~39 */\
N							GPIOB->OFFD |= 0xF1F30000;\
N							GPIOC->OFFD |= 0xCF800000;\
N						}
X#define MFP_LCD_TYPEB()	{ 							GCR->PA_L_MFP |= 0x77777700;	 							GCR->PA_H_MFP = 0x77777777;		 							GCR->PB_L_MFP = 0x77777777;		 							GCR->PB_H_MFP = 0x77777777;		 							GCR->PC_L_MFP |= 0x70007777;	 							GCR->PC_H_MFP |= 0x77007777;	 							GPIOB->OFFD |= 0xE000000;	 							GPIOC->OFFD |= 0x30000;	 							GPIOC->OFFD |= 0xC0000;	 							GPIOB->OFFD |= 0xC0000;							GPIOA->OFFD |= 0xFFFC0000;	 							GPIOB->OFFD |= 0xF1F30000;							GPIOC->OFFD |= 0xCF800000;						}
N
N/*@}*/ /* end of group NANO1xx_Exported_Macros */
N
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup NANO1xx_legacy_Constants NANO1xx Legacy Constants
N  NANO1xx Legacy Constants
N  @{
N*/
Ntypedef volatile unsigned char  vu8;
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
N#define M8(adr)  (*((vu8  *) (adr)))
N#define M16(adr) (*((vu16 *) (adr)))
N#define M32(adr) (*((vu32 *) (adr)))
N
N#define outpw(port,value)	*((volatile unsigned int *)(port))=value
N#define inpw(port)			(*((volatile unsigned int *)(port)))
N#define outpb(port,value)	*((volatile unsigned char *)(port))=value
N#define inpb(port)			(*((volatile unsigned char *)(port)))
N#define outps(port,value)	*((volatile unsigned short *)(port))=value
N#define inps(port)			(*((volatile unsigned short *)(port)))
N
N#define outp32(port,value)	*((volatile unsigned int *)(port))=value
N#define inp32(port)			(*((volatile unsigned int *)(port)))
N#define outp8(port,value)	*((volatile unsigned char *)(port))=value
N#define inp8(port)			(*((volatile unsigned char *)(port)))
N#define outp16(port,value)	*((volatile unsigned short *)(port))=value
N#define inp16(port)			(*((volatile unsigned short *)(port)))
N
N
N#ifndef E_SUCCESS
N#define E_SUCCESS 	(0)
N#endif
N#ifndef NULL
S#define NULL        (0)
N#endif
N
N#define TRUE	   	(1)
N#define FALSE   	(0)
N
N#define ENABLE     (1)
N#define DISABLE    (0)
N
N/* Define one bit mask */
N#define BIT0	(0x00000001)
N#define BIT1	(0x00000002)
N#define BIT2	(0x00000004)
N#define BIT3	(0x00000008)
N#define BIT4	(0x00000010)
N#define BIT5	(0x00000020)
N#define BIT6	(0x00000040)
N#define BIT7	(0x00000080)
N#define BIT8	(0x00000100)
N#define BIT9	(0x00000200)
N#define BIT10	(0x00000400)
N#define BIT11	(0x00000800)
N#define BIT12	(0x00001000)
N#define BIT13	(0x00002000)
N#define BIT14	(0x00004000)
N#define BIT15	(0x00008000)
N#define BIT16	(0x00010000)
N#define BIT17	(0x00020000)
N#define BIT18	(0x00040000)
N#define BIT19	(0x00080000)
N#define BIT20	(0x00100000)
N#define BIT21	(0x00200000)
N#define BIT22	(0x00400000)
N#define BIT23	(0x00800000)
N#define BIT24	(0x01000000)
N#define BIT25	(0x02000000)
N#define BIT26	(0x04000000)
N#define BIT27	(0x08000000)
N#define BIT28	(0x10000000)
N#define BIT29	(0x20000000)
N#define BIT30	(0x40000000)
N#define BIT31	(0x80000000)
N
N/*@}*/ /* end of group NANO1xx_legacy_Constants */
N
N
N/*@}*/ /* end of group NANO1xx_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* __NANO1xx_H */
N
N/*** (C) COPYRIGHT 2012 Nuvoton Technology Corp. ***/
L 16 ".\Include\nano1xx_sys.h" 2
N
N
N/** @addtogroup NANO1xx_Device_Driver NANO1xx Device Driver
N  @{
N*/
N
N/** @addtogroup NANO1xx_SYS_Driver SYS Driver
N  @{
N*/
N
N
N/** @addtogroup NANO1xx_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* Constant definitions                                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N/* Chip clock source constants */
N#define CHIP_CLOCKS_ALL_ENABLE	(CLK_PWRCTL_HXT_EN | CLK_PWRCTL_LXT_EN | CLK_PWRCTL_HIRC_EN | CLK_PWRCTL_LIRC_EN)
N
N/// @cond
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define parameter checking                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CHECK_HCLK_SOURCE(HclkSel)			((HclkSel == 0) || \
N											 (HclkSel == 1)	|| \
N											 (HclkSel == 2)	|| \
N											 (HclkSel == 3)	|| \
N											 (HclkSel == 7))						 
X#define CHECK_HCLK_SOURCE(HclkSel)			((HclkSel == 0) || 											 (HclkSel == 1)	|| 											 (HclkSel == 2)	|| 											 (HclkSel == 3)	|| 											 (HclkSel == 7))						 
N#define CHECK_PLLIN_CLK(PllInClk)	        ((PllInClk == E_SYS_PLLIN_4M)  || \
N											 (PllInClk == E_SYS_PLLIN_8M)  || \
N											 (PllInClk == E_SYS_PLLIN_12M) || \
N											 (PllInClk == E_SYS_PLLIN_15M) || \
N											 (PllInClk == E_SYS_PLLIN_24M))
X#define CHECK_PLLIN_CLK(PllInClk)	        ((PllInClk == E_SYS_PLLIN_4M)  || 											 (PllInClk == E_SYS_PLLIN_8M)  || 											 (PllInClk == E_SYS_PLLIN_12M) || 											 (PllInClk == E_SYS_PLLIN_15M) || 											 (PllInClk == E_SYS_PLLIN_24M))
N#define CHECK_PLLOUT_CLK(PllOutClk)	        ((PllOutClk == E_SYS_PLLOUT_45M)  || \
N											 (PllOutClk == E_SYS_PLLOUT_48M)  || \
N											 (PllOutClk == E_SYS_PLLOUT_90M)  || \
N											 (PllOutClk == E_SYS_PLLOUT_96M)  || \
N											 (PllOutClk == E_SYS_PLLOUT_120M) || \
N											 (PllOutClk == E_SYS_PLLOUT_128M))
X#define CHECK_PLLOUT_CLK(PllOutClk)	        ((PllOutClk == E_SYS_PLLOUT_45M)  || 											 (PllOutClk == E_SYS_PLLOUT_48M)  || 											 (PllOutClk == E_SYS_PLLOUT_90M)  || 											 (PllOutClk == E_SYS_PLLOUT_96M)  || 											 (PllOutClk == E_SYS_PLLOUT_120M) || 											 (PllOutClk == E_SYS_PLLOUT_128M))
N#define CHECK_CLK_CONFIG(ClkCfg)			 (ClkCfg != NULL)
N
N/// @endcond
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLL Clock In Freq.		     				                                          		           */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N	E_SYS_PLLIN_4M, 
N	E_SYS_PLLIN_8M, 
N	E_SYS_PLLIN_12M, 
N	E_SYS_PLLIN_15M, 
N	E_SYS_PLLIN_24M
N} E_SYS_PLLIN_CLK;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLL Clock Out Freq.		     				                                          		           */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N	E_SYS_PLLOUT_45M, 
N	E_SYS_PLLOUT_48M, 
N	E_SYS_PLLOUT_90M, 
N	E_SYS_PLLOUT_96M, 
N	E_SYS_PLLOUT_120M,
N	E_SYS_PLLOUT_128M,
N} E_SYS_PLLOUT_CLK;
N
N
N/*@}*/ /* end of group NANO1xx_SYS_EXPORTED_CONSTANTS */
N
N
N
N/** @addtogroup NANO1xx_SYS_EXPORTED_STRUCTS SYS Exported Structs
N  @{
N*/
N
N/*
N * Struture to store HCLK (CPU) and PLL clock configurations
N */
Ntypedef struct {
N    uint32_t u32ChipClkEn;	/* CLK_PWRCTL_XXX_EN, where XXX could be HXT, LXT, HIRC or LIRC */
N	uint32_t u32PLLClkSrc;	/* CLK_PLLCTL_PLLSRC_HIRC or CLK_PLLCTL_PLLSRC_HXT */
N    uint8_t  u8PLLEnable;   /* 1 to enable PLL, 0 to disable PLL */
N	uint8_t  ePLLInFreq;    /* E_SYS_PLLIN_CLK */
N    uint8_t  ePLLOutFreq;   /* E_SYS_PLLOUT_CLK */
N	uint8_t  RESERVED0[1];
N    uint32_t u32HClkSrc; 	/* CLK_CLKSEL0_HCLK_XXX, where XXX could be HXT, LXT, PLL, HIRC or LIRC */
N    uint32_t u32HClkDiv;	/* 0 ~ 15 */	
N	uint32_t u32AHBClkEn;	/* CLK_AHBCLK_XXX_EN, where XXX could be GPIO, DMA, ISP, EBI, SRAM and TICK */
N    uint32_t u32APBClkEn; 	/* CLK_APBCLK_XXX_EN, where XXX cound be WDT, RTC, TMR0~3, FDIV, SC0~2, I2C0~1, SPI0~2, UART0~1, PWM0_CH01 */
N	                        /*                                       PWM0_CH23, PWM1_CH01, PWM1_CH23, TK, DAC, LCD, USBD, ADC, I2S */
N} S_SYS_CHIP_CLKCFG;
N
N/*@}*/ /* end of group NANO1xx_SYS_EXPORTED_STRUCTS */
N
N
N/** @addtogroup NANO1xx_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define SYS inline functions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N  * @brief  Read Product ID
N  * @param  None
N  * @return Product ID
N  */
Nstatic __INLINE uint32_t SYS_ReadProductID(void)
Xstatic __inline uint32_t SYS_ReadProductID(void)
N{	
N	return GCR->PDID;
X	return ((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->PDID;
N}
N
N
N/**
N  * @brief  Unlock protected registers
N  * @param  None
N  * @return Lock status
N  * @retval 1 unlock
N  * @retval 0 still lock
N  */
Nstatic __INLINE int32_t SYS_UnlockProtectedReg(void)
Xstatic __inline int32_t SYS_UnlockProtectedReg(void)
N{
N	uint32_t lockbit;
N
N	GCR->RegLockAddr = 0x59;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RegLockAddr = 0x59;
N	GCR->RegLockAddr = 0x16;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RegLockAddr = 0x16;
N	GCR->RegLockAddr = 0x88;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RegLockAddr = 0x88;
N
N	lockbit = GCR->RegLockAddr & 0x01;
X	lockbit = ((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RegLockAddr & 0x01;
N	return (lockbit);
N} 
N 
N
N/**
N  * @brief  Lock protected registers
N  * @param  None
N  * @return Lock status
N  * @retval 1 unlock
N  * @retval 0 lock
N  */
Nstatic __INLINE int32_t SYS_LockProtectedReg(void)
Xstatic __inline int32_t SYS_LockProtectedReg(void)
N{
N	uint32_t lockbit;
N
N	GCR->RegLockAddr = 0x00;	
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RegLockAddr = 0x00;	
N
N	lockbit = GCR->RegLockAddr & 0x01;
X	lockbit = ((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RegLockAddr & 0x01;
N	return (lockbit);
N}
N
N
N/**
N  * @brief  Check the status of protected registers
N  * @param  None
N  * @return Lock status
N  * @retval 1 unlock
N  * @retval 0 lock
N  */
Nstatic __INLINE int32_t SYS_IsProtectedRegLocked(void)
Xstatic __inline int32_t SYS_IsProtectedRegLocked(void)
N{
N	return GCR->RegLockAddr & 0x01;
X	return ((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RegLockAddr & 0x01;
N}
N
N
N/**
N  * @brief  Read reset source from last operation
N  * @param  None
N  * @return Reset source value
N  */
Nstatic __INLINE uint32_t SYS_GetResetSource(void)
Xstatic __inline uint32_t SYS_GetResetSource(void)
N{
N	return GCR->RST_SRC;
X	return ((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RST_SRC;
N}
N
N
N/**
N  * @brief  Clear reset source. 
N  * @param  u32Src The reset source will be cleared if the corresponding bit is set to 1.
N  * @return None.
N  */
Nstatic __INLINE void SYS_ClearResetSource(uint32_t u32Src)
Xstatic __inline void SYS_ClearResetSource(uint32_t u32Src)
N{
N	GCR->RST_SRC = u32Src;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->RST_SRC = u32Src;
N}
N
N
N/**
N  * @brief  Reset proteced peripheral functions. These functions include EBI, PDMA, CPU and Chip. 
N  * @param  u32RstFlag GCR_IPRSTCTL1_XXX, where XXX could be CHIP, CPU,DMA or EBI.
N  * @return None.
N  */
Nstatic __INLINE void SYS_ResetProtectIP(uint32_t u32RstFlag)
Xstatic __inline void SYS_ResetProtectIP(uint32_t u32RstFlag)
N{	
N	
N	GCR->IPRST_CTL1 |= u32RstFlag;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->IPRST_CTL1 |= u32RstFlag;
N	GCR->IPRST_CTL1 &= ~u32RstFlag;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->IPRST_CTL1 &= ~u32RstFlag;
N}
N
N
N/**
N  * @brief  Reset selected peripheral functions.
N  * @param  u32RstFlag The combination of GCR_IPRSTCTL2_XXX, where XXX could be GPIO, TMR0~3, SC0~2, I2C0~1, SPI0~2, UART0~1
N  *                                                                             PWM0~1, TK, DAC, LCD, USBD, ADC, I2S.
N  * @return None.
N  */
Nstatic __INLINE void SYS_ResetIP(uint32_t u32RstFlag)
Xstatic __inline void SYS_ResetIP(uint32_t u32RstFlag)
N{	
N	GCR->IPRST_CTL2 |= u32RstFlag;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->IPRST_CTL2 |= u32RstFlag;
N	GCR->IPRST_CTL2 &= ~u32RstFlag;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->IPRST_CTL2 &= ~u32RstFlag;
N}
N
N
N
N/**
N  * @brief  Enable power on reset (POR) control. 
N  * @param  None.
N  * @return None.
N  */
Nstatic __INLINE void SYS_EnablePOR(void)
Xstatic __inline void SYS_EnablePOR(void)
N{
N	GCR->PORCTL = 0;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->PORCTL = 0;
N}
N
N
N/**
N  * @brief  Disable power on reset (POR) control. 
N  * @param  None.
N  * @return None.
N  */
Nstatic __INLINE void SYS_DisablePOR(void)
Xstatic __inline void SYS_DisablePOR(void)
N{
N	GCR->PORCTL = 0x5AA5;
X	((GCR_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00000))->PORCTL = 0x5AA5;
N}
N
N
N/**
N  * @brief  Enable or Disable AHB peripheral function clock. The functions include Tick, SRAM, EBI, ISP, DMA and GPIO
N  * @param  u32IpFuncs The corresponding bits will be set to 1 for selected peripheral functions.
N  * @param  i32Enable This value is 1 to enable clock, and 0 for disable.
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetIPClock_1(uint32_t u32IpFuncs, uint32_t i32Enable)
Xstatic __inline void SYS_SetIPClock_1(uint32_t u32IpFuncs, uint32_t i32Enable)
N{	
N	/* Tick, SRAM, EBI, ISP, DMA and GPIO */  
N	(i32Enable == 1) ? (CLK->AHBCLK |= u32IpFuncs) : (CLK->AHBCLK &= ~u32IpFuncs);	
X	(i32Enable == 1) ? (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->AHBCLK |= u32IpFuncs) : (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->AHBCLK &= ~u32IpFuncs);	
N
N}
N
N
N/**
N  * @brief  Enable or Disable APB peripheral function clock except for WDT. 
N  * @param  u32IpFuncs The corresponding bits will be set to 1 for the selected peripheral functions.
N  * @param  i32Enable This value is 1 to enable clock, and 0 for disable.
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetIPClock_2(uint32_t u32IpFuncs, uint32_t i32Enable)
Xstatic __inline void SYS_SetIPClock_2(uint32_t u32IpFuncs, uint32_t i32Enable)
N{	
N    /* The APB peripheral functions except for WDT */
N	(i32Enable == 1) ? (CLK->APBCLK |= u32IpFuncs) : (CLK->APBCLK &= ~u32IpFuncs);
X	(i32Enable == 1) ? (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->APBCLK |= u32IpFuncs) : (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->APBCLK &= ~u32IpFuncs);
N}
N
N
N/**
N  * @brief  Enable or Disable Watchdog Timer clock. 
N  * @param  i32Enable This value is 1 to enable clock, and 0 for disable.
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetWDTClock(uint32_t i32Enable)
Xstatic __inline void SYS_SetWDTClock(uint32_t i32Enable)
N{	
N	(i32Enable == 1) ? (CLK->APBCLK |= CLK_APBCLK_WDT_EN) : (CLK->APBCLK &= ~CLK_APBCLK_WDT_EN);		
X	(i32Enable == 1) ? (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->APBCLK |= ((uint32_t)0x00000001)) : (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->APBCLK &= ~((uint32_t)0x00000001));		
N}
N
N
N/**
N  * @brief  Select clock source for peripheral functions : UART, ADC, PWM0_CH01, PWM0_CH23, Timer 0, Timer 1, TK and LCD. 
N  * @param  u32ClkMask The mask filed used to chnage clock source. Please refer nano1xx.h for possible values : CLK_CLKSEL1_XXX_MASK.
N  * @param  u32ClkSrc The selected clock source. 
N  * @return None.
N  */
Nstatic __INLINE void SYS_SelectIPClockSource_1(uint32_t u32ClkMask, uint32_t u32ClkSrc)
Xstatic __inline void SYS_SelectIPClockSource_1(uint32_t u32ClkMask, uint32_t u32ClkSrc)
N{
N 	CLK->CLKSEL1 = (CLK->CLKSEL1 & (~u32ClkMask)) | u32ClkSrc;
X 	((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSEL1 = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSEL1 & (~u32ClkMask)) | u32ClkSrc;
N}
N
N
N/**
N  * @brief  Select clock source for peripheral functions : FRQDIV, PWM1_CH01, PWM2_CH23, Timer 2, Timer 3, I2S, SC, SPI 0, SPI 1, SPI 2. 
N  * @param  u32ClkMask The mask filed used to chnage clock source. Please refer nano1xx.h for possible values : CLK_CLKSEL1_XXX_MASK.
N  * @param  u32ClkSrc The selected clock source.
N  * @return None.
N  */
Nstatic __INLINE void SYS_SelectIPClockSource_2(uint32_t u32ClkMask, uint32_t u32ClkSrc)
Xstatic __inline void SYS_SelectIPClockSource_2(uint32_t u32ClkMask, uint32_t u32ClkSrc)
N{
N	CLK->CLKSEL2 = (CLK->CLKSEL2 & (~u32ClkMask)) | u32ClkSrc;
X	((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSEL2 = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSEL2 & (~u32ClkMask)) | u32ClkSrc;
N}
N
N
N/**
N  * @brief  Select clock divider for HCLK 
N  * @param  u32DivValue The clock divider, HCLK_CLK_DIVIDER(x) where x is 0 ~ 15. 
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetHCLKDivider(int32_t u32DivValue)
Xstatic __inline void SYS_SetHCLKDivider(int32_t u32DivValue)
N{
N    CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLK_MASK)) | u32DivValue;
X    ((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV0 = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV0 & (~((uint32_t)0x0000000F))) | u32DivValue;
N
N	SystemCoreClockUpdate();
N}
N
N
N
N/**
N  * @brief  Select clock divider for peripheral functions : USB, I2S, ADC, TK and SC0. 
N  * @param  u32ClkDivMask The mask filed used to chnage clock divider. Please refer nano1xx.h for possible values : CLK_CLKDIV0_XXX_MASK.
N  * @param  u32DivValue The clock divider. XXX_CLK_DIVIDER(y) where XXX can be USB, I2S, ADC, TK or SC0. The y is 0 ~ 255 for ADC, and 0 ~ 15 for others.
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetClockDivider_0(uint32_t u32ClkDivMask, uint32_t u32DivValue)
Xstatic __inline void SYS_SetClockDivider_0(uint32_t u32ClkDivMask, uint32_t u32DivValue)
N{
N    CLK->CLKDIV0 = (CLK->CLKDIV0 & (~u32ClkDivMask)) | u32DivValue;
X    ((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV0 = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV0 & (~u32ClkDivMask)) | u32DivValue;
N}
N
N
N/**
N  * @brief  Select clock divider for peripheral functions : SC1 and SC2. 
N  * @param  u32ClkDivMask The mask filed used to chnage clock divider. Please refer nano1xx.h for possible values : CLK_CLKDIV0_XXX_MASK.
N  * @param  u32DivValue The clock divider. XXX_CLK_DIVIDER(y) where XXX can be SC1 or SC2. The y is 0 ~ 15
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetClockDivider_1(uint32_t u32ClkDivMask, uint32_t u32DivValue)
Xstatic __inline void SYS_SetClockDivider_1(uint32_t u32ClkDivMask, uint32_t u32DivValue)
N{
N    CLK->CLKDIV1 = (CLK->CLKDIV1 & (~u32ClkDivMask)) | u32DivValue;
X    ((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV1 = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV1 & (~u32ClkDivMask)) | u32DivValue;
N}
N
N
N
N/**
N  * @brief  Enable or disable internal oscillators and external crystals. 
N  * @param  u32OscSrc The combination of CLK_PWRCTL_HXT_EN, CLK_PWRCTL_LXT_EN, CLK_PWRCTL_HIRC_EN and CLK_PWRCTL_LIRC_EN
N  * @param  u32Enable This value is 1 to enable clock, and 0 for disable. 
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetChipClockSrc(uint32_t u32OscSrc, uint32_t u32Enable)
Xstatic __inline void SYS_SetChipClockSrc(uint32_t u32OscSrc, uint32_t u32Enable)
N{	
N	(u32Enable == 1) ? (CLK->PWRCTL |= u32OscSrc) : (CLK->PWRCTL &= ~u32OscSrc);
X	(u32Enable == 1) ? (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PWRCTL |= u32OscSrc) : (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PWRCTL &= ~u32OscSrc);
N
N}
N
N
N/**
N  * @brief  Check the status of selected chip clock sources 
N  * @param  u32ChipClkSrc The combination of CLK_CLKSTATUS_HXT_STB, CLK_CLKSTATUS_LXT_STB, CLK_CLKSTATUS_PLL_STB, 
N  *                                       CLK_CLKSTATUS_LIRC_STB, CLK_CLKSTATUS_HIRC_STB
N  * @return clock status
N  * @retval -1 one or more clock sources are unstable or disabled.
N  * @retval 0 all selected clock sources are stable
N  */
Nstatic __INLINE int32_t SYS_CheckChipClockSrc(uint32_t u32ChipClkSrc)
Xstatic __inline int32_t SYS_CheckChipClockSrc(uint32_t u32ChipClkSrc)
N{
N	if ((CLK->CLKSTATUS & u32ChipClkSrc) == u32ChipClkSrc)
X	if ((((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSTATUS & u32ChipClkSrc) == u32ChipClkSrc)
N		return 0;
N	else
N		return -1;
N}
N
N
N/**
N  * @brief  Select PLL clock source. 
N  * @param  u32PLLSrc The PLL clock source, either CLK_PLLCTL_PLLSRC_HIRC or CLK_PLLCTL_PLLSRC_HXT.
N  * @return None.
N  */
Nstatic __INLINE void SYS_SelectPLLSource(uint32_t u32PLLSrc)
Xstatic __inline void SYS_SelectPLLSource(uint32_t u32PLLSrc)
N{
N	CLK->PLLCTL = (CLK->PLLCTL & ~CLK_PLLCTL_PLLSRC_MASK) | u32PLLSrc;
X	((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PLLCTL = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PLLCTL & ~((uint32_t)0x00020000)) | u32PLLSrc;
N}
N
N
N/**
N  * @brief  Set PLL operate in power down or normal mode. 
N  * @param  u32PowerDown 1 for power down mode while 0 for normal mode.
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetPLLMode(uint32_t u32PowerDown)
Xstatic __inline void SYS_SetPLLMode(uint32_t u32PowerDown)
N{
N	(u32PowerDown == 1) ? (CLK->PLLCTL |= CLK_PLLCTL_PD) : (CLK->PLLCTL &= ~CLK_PLLCTL_PD);
X	(u32PowerDown == 1) ? (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PLLCTL |= ((uint32_t)0x00010000)) : (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PLLCTL &= ~((uint32_t)0x00010000));
N}
N
N
N/**
N  * @brief  Set PLL output frequency. 
N  * @param  u32PllClkSrc The clock source, either CLK_PLLCTL_PLLSRC_HIRC or CLK_PLLCTL_PLLSRC_HXT.
N  * @param  u32PllFreq The output frequency of PLL.	The supported value is defined in nano1xx_sys.h
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetPLLFreq(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
Xstatic __inline void SYS_SetPLLFreq(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
N{
N	CLK->PLLCTL = (u32PllClkSrc | u32PllFreq);
X	((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PLLCTL = (u32PllClkSrc | u32PllFreq);
N}
N
N
N/**
N  * @brief  Enable frequency clock output and set its divider value. The output frequency = Fin/2^(N+1), 
N  *         Fin is the input clock frequency, N is 4-bit value 
N  * @param  i32Flag 1 for Enable while 0 for Disable.
N  * @param  u8Divider The divider of output frequency (0~15)
N  * @return None.
N  */
Nstatic __INLINE void SYS_SetFreqDividerOutput(int32_t i32Flag, uint8_t u8Divider)
Xstatic __inline void SYS_SetFreqDividerOutput(int32_t i32Flag, uint8_t u8Divider)
N{
N	if (i32Flag)
N		CLK->FRQDIV = CLK_FRQDIV_EN | u8Divider;
X		((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->FRQDIV = ((uint32_t)0x00000010) | u8Divider;
N	else		
N		CLK->FRQDIV &= ~CLK_FRQDIV_EN; 		
X		((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->FRQDIV &= ~((uint32_t)0x00000010); 		
N	   
N	SYS_SetIPClock_2(CLK_APBCLK_FDIV_EN, i32Flag);
X	SYS_SetIPClock_2(((uint32_t)0x00000040), i32Flag);
N}
N
N
N/**
N  * @brief  Get the external clock frequency
N  * @param None. 
N  * @return __XTAL.
N  */
Nstatic __INLINE int32_t SYS_GetExtClockFreq()
Xstatic __inline int32_t SYS_GetExtClockFreq()
N{
N	return __XTAL;
X	return (12000000UL);
N}
N
N
N/**
N  * @brief  Check the status of PLL clock output
N  * @param None. 
N  * @return PLL clock status
N  * @retval -1 PLL output clock is unstable or disabled.
N  * @retval 0 PLL output clock is stable
N  */
Nstatic __INLINE int32_t SYS_GetPLLStatus()
Xstatic __inline int32_t SYS_GetPLLStatus()
N{
N	int32_t i32Sts;
N
N	(CLK->CLKSTATUS & CLK_CLKSTATUS_PLL_STB) ? (i32Sts = 0) : (i32Sts = -1);
X	(((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSTATUS & ((uint32_t)0x00000004)) ? (i32Sts = 0) : (i32Sts = -1);
N	return i32Sts;
N}
N
N
N/**
N  * @brief  Check the result of switching HCLK source. 
N  * @param None.
N  * @ return clock switch status
N  * @retval 0  success.
N  * @retval -1  failed.
N  */
Nstatic __INLINE uint32_t SYS_GetClockSwitchStatus(void)
Xstatic __inline uint32_t SYS_GetClockSwitchStatus(void)
N{	
N	int32_t i32Sts;
N
N	(CLK->CLKSTATUS & CLK_CLKSTATUS_CLK_SW_FAIL) ? (i32Sts = -1) : (i32Sts = 0);
X	(((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSTATUS & ((uint32_t)0x00000080)) ? (i32Sts = -1) : (i32Sts = 0);
N	return i32Sts;
N}
N
N
N/**
N  * @brief  clear the clock switch failure status 
N  * @param None.
N  * @return None.
N  */
Nstatic __INLINE void SYS_ClearClockSwitchStatus(void)
Xstatic __inline void SYS_ClearClockSwitchStatus(void)
N{
N	 CLK->CLKSTATUS |= CLK_CLKSTATUS_CLK_SW_FAIL;
X	 ((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSTATUS |= ((uint32_t)0x00000080);
N}	
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define SYS functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nint32_t  SYS_SelectHCLKSource(uint32_t u32ClkSrc);
Nvoid     SYS_SetUpPowerDown(uint32_t u32Enable);
Nuint32_t SYS_GetPLLClockFreq(void);
Nuint32_t SYS_GetHCLKFreq(void);
Nint32_t  SYS_InitChipClock(S_SYS_CHIP_CLKCFG *sChipCfg);
Nvoid     SYS_Delay(uint32_t us);
N
N/*@}*/ /* end of group NANO1xx_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO1xx_SYS_Driver */
N
N/*@}*/ /* end of group NANO1xx_Device_Driver */
N
N#endif //__NANO1XX_SYS_H
N
N/*** (C) COPYRIGHT 2012 Nuvoton Technology Corp. ***/
L 12 "Libraries\nano1xx_sys.c" 2
N#include "nano1xx_assert.h"
L 1 ".\Include\nano1xx_assert.h" 1
N/******************************************************************************
N * @file     nano1xx_assert.h
N * @brief    NANO1xx Assert functon header file
N * @version  1.0.1
N * @date     04, September, 2012
N *
N * @note
N * Copyright (C) 2012-2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N
N
N#ifndef __NU_ASSERT_H
N#define __NU_ASSERT_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#ifdef USE_ASSERT
S#define	assert_param(expr)		{															\
S									if (!(expr))											\
S									{														\
S										assert_error((uint8_t*)__FILE__, __LINE__);	        \
S									}														\
S								}
X#define	assert_param(expr)		{																								if (!(expr))																				{																								assert_error((uint8_t*)__FILE__, __LINE__);	        									}																						}
S
Svoid assert_error(uint8_t* file, uint32_t line);
N#else
N#define	assert_param(expr)
N#endif
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  // __NU_ASSERT_H
N
N
N/*** (C) COPYRIGHT 2012 Nuvoton Technology Corp. ***/
L 13 "Libraries\nano1xx_sys.c" 2
N
N
N/** @addtogroup NANO1xx_Device_Driver NANO1xx Device Driver
N  @{
N*/
N
N/** @addtogroup NANO1xx_SYS_Driver SYS Driver
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Global variables                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/// @cond 
Nstatic uint16_t _DrvSYS_PLL_Table[5][6] = {
N     /* Output Freq. */
N     /* 45MHz,                48MHz,               90MHz,               96MHz,               120MHz,               128MHz */
N		{PLL_NOT_SUPPORTED,   PLL_IN_4M_OUT_48M,   PLL_NOT_SUPPORTED,   PLL_IN_4M_OUT_96M,   PLL_IN_4M_OUT_120M,   PLL_IN_4M_OUT_128M},		/* Input 4MHz */
X		{0xFFFF,   0x0110,   0xFFFF,   0x0010,   0x001c,   0xFFFF},		 
N		{PLL_NOT_SUPPORTED,   PLL_IN_8M_OUT_48M,   PLL_NOT_SUPPORTED,   PLL_IN_8M_OUT_96M,   PLL_NOT_SUPPORTED,    PLL_IN_8M_OUT_128M},		/* Input 8MHz */
X		{0xFFFF,   0x0210,   0xFFFF,   0x0110,   0xFFFF,    0x0120},		 
N		{PLL_NOT_SUPPORTED,   PLL_IN_12M_OUT_48M,  PLL_NOT_SUPPORTED,   PLL_IN_12M_OUT_96M,  PLL_IN_12M_OUT_120M,  PLL_NOT_SUPPORTED},		/* Input 12MHz */
X		{0xFFFF,   0x0200,  0xFFFF,   0x0100,  0x0230,  0xFFFF},		 
N		{PLL_IN_15M_OUT_45M,  PLL_NOT_SUPPORTED,   PLL_IN_15M_OUT_90M,  PLL_NOT_SUPPORTED,   PLL_IN_15M_OUT_120M,  PLL_NOT_SUPPORTED},		/* Input 15MHz */
X		{0x0310,  0xFFFF,   0x0210,  0xFFFF,   0x0220,  0xFFFF},		 
N		{PLL_NOT_SUPPORTED,   PLL_IN_24M_OUT_48M,  PLL_NOT_SUPPORTED,   PLL_IN_24M_OUT_96M,  PLL_IN_24M_OUT_120M,  PLL_NOT_SUPPORTED}		/* Input 24MHz */
X		{0xFFFF,   0x1320,  0xFFFF,   0x0320,  0x0330,  0xFFFF}		 
N};
N
N/// @endcond
N
N/** @addtogroup NANO1xx_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief  Select HCLK clock source. 
N  * @param  u32ClkSrc The clock source. CLK_CLKSEL0_HCLK_XXX, where XXX can be HXT, LXT, PLL, HIRC or LIRC.
N  * @return Status of clock selection result.
N  * @retval 0 HCLK is sucessfully changed.
N  * @retval -1 HCLK isn't changed.
N  */
Nint32_t SYS_SelectHCLKSource(uint32_t u32ClkSrc)
N{
N	
N	CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_HCLK_MASK) | u32ClkSrc;
X	((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSEL0 = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSEL0 & ~((uint32_t)0x00000007)) | u32ClkSrc;
N
N	if (CLK->CLKSTATUS & CLK_CLKSTATUS_CLK_SW_FAIL)  {
X	if (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSTATUS & ((uint32_t)0x00000080))  {
N		CLK->CLKSTATUS |= CLK_CLKSTATUS_CLK_SW_FAIL;   /* Clear Clock Switch Fail Flag */
X		((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSTATUS |= ((uint32_t)0x00000080);    
N        return -1;  /* HCLK isn't changed */
N    }
N		
N	SystemCoreClockUpdate(); /* HCLK is changed successfully */
N	
N	return 0;
N}
N
N
N/**
N  * @brief  System enter power down after this function is executed. 
N  * @param  u32Enable This value should be 1 to enable PDWU interrupt. Otherwise, this value should be 0.
N  * @return None.
N  */
Nvoid SYS_SetUpPowerDown(uint32_t u32Enable)
N{	
N
N	CLK->PWRCTL |= (CLK_PWRCTL_PWRDOWN_EN);	   /* Set power down bit */
X	((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PWRCTL |= (((uint32_t)0x00000040));	    
N	SCB->SCR |= 0x04;						   /* Sleep Deep */
X	((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR |= 0x04;						    
N
N	if (u32Enable)  {
N		CLK->PWRCTL |= CLK_PWRCTL_WAKEINT_EN;  /* Enable wake up interrupt source */
X		((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PWRCTL |= ((uint32_t)0x00000020);   
N	    NVIC_EnableIRQ(PDWU_IRQn);			   /* Enable IRQ request for PDWU interupt */
N	}
N
N}
N
N
N/**
N  * @brief  Calculate current PLL clock frquency. 
N  * @param  None.
N  * @return PLL clock frquency. The clock UNIT is in Hz.
N  */
Nuint32_t SYS_GetPLLClockFreq(void)
N{
N	uint32_t u32Freq =0, u32PLLSrc;
N    uint32_t u32NO, u32NR, u32IN_DV, u32PllReg;
N
N	u32PllReg = CLK->PLLCTL;
X	u32PllReg = ((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PLLCTL;
N
N	if (u32PllReg & CLK_PLLCTL_PD)  
X	if (u32PllReg & ((uint32_t)0x00010000))  
N		return 0;	 /* PLL is in power down mode */
N	
N	if (u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
X	if (u32PllReg & ((uint32_t)0x00020000))
N		u32PLLSrc = __IRC12M;
X		u32PLLSrc = (12000000UL);
N	else
N		u32PLLSrc = __XTAL;
X		u32PLLSrc = (12000000UL);
N
N    u32NO = (u32PllReg & CLK_PLLCTL_OUT_DV) ? 2: 1;
X    u32NO = (u32PllReg & ((uint32_t)0x00001000)) ? 2: 1;
N
N	u32IN_DV = (u32PllReg & CLK_PLLCTL_IN_DIVIDER_MASK) >> 8;
X	u32IN_DV = (u32PllReg & ((uint32_t)0x00000300)) >> 8;
N	if (u32IN_DV == 0)
N		u32NR = 2;
N	else if (u32IN_DV == 1)
N		u32NR = 4;
N	else if (u32IN_DV == 2)
N		u32NR = 8;
N	else
N		u32NR = 16;
N
N	u32Freq = u32PLLSrc * ((u32PllReg & CLK_PLLCTL_FB_DIVIDER_MASK) +32) / u32NR / u32NO;
X	u32Freq = u32PLLSrc * ((u32PllReg & ((uint32_t)0x0000003F)) +32) / u32NR / u32NO;
N
N	return u32Freq;
N}
N
N
N/**
N  * @brief  Get current HCLK clock frquency. 
N  * @param  None.
N  * @return HCLK clock frquency. The clock UNIT is in Hz.
N  */
Nuint32_t SYS_GetHCLKFreq(void)
N{
N	
N	uint32_t u32Freqout, u32AHBDivider, u32ClkSel;
N
N	u32ClkSel = CLK->CLKSEL0 & CLK_CLKSEL0_HCLK_MASK;
X	u32ClkSel = ((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSEL0 & ((uint32_t)0x00000007);
N
N	if (u32ClkSel == CLK_CLKSEL0_HCLK_HXT)	/* external HXT crystal clock */
X	if (u32ClkSel == ((uint32_t)0x00000000))	 
N	{
N		u32Freqout = __XTAL;	
X		u32Freqout = (12000000UL);	
N	}
N	else if(u32ClkSel == CLK_CLKSEL0_HCLK_LXT)		/* external LXT crystal clock */ 
X	else if(u32ClkSel == ((uint32_t)0x00000001))		  
N	{
N		u32Freqout = __RTC_XTAL;
X		u32Freqout = (32768UL);
N	}
N	else if(u32ClkSel == CLK_CLKSEL0_HCLK_PLL)		/* PLL clock */
X	else if(u32ClkSel == ((uint32_t)0x00000002))		 
N	{
N		u32Freqout = SYS_GetPLLClockFreq();
N	}
N	else if(u32ClkSel == CLK_CLKSEL0_HCLK_LIRC)	/* internal LIRC oscillator clock */
X	else if(u32ClkSel == ((uint32_t)0x00000003))	 
N	{
N	 	u32Freqout = __IRC10K;
X	 	u32Freqout = (10000UL);
N	}
N	else									/* internal HIRC oscillator clock */
N	{
N	 	u32Freqout = __IRC12M;
X	 	u32Freqout = (12000000UL);
N	
N	}
N	u32AHBDivider = (CLK->CLKDIV0 & CLK_CLKDIV0_HCLK_MASK) + 1 ;
X	u32AHBDivider = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV0 & ((uint32_t)0x0000000F)) + 1 ;
N	
N	return (u32Freqout/u32AHBDivider);	
N}
N
N
N/**
N  * @brief  Enable chip clock sources including HXT, LXT, LIRX, HIRC and PLL. And then set HCLK clock source and divider.
N  *         If the second parameter is NOT NULL, also enable the clock and set the source/divider of peripheral functions. 
N  * @param  sChipCfg    - [in], The pointer to the structure which stores the configuration of chip clock source and HCLK.
N  *                              u32ChipClkEn : CLK_PWRCTL_XXX_EN, where XXX could be HXT, LXT, HIRC or LIRC
N  *                              u32PLLClkSrc : CLK_PLLCTL_PLLSRC_HIRC or CLK_PLLCTL_PLLSRC_HXT
N  *                              u8PLLEnable : 1 to enable PLL, 0 to disable PLL        
N  *                              ePLLInFreq  : E_SYS_PLLIN_4M, _8M, _12M, _15M or _24M                     
N  *                              ePLLOutFreq : E_SYS_PLLOUT_45M, _48M, _90M, _96M, _120M or _128M  
N  *                              u32HClkSrc : CLK_CLKSEL0_HCLK_XXX, where XXX could be HXT, LXT, PLL, HIRC or LIRC
N  *                              u32HClkDiv : 0 ~ 15       
N  *                                                                                                             
N  * @return Execution result.
N  * @retval  0 Success                                                              
N  * @retval  -1 The chip clock sources are not stable
N  * @retval  -2 The selected PLL setting is not supported
N  * @retval  -3 The PLL clock output is not stable
N  */
Nint32_t SYS_InitChipClock(S_SYS_CHIP_CLKCFG *sChipCfg)
N{
N	uint32_t u32ClkEn, u32ClkSts, u32PllCtl;	
N	volatile uint32_t delayCnt;
N	
N	assert_param(CHECK_CLK_CONFIG(sChipCfg));               /* Check input parameter */
X	;                
N	assert_param(CHECK_HCLK_SOURCE(sChipCfg->u32HClkSrc));  /* Check HCLK clock select */
X	;   
N
N	/* enable chip clock sources */
N	u32ClkEn = u32ClkSts = (sChipCfg->u32ChipClkEn) & 0x0F; 
N	if (u32ClkSts & CLK_PWRCTL_HIRC_EN) 
X	if (u32ClkSts & ((uint32_t)0x00000004)) 
N		u32ClkSts = (u32ClkSts & ~CLK_PWRCTL_HIRC_EN) | CLK_CLKSTATUS_HIRC_STB;
X		u32ClkSts = (u32ClkSts & ~((uint32_t)0x00000004)) | ((uint32_t)0x00000010);
N	
N	SYS_SetChipClockSrc(u32ClkEn, 1);  /* enable the selected chip clock sources */
N	
N	for (delayCnt=0; delayCnt<100000; delayCnt++)
N		if ((CLK->CLKSTATUS & u32ClkSts) == u32ClkSts)
X		if ((((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSTATUS & u32ClkSts) == u32ClkSts)
N			break;
N
N	if (delayCnt == 100000)
N		return -1;
N
N	/* enable PLL */
N	if (sChipCfg->u8PLLEnable == 1)  {
N
N		/* check PLL in clock freq. */
N		assert_param(CHECK_PLLIN_CLK(sChipCfg->ePLLInFreq));
X		;
N		assert_param(CHECK_PLLOUT_CLK(sChipCfg->ePLLOutFreq));
X		;
N		
N		u32PllCtl = _DrvSYS_PLL_Table[sChipCfg->ePLLInFreq][sChipCfg->ePLLOutFreq];
N
N		if (u32PllCtl == PLL_NOT_SUPPORTED)
X		if (u32PllCtl == 0xFFFF)
N			return -2;
N
N		/* select correct pll clock source */
N		u32PllCtl |= sChipCfg->u32PLLClkSrc;
N
N		/* set PLL control reg and waits for PLL clock stable */
N		CLK->PLLCTL = u32PllCtl;
X		((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->PLLCTL = u32PllCtl;
N
N		for (delayCnt=0; delayCnt<100000; delayCnt++)
N			if (CLK->CLKSTATUS & CLK_CLKSTATUS_PLL_STB)
X			if (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKSTATUS & ((uint32_t)0x00000004))
N				break;
N
N		if (delayCnt == 100000)
N			return -3;		
N	}
N
N	/* set HCLK divider and source */
N	CLK->CLKDIV0 = (CLK->CLKDIV0 & ~CLK_CLKDIV0_HCLK_MASK) | sChipCfg->u32HClkDiv;
X	((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV0 = (((CLK_TypeDef *) (((0x40000000UL) + 0x10000000) + 0x00200))->CLKDIV0 & ~((uint32_t)0x0000000F)) | sChipCfg->u32HClkDiv;
N	SYS_SelectHCLKSource(sChipCfg->u32HClkSrc); /* select required clock source for HCLk */
N
N	return 0;
N}
N
N
N/**
N  * @brief  Use the SysTick to generate the delay time. 
N  * @param  us The required delay time in us.
N  * @return None.
N  */
Nvoid SYS_Delay(uint32_t us)
N{
N	SysTick->LOAD = (us * ((SystemCoreClock + 500000) / 1000000));
X	((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = (us * ((SystemCoreClock + 500000) / 1000000));
N	SysTick->VAL  = (0x00);
X	((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2) | (1UL << 0);
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & (1 << 16)) == 0);
X    while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1 << 16)) == 0);
N
N}
N
N/*@}*/ /* end of group NANO1xx_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO1xx_SYS_Driver */
N
N/*@}*/ /* end of group NANO1xx_Device_Driver */
N
N/*** (C) COPYRIGHT 2012 Nuvoton Technology Corp. ***/
