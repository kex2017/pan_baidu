; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\rc522.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\rc522.d --feedback=.\obj\START_KIT.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Libraries -I.\Include -I.\Users -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -D__MICROLIB -D__LCDDISPLAY_BTL001_LB_H --omf_browse=.\obj\rc522.crf Users\RC522.C]
                          THUMB

                          AREA ||i.CalulateCRC||, CODE, READONLY, ALIGN=1

                  CalulateCRC PROC
;;;278    /////////////////////////////////////////////////////////////////////
;;;279    void CalulateCRC(unsigned char *pIndata,unsigned char len,unsigned char *pOutData)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;280    {
000002  4607              MOV      r7,r0
000004  4615              MOV      r5,r2
;;;281        unsigned char i,n;
;;;282        ClearBitMask(DivIrqReg,0x04);
000006  2104              MOVS     r1,#4
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       ClearBitMask
;;;283        WriteRawRC(CommandReg,PCD_IDLE);
00000e  2100              MOVS     r1,#0
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       WriteRawRC
;;;284        SetBitMask(FIFOLevelReg,0x80);
000016  2180              MOVS     r1,#0x80
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       SetBitMask
;;;285        for (i=0; i<len; i++)
00001e  2400              MOVS     r4,#0
000020  e005              B        |L1.46|
                  |L1.34|
;;;286        {   WriteRawRC(FIFODataReg, *(pIndata+i));   }
000022  5d39              LDRB     r1,[r7,r4]
000024  2009              MOVS     r0,#9
000026  f7fffffe          BL       WriteRawRC
00002a  1c60              ADDS     r0,r4,#1              ;285
00002c  b2c4              UXTB     r4,r0                 ;285
                  |L1.46|
00002e  9801              LDR      r0,[sp,#4]            ;285
000030  4284              CMP      r4,r0                 ;285
000032  dbf6              BLT      |L1.34|
;;;287        WriteRawRC(CommandReg, PCD_CALCCRC);
000034  2103              MOVS     r1,#3
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       WriteRawRC
;;;288        i = 0xFF;
00003c  24ff              MOVS     r4,#0xff
;;;289        do 
00003e  bf00              NOP      
                  |L1.64|
;;;290        {
;;;291            n = ReadRawRC(DivIrqReg);
000040  2005              MOVS     r0,#5
000042  f7fffffe          BL       ReadRawRC
000046  4606              MOV      r6,r0
;;;292            i--;
000048  1e60              SUBS     r0,r4,#1
00004a  b2c4              UXTB     r4,r0
;;;293        }
;;;294        while ((i!=0) && !(n&0x04));
00004c  2c00              CMP      r4,#0
00004e  d002              BEQ      |L1.86|
000050  2004              MOVS     r0,#4
000052  4206              TST      r6,r0
000054  d0f4              BEQ      |L1.64|
                  |L1.86|
;;;295        pOutData[0] = ReadRawRC(CRCResultRegL);
000056  2022              MOVS     r0,#0x22
000058  f7fffffe          BL       ReadRawRC
00005c  7028              STRB     r0,[r5,#0]
;;;296        pOutData[1] = ReadRawRC(CRCResultRegM);
00005e  2021              MOVS     r0,#0x21
000060  f7fffffe          BL       ReadRawRC
000064  7068              STRB     r0,[r5,#1]
;;;297    }
000066  bdfe              POP      {r1-r7,pc}
;;;298    
                          ENDP


                          AREA ||i.ClearBitMask||, CODE, READONLY, ALIGN=1

                  ClearBitMask PROC
;;;457    /////////////////////////////////////////////////////////////////////
;;;458    void ClearBitMask(unsigned char reg,unsigned char mask)  
000000  b570              PUSH     {r4-r6,lr}
;;;459    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;460        char tmp = 0x0;
000006  2600              MOVS     r6,#0
;;;461        tmp = ReadRawRC(reg);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       ReadRawRC
00000e  4606              MOV      r6,r0
;;;462        WriteRawRC(reg, tmp & ~mask);  // clear bit mask
000010  4630              MOV      r0,r6
000012  43a0              BICS     r0,r0,r4
000014  4601              MOV      r1,r0
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       WriteRawRC
;;;463    } 
00001c  bd70              POP      {r4-r6,pc}
;;;464    
                          ENDP


                          AREA ||i.GPIO_ClrBit||, CODE, READONLY, ALIGN=1

                  GPIO_ClrBit PROC
;;;102      */
;;;103    static __INLINE void GPIO_ClrBit(GPIO_TypeDef *port, uint32_t bit)
000000  6882              LDR      r2,[r0,#8]
;;;104    {
;;;105    	port->DOUT &= ~(1 << bit);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  439a              BICS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;106    }
00000a  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.GPIO_SetBit||, CODE, READONLY, ALIGN=1

                  GPIO_SetBit PROC
;;;80       */
;;;81     static __INLINE void GPIO_SetBit(GPIO_TypeDef *port, uint32_t bit)
000000  6882              LDR      r2,[r0,#8]
;;;82     {
;;;83     	port->DOUT |= (1 << bit);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  431a              ORRS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;84     }
00000a  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.M500PcdConfigISOType||, CODE, READONLY, ALIGN=1

                  M500PcdConfigISOType PROC
;;;331    //////////////////////////////////////////////////////////////////////
;;;332    char M500PcdConfigISOType(unsigned char type)
000000  b510              PUSH     {r4,lr}
;;;333    {
000002  4604              MOV      r4,r0
;;;334       if (type == 'A')                     //ISO14443_A
000004  2c41              CMP      r4,#0x41
000006  d125              BNE      |L5.84|
;;;335       { 
;;;336           ClearBitMask(Status2Reg,0x08);
000008  2108              MOVS     r1,#8
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       ClearBitMask
;;;337    
;;;338     /*     WriteRawRC(CommandReg,0x20);    //as default   
;;;339           WriteRawRC(ComIEnReg,0x80);     //as default
;;;340           WriteRawRC(DivlEnReg,0x0);      //as default
;;;341    	   WriteRawRC(ComIrqReg,0x04);     //as default
;;;342    	   WriteRawRC(DivIrqReg,0x0);      //as default
;;;343    	   WriteRawRC(Status2Reg,0x0);//80    //trun off temperature sensor
;;;344    	   WriteRawRC(WaterLevelReg,0x08); //as default
;;;345           WriteRawRC(ControlReg,0x20);    //as default
;;;346    	   WriteRawRC(CollReg,0x80);    //as default
;;;347    */
;;;348           WriteRawRC(ModeReg,0x3D);//3F
000010  213d              MOVS     r1,#0x3d
000012  2011              MOVS     r0,#0x11
000014  f7fffffe          BL       WriteRawRC
;;;349    /*	   WriteRawRC(TxModeReg,0x0);      //as default???
;;;350    	   WriteRawRC(RxModeReg,0x0);      //as default???
;;;351    	   WriteRawRC(TxControlReg,0x80);  //as default???
;;;352    
;;;353    	   WriteRawRC(TxSelReg,0x10);      //as default???
;;;354       */
;;;355           WriteRawRC(RxSelReg,0x86);//84
000018  2186              MOVS     r1,#0x86
00001a  2017              MOVS     r0,#0x17
00001c  f7fffffe          BL       WriteRawRC
;;;356     //      WriteRawRC(RxThresholdReg,0x84);//as default
;;;357     //      WriteRawRC(DemodReg,0x4D);      //as default
;;;358    
;;;359     //      WriteRawRC(ModWidthReg,0x13);//26
;;;360           WriteRawRC(RFCfgReg,0x7F);   //4F
000020  217f              MOVS     r1,#0x7f
000022  2026              MOVS     r0,#0x26
000024  f7fffffe          BL       WriteRawRC
;;;361    	/*   WriteRawRC(GsNReg,0x88);        //as default???
;;;362    	   WriteRawRC(CWGsCfgReg,0x20);    //as default???
;;;363           WriteRawRC(ModGsCfgReg,0x20);   //as default???
;;;364    */
;;;365       	   WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec) 
000028  211e              MOVS     r1,#0x1e
00002a  202d              MOVS     r0,#0x2d
00002c  f7fffffe          BL       WriteRawRC
;;;366    	   WriteRawRC(TReloadRegH,0);
000030  2100              MOVS     r1,#0
000032  202c              MOVS     r0,#0x2c
000034  f7fffffe          BL       WriteRawRC
;;;367           WriteRawRC(TModeReg,0x8D);
000038  218d              MOVS     r1,#0x8d
00003a  202a              MOVS     r0,#0x2a
00003c  f7fffffe          BL       WriteRawRC
;;;368    	   WriteRawRC(TPrescalerReg,0x3E);
000040  213e              MOVS     r1,#0x3e
000042  202b              MOVS     r0,#0x2b
000044  f7fffffe          BL       WriteRawRC
;;;369    
;;;370      //     PcdSetTmo(106);
;;;371    	    		delay_10ms(1);
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       delay_10ms
;;;372           PcdAntennaOn();
00004e  f7fffffe          BL       PcdAntennaOn
000052  e001              B        |L5.88|
                  |L5.84|
;;;373       }
;;;374       else{ return 1; }
000054  2001              MOVS     r0,#1
                  |L5.86|
;;;375       
;;;376       return MI_OK;
;;;377    }
000056  bd10              POP      {r4,pc}
                  |L5.88|
000058  2000              MOVS     r0,#0                 ;376
00005a  e7fc              B        |L5.86|
;;;378    /////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.PcdAntennaOff||, CODE, READONLY, ALIGN=1

                  PcdAntennaOff PROC
;;;575    /////////////////////////////////////////////////////////////////////
;;;576    void PcdAntennaOff()
000000  b510              PUSH     {r4,lr}
;;;577    {
;;;578        ClearBitMask(TxControlReg, 0x03);
000002  2103              MOVS     r1,#3
000004  2014              MOVS     r0,#0x14
000006  f7fffffe          BL       ClearBitMask
;;;579    }
00000a  bd10              POP      {r4,pc}
;;;580    
                          ENDP


                          AREA ||i.PcdAntennaOn||, CODE, READONLY, ALIGN=1

                  PcdAntennaOn PROC
;;;561    /////////////////////////////////////////////////////////////////////
;;;562    void PcdAntennaOn()
000000  b510              PUSH     {r4,lr}
;;;563    {
;;;564        unsigned char i;
;;;565        i = ReadRawRC(TxControlReg);
000002  2014              MOVS     r0,#0x14
000004  f7fffffe          BL       ReadRawRC
000008  4604              MOV      r4,r0
;;;566        if (!(i & 0x03))
00000a  07a0              LSLS     r0,r4,#30
00000c  0f80              LSRS     r0,r0,#30
00000e  d103              BNE      |L7.24|
;;;567        {
;;;568            SetBitMask(TxControlReg, 0x03);
000010  2103              MOVS     r1,#3
000012  2014              MOVS     r0,#0x14
000014  f7fffffe          BL       SetBitMask
                  |L7.24|
;;;569        }
;;;570    }
000018  bd10              POP      {r4,pc}
;;;571    
                          ENDP


                          AREA ||i.PcdAnticoll||, CODE, READONLY, ALIGN=1

                  PcdAnticoll PROC
;;;91     /////////////////////////////////////////////////////////////////////  
;;;92     char PcdAnticoll(unsigned char *pSnr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;93     {
000002  b087              SUB      sp,sp,#0x1c
000004  4605              MOV      r5,r0
;;;94         char status;
;;;95         unsigned char i,snr_check=0;
000006  2700              MOVS     r7,#0
;;;96         unsigned int  unLen;
;;;97         unsigned char ucComMF522Buf[MAXRLEN]; 
;;;98         
;;;99     
;;;100        ClearBitMask(Status2Reg,0x08);
000008  2108              MOVS     r1,#8
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       ClearBitMask
;;;101        WriteRawRC(BitFramingReg,0x00);
000010  2100              MOVS     r1,#0
000012  200d              MOVS     r0,#0xd
000014  f7fffffe          BL       WriteRawRC
;;;102        ClearBitMask(CollReg,0x80);
000018  2180              MOVS     r1,#0x80
00001a  200e              MOVS     r0,#0xe
00001c  f7fffffe          BL       ClearBitMask
;;;103     
;;;104        ucComMF522Buf[0] = PICC_ANTICOLL1;
000020  2193              MOVS     r1,#0x93
000022  4668              MOV      r0,sp
000024  7101              STRB     r1,[r0,#4]
;;;105        ucComMF522Buf[1] = 0x20;
000026  2120              MOVS     r1,#0x20
000028  7141              STRB     r1,[r0,#5]
;;;106    
;;;107        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
00002a  a806              ADD      r0,sp,#0x18
00002c  ab01              ADD      r3,sp,#4
00002e  2202              MOVS     r2,#2
000030  a901              ADD      r1,sp,#4
000032  9000              STR      r0,[sp,#0]
000034  200c              MOVS     r0,#0xc
000036  f7fffffe          BL       PcdComMF522
00003a  4606              MOV      r6,r0
;;;108    
;;;109        if (status == MI_OK)
00003c  2e00              CMP      r6,#0
00003e  d110              BNE      |L8.98|
;;;110        {
;;;111        	 for (i=0; i<4; i++)
000040  2400              MOVS     r4,#0
000042  e007              B        |L8.84|
                  |L8.68|
;;;112             {   
;;;113                 *(pSnr+i)  = ucComMF522Buf[i];
000044  a801              ADD      r0,sp,#4
000046  5d00              LDRB     r0,[r0,r4]
000048  5528              STRB     r0,[r5,r4]
;;;114                 snr_check ^= ucComMF522Buf[i];
00004a  a801              ADD      r0,sp,#4
00004c  5d00              LDRB     r0,[r0,r4]
00004e  4047              EORS     r7,r7,r0
000050  1c60              ADDS     r0,r4,#1              ;111
000052  b2c4              UXTB     r4,r0                 ;111
                  |L8.84|
000054  2c04              CMP      r4,#4                 ;111
000056  dbf5              BLT      |L8.68|
;;;115             }
;;;116             if (snr_check != ucComMF522Buf[i])
000058  a801              ADD      r0,sp,#4
00005a  5d00              LDRB     r0,[r0,r4]
00005c  42b8              CMP      r0,r7
00005e  d000              BEQ      |L8.98|
;;;117             {   status = MI_ERR;    }
000060  2602              MOVS     r6,#2
                  |L8.98|
;;;118        }
;;;119        
;;;120        SetBitMask(CollReg,0x80);
000062  2180              MOVS     r1,#0x80
000064  200e              MOVS     r0,#0xe
000066  f7fffffe          BL       SetBitMask
;;;121        return status;
00006a  4630              MOV      r0,r6
;;;122    }
00006c  b007              ADD      sp,sp,#0x1c
00006e  bdf0              POP      {r4-r7,pc}
;;;123    
                          ENDP


                          AREA ||i.PcdAuthState||, CODE, READONLY, ALIGN=1

                  PcdAuthState PROC
;;;167    /////////////////////////////////////////////////////////////////////               
;;;168    char PcdAuthState(unsigned char auth_mode,unsigned char addr,unsigned char *pKey,unsigned char *pSnr)
000000  b5ff              PUSH     {r0-r7,lr}
;;;169    {
000002  b087              SUB      sp,sp,#0x1c
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;170        char status;
;;;171        unsigned int  unLen;
;;;172        unsigned char i,ucComMF522Buf[MAXRLEN]; 
;;;173    
;;;174        ucComMF522Buf[0] = auth_mode;
000008  4668              MOV      r0,sp
00000a  7106              STRB     r6,[r0,#4]
;;;175        ucComMF522Buf[1] = addr;
00000c  7147              STRB     r7,[r0,#5]
;;;176        for (i=0; i<6; i++)
00000e  2400              MOVS     r4,#0
000010  e006              B        |L9.32|
                  |L9.18|
;;;177        {    ucComMF522Buf[i+2] = *(pKey+i);   }
000012  9809              LDR      r0,[sp,#0x24]
000014  5d01              LDRB     r1,[r0,r4]
000016  aa01              ADD      r2,sp,#4
000018  1ca0              ADDS     r0,r4,#2
00001a  5411              STRB     r1,[r2,r0]
00001c  1c60              ADDS     r0,r4,#1              ;176
00001e  b2c4              UXTB     r4,r0                 ;176
                  |L9.32|
000020  2c06              CMP      r4,#6                 ;176
000022  dbf6              BLT      |L9.18|
;;;178        for (i=0; i<6; i++)
000024  2400              MOVS     r4,#0
000026  e007              B        |L9.56|
                  |L9.40|
;;;179        {    ucComMF522Buf[i+8] = *(pSnr+i);   }
000028  980a              LDR      r0,[sp,#0x28]
00002a  5d01              LDRB     r1,[r0,r4]
00002c  aa01              ADD      r2,sp,#4
00002e  4620              MOV      r0,r4
000030  3008              ADDS     r0,r0,#8
000032  5411              STRB     r1,[r2,r0]
000034  1c60              ADDS     r0,r4,#1              ;178
000036  b2c4              UXTB     r4,r0                 ;178
                  |L9.56|
000038  2c06              CMP      r4,#6                 ;178
00003a  dbf5              BLT      |L9.40|
;;;180     //   memcpy(&ucComMF522Buf[2], pKey, 6); 
;;;181     //   memcpy(&ucComMF522Buf[8], pSnr, 4); 
;;;182        
;;;183        status = PcdComMF522(PCD_AUTHENT,ucComMF522Buf,12,ucComMF522Buf,&unLen);
00003c  a806              ADD      r0,sp,#0x18
00003e  ab01              ADD      r3,sp,#4
000040  220c              MOVS     r2,#0xc
000042  a901              ADD      r1,sp,#4
000044  9000              STR      r0,[sp,#0]
000046  200e              MOVS     r0,#0xe
000048  f7fffffe          BL       PcdComMF522
00004c  4605              MOV      r5,r0
;;;184        if ((status != MI_OK) || (!(ReadRawRC(Status2Reg) & 0x08)))
00004e  2d00              CMP      r5,#0
000050  d105              BNE      |L9.94|
000052  2008              MOVS     r0,#8
000054  f7fffffe          BL       ReadRawRC
000058  2108              MOVS     r1,#8
00005a  4208              TST      r0,r1
00005c  d100              BNE      |L9.96|
                  |L9.94|
;;;185        {   status = MI_ERR;   }
00005e  2502              MOVS     r5,#2
                  |L9.96|
;;;186        
;;;187        return status;
000060  4628              MOV      r0,r5
;;;188    }
000062  b00b              ADD      sp,sp,#0x2c
000064  bdf0              POP      {r4-r7,pc}
;;;189    
                          ENDP


                          AREA ||i.PcdBakValue||, CODE, READONLY, ALIGN=1

                  PcdBakValue PROC
;;;637    /////////////////////////////////////////////////////////////////////
;;;638    char PcdBakValue(unsigned char sourceaddr, unsigned char goaladdr)
000000  b570              PUSH     {r4-r6,lr}
;;;639    {
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;640        char status;
;;;641        unsigned int  unLen;
;;;642        unsigned char ucComMF522Buf[MAXRLEN]; 
;;;643    
;;;644        ucComMF522Buf[0] = PICC_RESTORE;
000008  21c2              MOVS     r1,#0xc2
00000a  4668              MOV      r0,sp
00000c  7201              STRB     r1,[r0,#8]
;;;645        ucComMF522Buf[1] = sourceaddr;
00000e  7245              STRB     r5,[r0,#9]
;;;646        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
000010  aa02              ADD      r2,sp,#8
000012  3202              ADDS     r2,#2
000014  2102              MOVS     r1,#2
000016  a802              ADD      r0,sp,#8
000018  f7fffffe          BL       CalulateCRC
;;;647     
;;;648        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
00001c  a807              ADD      r0,sp,#0x1c
00001e  ab02              ADD      r3,sp,#8
000020  2204              MOVS     r2,#4
000022  a902              ADD      r1,sp,#8
000024  9000              STR      r0,[sp,#0]
000026  200c              MOVS     r0,#0xc
000028  f7fffffe          BL       PcdComMF522
00002c  4604              MOV      r4,r0
;;;649    
;;;650        if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
00002e  2c00              CMP      r4,#0
000030  d108              BNE      |L10.68|
000032  9807              LDR      r0,[sp,#0x1c]
000034  2804              CMP      r0,#4
000036  d105              BNE      |L10.68|
000038  4668              MOV      r0,sp
00003a  7a00              LDRB     r0,[r0,#8]
00003c  0700              LSLS     r0,r0,#28
00003e  0f00              LSRS     r0,r0,#28
000040  280a              CMP      r0,#0xa
000042  d000              BEQ      |L10.70|
                  |L10.68|
;;;651        {   status = MI_ERR;   }
000044  2402              MOVS     r4,#2
                  |L10.70|
;;;652        
;;;653        if (status == MI_OK)
000046  2c00              CMP      r4,#0
000048  d116              BNE      |L10.120|
;;;654        {
;;;655            ucComMF522Buf[0] = 0;
00004a  2100              MOVS     r1,#0
00004c  4668              MOV      r0,sp
00004e  7201              STRB     r1,[r0,#8]
;;;656            ucComMF522Buf[1] = 0;
000050  7241              STRB     r1,[r0,#9]
;;;657            ucComMF522Buf[2] = 0;
000052  7281              STRB     r1,[r0,#0xa]
;;;658            ucComMF522Buf[3] = 0;
000054  72c1              STRB     r1,[r0,#0xb]
;;;659            CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
000056  aa03              ADD      r2,sp,#0xc
000058  2104              MOVS     r1,#4
00005a  a802              ADD      r0,sp,#8
00005c  f7fffffe          BL       CalulateCRC
;;;660     
;;;661            status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
000060  a807              ADD      r0,sp,#0x1c
000062  ab02              ADD      r3,sp,#8
000064  2206              MOVS     r2,#6
000066  a902              ADD      r1,sp,#8
000068  9000              STR      r0,[sp,#0]
00006a  200c              MOVS     r0,#0xc
00006c  f7fffffe          BL       PcdComMF522
000070  4604              MOV      r4,r0
;;;662            if (status != MI_ERR)
000072  2c02              CMP      r4,#2
000074  d000              BEQ      |L10.120|
;;;663            {    status = MI_OK;    }
000076  2400              MOVS     r4,#0
                  |L10.120|
;;;664        }
;;;665        
;;;666        if (status != MI_OK)
000078  2c00              CMP      r4,#0
00007a  d002              BEQ      |L10.130|
;;;667        {    return MI_ERR;   }
00007c  2002              MOVS     r0,#2
                  |L10.126|
;;;668        
;;;669        ucComMF522Buf[0] = PICC_TRANSFER;
;;;670        ucComMF522Buf[1] = goaladdr;
;;;671    
;;;672        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
;;;673     
;;;674        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
;;;675    
;;;676        if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
;;;677        {   status = MI_ERR;   }
;;;678    
;;;679        return status;
;;;680    }
00007e  b008              ADD      sp,sp,#0x20
000080  bd70              POP      {r4-r6,pc}
                  |L10.130|
000082  21b0              MOVS     r1,#0xb0              ;669
000084  4668              MOV      r0,sp                 ;669
000086  7201              STRB     r1,[r0,#8]            ;669
000088  7246              STRB     r6,[r0,#9]            ;670
00008a  aa02              ADD      r2,sp,#8              ;672
00008c  3202              ADDS     r2,#2                 ;672
00008e  2102              MOVS     r1,#2                 ;672
000090  a802              ADD      r0,sp,#8              ;672
000092  f7fffffe          BL       CalulateCRC
000096  a807              ADD      r0,sp,#0x1c           ;674
000098  ab02              ADD      r3,sp,#8              ;674
00009a  2204              MOVS     r2,#4                 ;674
00009c  a902              ADD      r1,sp,#8              ;674
00009e  9000              STR      r0,[sp,#0]            ;674
0000a0  200c              MOVS     r0,#0xc               ;674
0000a2  f7fffffe          BL       PcdComMF522
0000a6  4604              MOV      r4,r0                 ;674
0000a8  2c00              CMP      r4,#0                 ;676
0000aa  d108              BNE      |L10.190|
0000ac  9807              LDR      r0,[sp,#0x1c]         ;676
0000ae  2804              CMP      r0,#4                 ;676
0000b0  d105              BNE      |L10.190|
0000b2  4668              MOV      r0,sp                 ;676
0000b4  7a00              LDRB     r0,[r0,#8]            ;676
0000b6  0700              LSLS     r0,r0,#28             ;676
0000b8  0f00              LSRS     r0,r0,#28             ;676
0000ba  280a              CMP      r0,#0xa               ;676
0000bc  d000              BEQ      |L10.192|
                  |L10.190|
0000be  2402              MOVS     r4,#2                 ;677
                  |L10.192|
0000c0  4620              MOV      r0,r4                 ;679
0000c2  e7dc              B        |L10.126|
;;;681    
                          ENDP


                          AREA ||i.PcdComMF522||, CODE, READONLY, ALIGN=1

                  PcdComMF522 PROC
;;;472    /////////////////////////////////////////////////////////////////////
;;;473    char PcdComMF522(unsigned char Command, 
000000  b5ff              PUSH     {r0-r7,lr}
;;;474                     unsigned char *pInData, 
;;;475                     unsigned char InLenByte,
;;;476                     unsigned char *pOutData, 
;;;477                     unsigned int  *pOutLenBit)
;;;478    {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
;;;479        char status = MI_ERR;
000006  2002              MOVS     r0,#2
000008  9004              STR      r0,[sp,#0x10]
;;;480        unsigned char irqEn   = 0x00;
00000a  2000              MOVS     r0,#0
00000c  9003              STR      r0,[sp,#0xc]
;;;481        unsigned char waitFor = 0x00;
00000e  9002              STR      r0,[sp,#8]
;;;482        unsigned char lastBits;
;;;483        unsigned char n, temp;
;;;484        unsigned int i;
;;;485        switch (Command)
000010  2e0c              CMP      r6,#0xc
000012  d006              BEQ      |L11.34|
000014  2e0e              CMP      r6,#0xe
000016  d109              BNE      |L11.44|
;;;486        {
;;;487           case PCD_AUTHENT:
;;;488              irqEn   = 0x12;
000018  2012              MOVS     r0,#0x12
00001a  9003              STR      r0,[sp,#0xc]
;;;489              waitFor = 0x10;
00001c  2010              MOVS     r0,#0x10
00001e  9002              STR      r0,[sp,#8]
;;;490              break;
000020  e005              B        |L11.46|
                  |L11.34|
;;;491           case PCD_TRANSCEIVE:
;;;492              irqEn   = 0x77;
000022  2077              MOVS     r0,#0x77
000024  9003              STR      r0,[sp,#0xc]
;;;493              waitFor = 0x30;
000026  2030              MOVS     r0,#0x30
000028  9002              STR      r0,[sp,#8]
;;;494              break;
00002a  e000              B        |L11.46|
                  |L11.44|
;;;495           default:
;;;496             break;
00002c  bf00              NOP      
                  |L11.46|
00002e  bf00              NOP                            ;490
;;;497        }
;;;498       
;;;499        WriteRawRC(ComIEnReg,irqEn|0x80);
000030  2280              MOVS     r2,#0x80
000032  9803              LDR      r0,[sp,#0xc]
000034  4310              ORRS     r0,r0,r2
000036  4601              MOV      r1,r0
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       WriteRawRC
;;;500        ClearBitMask(ComIrqReg,0x80);
00003e  2180              MOVS     r1,#0x80
000040  2004              MOVS     r0,#4
000042  f7fffffe          BL       ClearBitMask
;;;501        WriteRawRC(CommandReg,PCD_IDLE);
000046  2100              MOVS     r1,#0
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       WriteRawRC
;;;502        SetBitMask(FIFOLevelReg,0x80);
00004e  2180              MOVS     r1,#0x80
000050  200a              MOVS     r0,#0xa
000052  f7fffffe          BL       SetBitMask
;;;503        
;;;504        for (i=0; i<InLenByte; i++)
000056  2500              MOVS     r5,#0
000058  e005              B        |L11.102|
                  |L11.90|
;;;505        {   WriteRawRC(FIFODataReg, pInData[i]);    }
00005a  9806              LDR      r0,[sp,#0x18]
00005c  5d41              LDRB     r1,[r0,r5]
00005e  2009              MOVS     r0,#9
000060  f7fffffe          BL       WriteRawRC
000064  1c6d              ADDS     r5,r5,#1              ;504
                  |L11.102|
000066  9807              LDR      r0,[sp,#0x1c]         ;504
000068  4285              CMP      r5,r0                 ;504
00006a  d3f6              BCC      |L11.90|
;;;506        WriteRawRC(CommandReg, Command);
00006c  4631              MOV      r1,r6
00006e  2001              MOVS     r0,#1
000070  f7fffffe          BL       WriteRawRC
;;;507       
;;;508        
;;;509        if (Command == PCD_TRANSCEIVE)
000074  2e0c              CMP      r6,#0xc
000076  d103              BNE      |L11.128|
;;;510        {    SetBitMask(BitFramingReg,0x80);  }
000078  2180              MOVS     r1,#0x80
00007a  200d              MOVS     r0,#0xd
00007c  f7fffffe          BL       SetBitMask
                  |L11.128|
;;;511        
;;;512    //    i = 600;//根据时钟频率调整，操作M1卡最大等待时间25ms
;;;513        i = 2000;
000080  257d              MOVS     r5,#0x7d
000082  012d              LSLS     r5,r5,#4
;;;514        do 
000084  bf00              NOP      
                  |L11.134|
;;;515        {
;;;516             n = ReadRawRC(ComIrqReg);
000086  2004              MOVS     r0,#4
000088  f7fffffe          BL       ReadRawRC
00008c  4604              MOV      r4,r0
;;;517             i--;
00008e  1e6d              SUBS     r5,r5,#1
;;;518        }
;;;519        while ((i!=0) && !(n&0x01) && !(n&waitFor));
000090  2d00              CMP      r5,#0
000092  d005              BEQ      |L11.160|
000094  07e0              LSLS     r0,r4,#31
000096  0fc0              LSRS     r0,r0,#31
000098  d102              BNE      |L11.160|
00009a  9802              LDR      r0,[sp,#8]
00009c  4204              TST      r4,r0
00009e  d0f2              BEQ      |L11.134|
                  |L11.160|
;;;520        ClearBitMask(BitFramingReg,0x80);
0000a0  2180              MOVS     r1,#0x80
0000a2  200d              MOVS     r0,#0xd
0000a4  f7fffffe          BL       ClearBitMask
;;;521    	      
;;;522        if (i!=0)
0000a8  2d00              CMP      r5,#0
0000aa  d03a              BEQ      |L11.290|
;;;523        { 
;;;524    		temp = ReadRawRC(ErrorReg);   
0000ac  2006              MOVS     r0,#6
0000ae  f7fffffe          BL       ReadRawRC
0000b2  9001              STR      r0,[sp,#4]
;;;525             if(!(temp&0x1B))
0000b4  211b              MOVS     r1,#0x1b
0000b6  9801              LDR      r0,[sp,#4]
0000b8  4208              TST      r0,r1
0000ba  d130              BNE      |L11.286|
;;;526             {
;;;527                 status = MI_OK;
0000bc  2000              MOVS     r0,#0
0000be  9004              STR      r0,[sp,#0x10]
;;;528                 if (n & irqEn & 0x01)
0000c0  9803              LDR      r0,[sp,#0xc]
0000c2  4020              ANDS     r0,r0,r4
0000c4  07c0              LSLS     r0,r0,#31
0000c6  0fc0              LSRS     r0,r0,#31
0000c8  d001              BEQ      |L11.206|
;;;529                 {   status = MI_NOTAGERR;   }
0000ca  2001              MOVS     r0,#1
0000cc  9004              STR      r0,[sp,#0x10]
                  |L11.206|
;;;530                 if (Command == PCD_TRANSCEIVE)
0000ce  2e0c              CMP      r6,#0xc
0000d0  d127              BNE      |L11.290|
;;;531                 {
;;;532                   	n = ReadRawRC(FIFOLevelReg);
0000d2  200a              MOVS     r0,#0xa
0000d4  f7fffffe          BL       ReadRawRC
0000d8  4604              MOV      r4,r0
;;;533                  	lastBits = ReadRawRC(ControlReg) & 0x07;
0000da  200c              MOVS     r0,#0xc
0000dc  f7fffffe          BL       ReadRawRC
0000e0  0747              LSLS     r7,r0,#29
0000e2  0f7f              LSRS     r7,r7,#29
;;;534                    if (lastBits)
0000e4  2f00              CMP      r7,#0
0000e6  d005              BEQ      |L11.244|
;;;535                    {   *pOutLenBit = (n-1)*8 + lastBits;   }
0000e8  1e60              SUBS     r0,r4,#1
0000ea  00c0              LSLS     r0,r0,#3
0000ec  19c1              ADDS     r1,r0,r7
0000ee  980e              LDR      r0,[sp,#0x38]
0000f0  6001              STR      r1,[r0,#0]
0000f2  e002              B        |L11.250|
                  |L11.244|
;;;536                    else
;;;537                    {   *pOutLenBit = n*8;   }
0000f4  00e1              LSLS     r1,r4,#3
0000f6  980e              LDR      r0,[sp,#0x38]
0000f8  6001              STR      r1,[r0,#0]
                  |L11.250|
;;;538                    if (n == 0)
0000fa  2c00              CMP      r4,#0
0000fc  d100              BNE      |L11.256|
;;;539                    {   n = 1;    }
0000fe  2401              MOVS     r4,#1
                  |L11.256|
;;;540                    if (n > MAXRLEN)
000100  2c12              CMP      r4,#0x12
000102  dd00              BLE      |L11.262|
;;;541                    {   n = MAXRLEN;   }
000104  2412              MOVS     r4,#0x12
                  |L11.262|
;;;542                    for (i=0; i<n; i++)
000106  2500              MOVS     r5,#0
000108  e006              B        |L11.280|
                  |L11.266|
;;;543                    {   pOutData[i] = ReadRawRC(FIFODataReg);    }
00010a  2009              MOVS     r0,#9
00010c  f7fffffe          BL       ReadRawRC
000110  4601              MOV      r1,r0
000112  9808              LDR      r0,[sp,#0x20]
000114  5541              STRB     r1,[r0,r5]
000116  1c6d              ADDS     r5,r5,#1              ;542
                  |L11.280|
000118  42a5              CMP      r5,r4                 ;542
00011a  d3f6              BCC      |L11.266|
00011c  e001              B        |L11.290|
                  |L11.286|
;;;544                }
;;;545             }
;;;546             else
;;;547             {   status = MI_ERR;   }
00011e  2002              MOVS     r0,#2
000120  9004              STR      r0,[sp,#0x10]
                  |L11.290|
;;;548            
;;;549       }
;;;550       
;;;551    
;;;552       SetBitMask(ControlReg,0x80);           // stop timer now
000122  2180              MOVS     r1,#0x80
000124  200c              MOVS     r0,#0xc
000126  f7fffffe          BL       SetBitMask
;;;553       WriteRawRC(CommandReg,PCD_IDLE); 
00012a  2100              MOVS     r1,#0
00012c  2001              MOVS     r0,#1
00012e  f7fffffe          BL       WriteRawRC
;;;554       return status;
000132  9804              LDR      r0,[sp,#0x10]
;;;555    }
000134  b009              ADD      sp,sp,#0x24
000136  bdf0              POP      {r4-r7,pc}
;;;556    
                          ENDP


                          AREA ||i.PcdHalt||, CODE, READONLY, ALIGN=1

                  PcdHalt PROC
;;;260    /////////////////////////////////////////////////////////////////////
;;;261    char PcdHalt(void)
000000  b500              PUSH     {lr}
;;;262    {
000002  b087              SUB      sp,sp,#0x1c
;;;263    //    char status;
;;;264        unsigned int  unLen;
;;;265        unsigned char ucComMF522Buf[MAXRLEN]; 
;;;266    
;;;267        ucComMF522Buf[0] = PICC_HALT;
000004  2150              MOVS     r1,#0x50
000006  4668              MOV      r0,sp
000008  7101              STRB     r1,[r0,#4]
;;;268        ucComMF522Buf[1] = 0;
00000a  2100              MOVS     r1,#0
00000c  7141              STRB     r1,[r0,#5]
;;;269        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
00000e  1d82              ADDS     r2,r0,#6
000010  2102              MOVS     r1,#2
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       CalulateCRC
;;;270     
;;;271    /*    status = */PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
000018  a806              ADD      r0,sp,#0x18
00001a  ab01              ADD      r3,sp,#4
00001c  2204              MOVS     r2,#4
00001e  a901              ADD      r1,sp,#4
000020  9000              STR      r0,[sp,#0]
000022  200c              MOVS     r0,#0xc
000024  f7fffffe          BL       PcdComMF522
;;;272    
;;;273        return MI_OK;
000028  2000              MOVS     r0,#0
;;;274    }
00002a  b007              ADD      sp,sp,#0x1c
00002c  bd00              POP      {pc}
;;;275    
                          ENDP


                          AREA ||i.PcdRead||, CODE, READONLY, ALIGN=1

                  PcdRead PROC
;;;195    ///////////////////////////////////////////////////////////////////// 
;;;196    char PcdRead(unsigned char addr,unsigned char *pData)
000000  b5f0              PUSH     {r4-r7,lr}
;;;197    {
000002  b087              SUB      sp,sp,#0x1c
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;198        char status;
;;;199        unsigned int  unLen;
;;;200        unsigned char i,ucComMF522Buf[MAXRLEN]; 
;;;201    
;;;202        ucComMF522Buf[0] = PICC_READ;
000008  2130              MOVS     r1,#0x30
00000a  4668              MOV      r0,sp
00000c  7101              STRB     r1,[r0,#4]
;;;203        ucComMF522Buf[1] = addr;
00000e  7145              STRB     r5,[r0,#5]
;;;204        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
000010  1d82              ADDS     r2,r0,#6
000012  2102              MOVS     r1,#2
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       CalulateCRC
;;;205       
;;;206        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
00001a  a806              ADD      r0,sp,#0x18
00001c  ab01              ADD      r3,sp,#4
00001e  2204              MOVS     r2,#4
000020  a901              ADD      r1,sp,#4
000022  9000              STR      r0,[sp,#0]
000024  200c              MOVS     r0,#0xc
000026  f7fffffe          BL       PcdComMF522
00002a  4607              MOV      r7,r0
;;;207        if ((status == MI_OK) && (unLen == 0x90))
00002c  2f00              CMP      r7,#0
00002e  d10c              BNE      |L13.74|
000030  9806              LDR      r0,[sp,#0x18]
000032  2890              CMP      r0,#0x90
000034  d109              BNE      |L13.74|
;;;208     //   {   memcpy(pData, ucComMF522Buf, 16);   }
;;;209        {
;;;210            for (i=0; i<16; i++)
000036  2400              MOVS     r4,#0
000038  e004              B        |L13.68|
                  |L13.58|
;;;211            {    *(pData+i) = ucComMF522Buf[i];   }
00003a  a801              ADD      r0,sp,#4
00003c  5d00              LDRB     r0,[r0,r4]
00003e  5530              STRB     r0,[r6,r4]
000040  1c60              ADDS     r0,r4,#1              ;210
000042  b2c4              UXTB     r4,r0                 ;210
                  |L13.68|
000044  2c10              CMP      r4,#0x10              ;210
000046  dbf8              BLT      |L13.58|
000048  e000              B        |L13.76|
                  |L13.74|
;;;212        }
;;;213        else
;;;214        {   status = MI_ERR;   }
00004a  2702              MOVS     r7,#2
                  |L13.76|
;;;215        
;;;216        return status;
00004c  4638              MOV      r0,r7
;;;217    }
00004e  b007              ADD      sp,sp,#0x1c
000050  bdf0              POP      {r4-r7,pc}
;;;218    
                          ENDP


                          AREA ||i.PcdRequest||, CODE, READONLY, ALIGN=1

                  PcdRequest PROC
;;;54     /////////////////////////////////////////////////////////////////////
;;;55     char PcdRequest(unsigned char req_code,unsigned char *pTagType)
000000  b570              PUSH     {r4-r6,lr}
;;;56     {
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;57        char status;  
;;;58        unsigned int  unLen;
;;;59        unsigned char ucComMF522Buf[MAXRLEN]; 
;;;60     //  unsigned char xTest ;
;;;61        ClearBitMask(Status2Reg,0x08);
000008  2108              MOVS     r1,#8
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       ClearBitMask
;;;62        WriteRawRC(BitFramingReg,0x07);
000010  2107              MOVS     r1,#7
000012  200d              MOVS     r0,#0xd
000014  f7fffffe          BL       WriteRawRC
;;;63     
;;;64     //  xTest = ReadRawRC(BitFramingReg);
;;;65     //  if(xTest == 0x07 )
;;;66      //   { LED_GREEN  =0 ;}
;;;67      // else {LED_GREEN =1 ;while(1){}}
;;;68        SetBitMask(TxControlReg,0x03);
000018  2103              MOVS     r1,#3
00001a  2014              MOVS     r0,#0x14
00001c  f7fffffe          BL       SetBitMask
;;;69      
;;;70        ucComMF522Buf[0] = req_code;
000020  4668              MOV      r0,sp
000022  7205              STRB     r5,[r0,#8]
;;;71     
;;;72        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
000024  a807              ADD      r0,sp,#0x1c
000026  ab02              ADD      r3,sp,#8
000028  2201              MOVS     r2,#1
00002a  a902              ADD      r1,sp,#8
00002c  9000              STR      r0,[sp,#0]
00002e  200c              MOVS     r0,#0xc
000030  f7fffffe          BL       PcdComMF522
000034  4606              MOV      r6,r0
;;;73     //     if(status  == MI_OK )
;;;74     //   { LED_GREEN  =0 ;}
;;;75     //   else {LED_GREEN =1 ;}
;;;76        if ((status == MI_OK) && (unLen == 0x10))
000036  2e00              CMP      r6,#0
000038  d109              BNE      |L14.78|
00003a  9807              LDR      r0,[sp,#0x1c]
00003c  2810              CMP      r0,#0x10
00003e  d106              BNE      |L14.78|
;;;77        {    
;;;78            *pTagType     = ucComMF522Buf[0];
000040  4668              MOV      r0,sp
000042  7a00              LDRB     r0,[r0,#8]
000044  7020              STRB     r0,[r4,#0]
;;;79            *(pTagType+1) = ucComMF522Buf[1];
000046  4668              MOV      r0,sp
000048  7a40              LDRB     r0,[r0,#9]
00004a  7060              STRB     r0,[r4,#1]
00004c  e000              B        |L14.80|
                  |L14.78|
;;;80        }
;;;81        else
;;;82        {   status = MI_ERR;   }
00004e  2602              MOVS     r6,#2
                  |L14.80|
;;;83        
;;;84        return status;
000050  4630              MOV      r0,r6
;;;85     }
000052  b008              ADD      sp,sp,#0x20
000054  bd70              POP      {r4-r6,pc}
;;;86     
                          ENDP


                          AREA ||i.PcdReset||, CODE, READONLY, ALIGN=2

                  PcdReset PROC
;;;302    /////////////////////////////////////////////////////////////////////
;;;303    char PcdReset(void)
000000  b510              PUSH     {r4,lr}
;;;304    {
;;;305    //	unsigned char tmp;
;;;306    
;;;307        SET_RC522_RST();//MF522_RST=1;
000002  210b              MOVS     r1,#0xb
000004  481c              LDR      r0,|L15.120|
000006  f7fffffe          BL       GPIO_SetBit
;;;308        __nop();  __nop();__nop();__nop();__nop();
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  bf00              NOP      
000012  bf00              NOP      
;;;309        CLS_RC522_RST();//MF522_RST=0;
000014  210b              MOVS     r1,#0xb
000016  4818              LDR      r0,|L15.120|
000018  f7fffffe          BL       GPIO_ClrBit
;;;310        __nop(); __nop();__nop();__nop();__nop();
00001c  bf00              NOP      
00001e  bf00              NOP      
000020  bf00              NOP      
000022  bf00              NOP      
000024  bf00              NOP      
;;;311        SET_RC522_RST();//MF522_RST=1;
000026  210b              MOVS     r1,#0xb
000028  4813              LDR      r0,|L15.120|
00002a  f7fffffe          BL       GPIO_SetBit
;;;312        __nop();__nop();__nop();__nop();__nop();
00002e  bf00              NOP      
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
;;;313    
;;;314    //   tmp = ReadRawRC(0x02);
;;;315    //   tmp = ReadRawRC(0x04); 
;;;316    
;;;317        WriteRawRC(CommandReg,PCD_RESETPHASE);
000038  210f              MOVS     r1,#0xf
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       WriteRawRC
;;;318        __nop();
000040  bf00              NOP      
;;;319        
;;;320        WriteRawRC(ModeReg,0x3D);            //和Mifare卡通讯，CRC初始值0x6363
000042  213d              MOVS     r1,#0x3d
000044  2011              MOVS     r0,#0x11
000046  f7fffffe          BL       WriteRawRC
;;;321        WriteRawRC(TReloadRegL,30);           
00004a  211e              MOVS     r1,#0x1e
00004c  202d              MOVS     r0,#0x2d
00004e  f7fffffe          BL       WriteRawRC
;;;322        WriteRawRC(TReloadRegH,0);
000052  2100              MOVS     r1,#0
000054  202c              MOVS     r0,#0x2c
000056  f7fffffe          BL       WriteRawRC
;;;323        WriteRawRC(TModeReg,0x8D);
00005a  218d              MOVS     r1,#0x8d
00005c  202a              MOVS     r0,#0x2a
00005e  f7fffffe          BL       WriteRawRC
;;;324        WriteRawRC(TPrescalerReg,0x3E);
000062  213e              MOVS     r1,#0x3e
000064  202b              MOVS     r0,#0x2b
000066  f7fffffe          BL       WriteRawRC
;;;325        WriteRawRC(TxAutoReg,0x40);
00006a  2140              MOVS     r1,#0x40
00006c  2015              MOVS     r0,#0x15
00006e  f7fffffe          BL       WriteRawRC
;;;326        
;;;327        return MI_OK;
000072  2000              MOVS     r0,#0
;;;328    }
000074  bd10              POP      {r4,pc}
;;;329    //////////////////////////////////////////////////////////////////////
                          ENDP

000076  0000              DCW      0x0000
                  |L15.120|
                          DCD      0x50004040

                          AREA ||i.PcdSelect||, CODE, READONLY, ALIGN=1

                  PcdSelect PROC
;;;128    /////////////////////////////////////////////////////////////////////
;;;129    char PcdSelect(unsigned char *pSnr)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
;;;131        char status;
;;;132        unsigned char i;
;;;133        unsigned int  unLen;
;;;134        unsigned char ucComMF522Buf[MAXRLEN]; 
;;;135        
;;;136        ucComMF522Buf[0] = PICC_ANTICOLL1;
000006  2193              MOVS     r1,#0x93
000008  4668              MOV      r0,sp
00000a  7201              STRB     r1,[r0,#8]
;;;137        ucComMF522Buf[1] = 0x70;
00000c  2170              MOVS     r1,#0x70
00000e  7241              STRB     r1,[r0,#9]
;;;138        ucComMF522Buf[6] = 0;
000010  2100              MOVS     r1,#0
000012  7381              STRB     r1,[r0,#0xe]
;;;139        for (i=0; i<4; i++)
000014  2400              MOVS     r4,#0
000016  e00b              B        |L16.48|
                  |L16.24|
;;;140        {
;;;141        	ucComMF522Buf[i+2] = *(pSnr+i);
000018  5d29              LDRB     r1,[r5,r4]
00001a  aa02              ADD      r2,sp,#8
00001c  1ca0              ADDS     r0,r4,#2
00001e  5411              STRB     r1,[r2,r0]
;;;142        	ucComMF522Buf[6]  ^= *(pSnr+i);
000020  4669              MOV      r1,sp
000022  7b88              LDRB     r0,[r1,#0xe]
000024  5d29              LDRB     r1,[r5,r4]
000026  4048              EORS     r0,r0,r1
000028  4669              MOV      r1,sp
00002a  7388              STRB     r0,[r1,#0xe]
00002c  1c60              ADDS     r0,r4,#1              ;139
00002e  b2c4              UXTB     r4,r0                 ;139
                  |L16.48|
000030  2c04              CMP      r4,#4                 ;139
000032  dbf1              BLT      |L16.24|
;;;143        }
;;;144        CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
000034  aa03              ADD      r2,sp,#0xc
000036  3203              ADDS     r2,#3
000038  2107              MOVS     r1,#7
00003a  a802              ADD      r0,sp,#8
00003c  f7fffffe          BL       CalulateCRC
;;;145      
;;;146        ClearBitMask(Status2Reg,0x08);
000040  2108              MOVS     r1,#8
000042  4608              MOV      r0,r1
000044  f7fffffe          BL       ClearBitMask
;;;147    
;;;148        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
000048  a807              ADD      r0,sp,#0x1c
00004a  ab02              ADD      r3,sp,#8
00004c  2209              MOVS     r2,#9
00004e  a902              ADD      r1,sp,#8
000050  9000              STR      r0,[sp,#0]
000052  200c              MOVS     r0,#0xc
000054  f7fffffe          BL       PcdComMF522
000058  4606              MOV      r6,r0
;;;149        
;;;150        if ((status == MI_OK) && (unLen == 0x18))
00005a  2e00              CMP      r6,#0
00005c  d103              BNE      |L16.102|
00005e  9807              LDR      r0,[sp,#0x1c]
000060  2818              CMP      r0,#0x18
000062  d100              BNE      |L16.102|
;;;151        {   status = MI_OK;  }
000064  e000              B        |L16.104|
                  |L16.102|
;;;152        else
;;;153        {   status = MI_ERR;    }
000066  2602              MOVS     r6,#2
                  |L16.104|
;;;154    
;;;155        return status;
000068  4630              MOV      r0,r6
;;;156    }
00006a  b008              ADD      sp,sp,#0x20
00006c  bd70              POP      {r4-r6,pc}
;;;157    
                          ENDP


                          AREA ||i.PcdValue||, CODE, READONLY, ALIGN=1

                  PcdValue PROC
;;;590    /////////////////////////////////////////////////////////////////////                 
;;;591    char PcdValue(unsigned char dd_mode,unsigned char addr,unsigned char *pValue)
000000  b5f0              PUSH     {r4-r7,lr}
;;;592    {
000002  b087              SUB      sp,sp,#0x1c
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;593        char status;
;;;594        unsigned int  unLen;
;;;595        unsigned char ucComMF522Buf[MAXRLEN]; 
;;;596        
;;;597        ucComMF522Buf[0] = dd_mode;
00000a  4668              MOV      r0,sp
00000c  7106              STRB     r6,[r0,#4]
;;;598        ucComMF522Buf[1] = addr;
00000e  7145              STRB     r5,[r0,#5]
;;;599        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
000010  1d82              ADDS     r2,r0,#6
000012  2102              MOVS     r1,#2
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       CalulateCRC
;;;600     
;;;601        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
00001a  a806              ADD      r0,sp,#0x18
00001c  ab01              ADD      r3,sp,#4
00001e  2204              MOVS     r2,#4
000020  a901              ADD      r1,sp,#4
000022  9000              STR      r0,[sp,#0]
000024  200c              MOVS     r0,#0xc
000026  f7fffffe          BL       PcdComMF522
00002a  4604              MOV      r4,r0
;;;602    
;;;603        if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
00002c  2c00              CMP      r4,#0
00002e  d108              BNE      |L17.66|
000030  9806              LDR      r0,[sp,#0x18]
000032  2804              CMP      r0,#4
000034  d105              BNE      |L17.66|
000036  4668              MOV      r0,sp
000038  7900              LDRB     r0,[r0,#4]
00003a  0700              LSLS     r0,r0,#28
00003c  0f00              LSRS     r0,r0,#28
00003e  280a              CMP      r0,#0xa
000040  d000              BEQ      |L17.68|
                  |L17.66|
;;;604        {   status = MI_ERR;   }
000042  2402              MOVS     r4,#2
                  |L17.68|
;;;605            
;;;606        if (status == MI_OK)
000044  2c00              CMP      r4,#0
000046  d117              BNE      |L17.120|
;;;607        {
;;;608            memcpy(ucComMF522Buf, pValue, 4);
000048  2204              MOVS     r2,#4
00004a  4639              MOV      r1,r7
00004c  a801              ADD      r0,sp,#4
00004e  f7fffffe          BL       __aeabi_memcpy
;;;609     //       for (i=0; i<16; i++)
;;;610     //       {    ucComMF522Buf[i] = *(pValue+i);   }
;;;611            CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
000052  aa02              ADD      r2,sp,#8
000054  2104              MOVS     r1,#4
000056  a801              ADD      r0,sp,#4
000058  f7fffffe          BL       CalulateCRC
;;;612            unLen = 0;
00005c  2000              MOVS     r0,#0
00005e  9006              STR      r0,[sp,#0x18]
;;;613            status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
000060  a806              ADD      r0,sp,#0x18
000062  ab01              ADD      r3,sp,#4
000064  2206              MOVS     r2,#6
000066  a901              ADD      r1,sp,#4
000068  9000              STR      r0,[sp,#0]
00006a  200c              MOVS     r0,#0xc
00006c  f7fffffe          BL       PcdComMF522
000070  4604              MOV      r4,r0
;;;614            if (status != MI_ERR)
000072  2c02              CMP      r4,#2
000074  d000              BEQ      |L17.120|
;;;615            {    status = MI_OK;    }
000076  2400              MOVS     r4,#0
                  |L17.120|
;;;616        }
;;;617        
;;;618        if (status == MI_OK)
000078  2c00              CMP      r4,#0
00007a  d11d              BNE      |L17.184|
;;;619        {
;;;620            ucComMF522Buf[0] = PICC_TRANSFER;
00007c  21b0              MOVS     r1,#0xb0
00007e  4668              MOV      r0,sp
000080  7101              STRB     r1,[r0,#4]
;;;621            ucComMF522Buf[1] = addr;
000082  7145              STRB     r5,[r0,#5]
;;;622            CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]); 
000084  1d82              ADDS     r2,r0,#6
000086  2102              MOVS     r1,#2
000088  a801              ADD      r0,sp,#4
00008a  f7fffffe          BL       CalulateCRC
;;;623       
;;;624            status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
00008e  a806              ADD      r0,sp,#0x18
000090  ab01              ADD      r3,sp,#4
000092  2204              MOVS     r2,#4
000094  a901              ADD      r1,sp,#4
000096  9000              STR      r0,[sp,#0]
000098  200c              MOVS     r0,#0xc
00009a  f7fffffe          BL       PcdComMF522
00009e  4604              MOV      r4,r0
;;;625    
;;;626            if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
0000a0  2c00              CMP      r4,#0
0000a2  d108              BNE      |L17.182|
0000a4  9806              LDR      r0,[sp,#0x18]
0000a6  2804              CMP      r0,#4
0000a8  d105              BNE      |L17.182|
0000aa  4668              MOV      r0,sp
0000ac  7900              LDRB     r0,[r0,#4]
0000ae  0700              LSLS     r0,r0,#28
0000b0  0f00              LSRS     r0,r0,#28
0000b2  280a              CMP      r0,#0xa
0000b4  d000              BEQ      |L17.184|
                  |L17.182|
;;;627            {   status = MI_ERR;   }
0000b6  2402              MOVS     r4,#2
                  |L17.184|
;;;628        }
;;;629        return status;
0000b8  4620              MOV      r0,r4
;;;630    }
0000ba  b007              ADD      sp,sp,#0x1c
0000bc  bdf0              POP      {r4-r7,pc}
;;;631    
                          ENDP


                          AREA ||i.PcdWrite||, CODE, READONLY, ALIGN=1

                  PcdWrite PROC
;;;224    /////////////////////////////////////////////////////////////////////                  
;;;225    char PcdWrite(unsigned char addr,unsigned char *pData)
000000  b5f0              PUSH     {r4-r7,lr}
;;;226    {
000002  b087              SUB      sp,sp,#0x1c
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;227        char status;
;;;228        unsigned int  unLen;
;;;229        unsigned char i,ucComMF522Buf[MAXRLEN]; 
;;;230        
;;;231        ucComMF522Buf[0] = PICC_WRITE;
000008  21a0              MOVS     r1,#0xa0
00000a  4668              MOV      r0,sp
00000c  7101              STRB     r1,[r0,#4]
;;;232        ucComMF522Buf[1] = addr;
00000e  7146              STRB     r6,[r0,#5]
;;;233        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
000010  1d82              ADDS     r2,r0,#6
000012  2102              MOVS     r1,#2
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       CalulateCRC
;;;234     
;;;235        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
00001a  a806              ADD      r0,sp,#0x18
00001c  ab01              ADD      r3,sp,#4
00001e  2204              MOVS     r2,#4
000020  a901              ADD      r1,sp,#4
000022  9000              STR      r0,[sp,#0]
000024  200c              MOVS     r0,#0xc
000026  f7fffffe          BL       PcdComMF522
00002a  4605              MOV      r5,r0
;;;236    
;;;237        if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
00002c  2d00              CMP      r5,#0
00002e  d108              BNE      |L18.66|
000030  9806              LDR      r0,[sp,#0x18]
000032  2804              CMP      r0,#4
000034  d105              BNE      |L18.66|
000036  4668              MOV      r0,sp
000038  7900              LDRB     r0,[r0,#4]
00003a  0700              LSLS     r0,r0,#28
00003c  0f00              LSRS     r0,r0,#28
00003e  280a              CMP      r0,#0xa
000040  d000              BEQ      |L18.68|
                  |L18.66|
;;;238        {   status = MI_ERR;   }
000042  2502              MOVS     r5,#2
                  |L18.68|
;;;239            
;;;240        if (status == MI_OK)
000044  2d00              CMP      r5,#0
000046  d122              BNE      |L18.142|
;;;241        {
;;;242            //memcpy(ucComMF522Buf, pData, 16);
;;;243            for (i=0; i<16; i++)
000048  2400              MOVS     r4,#0
00004a  e004              B        |L18.86|
                  |L18.76|
;;;244            {    ucComMF522Buf[i] = *(pData+i);   }
00004c  5d38              LDRB     r0,[r7,r4]
00004e  a901              ADD      r1,sp,#4
000050  5508              STRB     r0,[r1,r4]
000052  1c60              ADDS     r0,r4,#1              ;243
000054  b2c4              UXTB     r4,r0                 ;243
                  |L18.86|
000056  2c10              CMP      r4,#0x10              ;243
000058  dbf8              BLT      |L18.76|
;;;245            CalulateCRC(ucComMF522Buf,16,&ucComMF522Buf[16]);
00005a  aa05              ADD      r2,sp,#0x14
00005c  2110              MOVS     r1,#0x10
00005e  a801              ADD      r0,sp,#4
000060  f7fffffe          BL       CalulateCRC
;;;246    
;;;247            status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,18,ucComMF522Buf,&unLen);
000064  a806              ADD      r0,sp,#0x18
000066  ab01              ADD      r3,sp,#4
000068  2212              MOVS     r2,#0x12
00006a  a901              ADD      r1,sp,#4
00006c  9000              STR      r0,[sp,#0]
00006e  200c              MOVS     r0,#0xc
000070  f7fffffe          BL       PcdComMF522
000074  4605              MOV      r5,r0
;;;248            if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
000076  2d00              CMP      r5,#0
000078  d108              BNE      |L18.140|
00007a  9806              LDR      r0,[sp,#0x18]
00007c  2804              CMP      r0,#4
00007e  d105              BNE      |L18.140|
000080  4668              MOV      r0,sp
000082  7900              LDRB     r0,[r0,#4]
000084  0700              LSLS     r0,r0,#28
000086  0f00              LSRS     r0,r0,#28
000088  280a              CMP      r0,#0xa
00008a  d000              BEQ      |L18.142|
                  |L18.140|
;;;249            {   status = MI_ERR;   }
00008c  2502              MOVS     r5,#2
                  |L18.142|
;;;250        }
;;;251        
;;;252        return status;
00008e  4628              MOV      r0,r5
;;;253    }
000090  b007              ADD      sp,sp,#0x1c
000092  bdf0              POP      {r4-r7,pc}
;;;254    
                          ENDP


                          AREA ||i.Rc522Init||, CODE, READONLY, ALIGN=2

                  Rc522Init PROC
;;;8      
;;;9      void Rc522Init(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;10     {
;;;11     	SPI_DATA_T conf;
;;;12     
;;;13     	/* RC522 pin */
;;;14     	MFP_SPI1_SS0_TO_PORTB();
000002  2005              MOVS     r0,#5
000004  0700              LSLS     r0,r0,#28
000006  6b80              LDR      r0,[r0,#0x38]
000008  0c00              LSRS     r0,r0,#16
00000a  0400              LSLS     r0,r0,#16
00000c  491b              LDR      r1,|L19.124|
00000e  1840              ADDS     r0,r0,r1
000010  2105              MOVS     r1,#5
000012  0709              LSLS     r1,r1,#28
000014  6388              STR      r0,[r1,#0x38]
;;;15     	
;;;16     	SPI_Init(SPI1);
000016  481a              LDR      r0,|L19.128|
000018  f7fffffe          BL       SPI_Init
;;;17     	
;;;18     	/* Configure SPI0 as a master, 32-bit transaction*/
;;;19     	conf.u32Mode = SPI_MODE_MASTER;
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
;;;20     	conf.u32Type = SPI_TYPE0;
000020  2004              MOVS     r0,#4
000022  9001              STR      r0,[sp,#4]
;;;21     	conf.i32BitLength = 32;	
000024  2020              MOVS     r0,#0x20
000026  9002              STR      r0,[sp,#8]
;;;22     	SPI_Open(SPI0, &conf);	
000028  4669              MOV      r1,sp
00002a  4816              LDR      r0,|L19.132|
00002c  f7fffffe          BL       SPI_Open
;;;23     	
;;;24     	/* Diable AutoSS */
;;;25     	SPI_DisableAutoSS(SPI1);
000030  bf00              NOP      
000032  4813              LDR      r0,|L19.128|
000034  68c0              LDR      r0,[r0,#0xc]
000036  2108              MOVS     r1,#8
000038  4388              BICS     r0,r0,r1
00003a  4911              LDR      r1,|L19.128|
00003c  60c8              STR      r0,[r1,#0xc]
00003e  bf00              NOP      
;;;26     	
;;;27     	/* Set the active level of slave select. */
;;;28     	SPI_SetSlaveSelectActiveLow(SPI1);
000040  bf00              NOP      
000042  4608              MOV      r0,r1
000044  68c0              LDR      r0,[r0,#0xc]
000046  2104              MOVS     r1,#4
000048  4388              BICS     r0,r0,r1
00004a  490d              LDR      r1,|L19.128|
00004c  60c8              STR      r0,[r1,#0xc]
00004e  bf00              NOP      
;;;29     	
;;;30     	/* SPI clock rate 2MHz */
;;;31     	SPI_SetClockFreq(SPI1, 1000000, 0);
000050  2200              MOVS     r2,#0
000052  490d              LDR      r1,|L19.136|
000054  480a              LDR      r0,|L19.128|
000056  f7fffffe          BL       SPI_SetClockFreq
;;;32     
;;;33     	/*打开RC522电源*/
;;;34     	CLS_RC522_PWR();
00005a  210a              MOVS     r1,#0xa
00005c  480b              LDR      r0,|L19.140|
00005e  f7fffffe          BL       GPIO_ClrBit
;;;35     	delay_10ms(10);
000062  200a              MOVS     r0,#0xa
000064  f7fffffe          BL       delay_10ms
;;;36     
;;;37     	PcdReset();
000068  f7fffffe          BL       PcdReset
;;;38     	PcdAntennaOff(); 
00006c  f7fffffe          BL       PcdAntennaOff
;;;39     	PcdAntennaOn();  
000070  f7fffffe          BL       PcdAntennaOn
;;;40     	M500PcdConfigISOType( 'A' );
000074  2041              MOVS     r0,#0x41
000076  f7fffffe          BL       M500PcdConfigISOType
;;;41     }                       
00007a  bd0e              POP      {r1-r3,pc}
;;;42     /////////////////////////////////////////////////////////////////////
                          ENDP

                  |L19.124|
                          DCD      0x00003333
                  |L19.128|
                          DCD      0x40130000
                  |L19.132|
                          DCD      0x40030000
                  |L19.136|
                          DCD      0x000f4240
                  |L19.140|
                          DCD      0x50004040

                          AREA ||i.ReadRawRC||, CODE, READONLY, ALIGN=2

                  ReadRawRC PROC
;;;382    /////////////////////////////////////////////////////////////////////
;;;383    unsigned char ReadRawRC(unsigned char Address)
000000  b51c              PUSH     {r2-r4,lr}
;;;384    {
000002  4604              MOV      r4,r0
;;;385        uint32_t ucResult=0, temp;
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;386    
;;;387    	// configure transaction length as 8 bits
;;;388    	SPI_SetBitLength(SPI1, 8);	
000008  2108              MOVS     r1,#8
00000a  4819              LDR      r0,|L20.112|
00000c  f7fffffe          BL       SPI_SetBitLength
;;;389    
;;;390    	// /CS: active
;;;391    	SPI_SetSS(SPI1, SPI_SS0);	
000010  2101              MOVS     r1,#1
000012  4817              LDR      r0,|L20.112|
000014  f7fffffe          BL       SPI_SetSS
;;;392    
;;;393        temp = ((Address<<1)&0x7E) | 0x80;			/*   write Address */
000018  0060              LSLS     r0,r4,#1
00001a  217e              MOVS     r1,#0x7e
00001c  4008              ANDS     r0,r0,r1
00001e  3080              ADDS     r0,r0,#0x80
000020  9000              STR      r0,[sp,#0]
;;;394        SPI_SingleWrite(SPI1, &temp);
000022  4669              MOV      r1,sp
000024  4812              LDR      r0,|L20.112|
000026  f7fffffe          BL       SPI_SingleWrite
;;;395    	// wait
;;;396    	while (SPI_IsBusy(SPI1)) {}
00002a  bf00              NOP      
                  |L20.44|
00002c  4810              LDR      r0,|L20.112|
00002e  f7fffffe          BL       SPI_IsBusy
000032  2800              CMP      r0,#0
000034  d1fa              BNE      |L20.44|
;;;397    
;;;398    	temp = 0xFF;
000036  20ff              MOVS     r0,#0xff
000038  9000              STR      r0,[sp,#0]
;;;399    
;;;400        SPI_SingleWrite(SPI1, &temp);
00003a  4669              MOV      r1,sp
00003c  480c              LDR      r0,|L20.112|
00003e  f7fffffe          BL       SPI_SingleWrite
;;;401    	// wait
;;;402    	while (SPI_IsBusy(SPI1)) {}
000042  bf00              NOP      
                  |L20.68|
000044  480a              LDR      r0,|L20.112|
000046  f7fffffe          BL       SPI_IsBusy
00004a  2800              CMP      r0,#0
00004c  d1fa              BNE      |L20.68|
;;;403    
;;;404    	SPI_SingleRead(SPI1, &ucResult);
00004e  a901              ADD      r1,sp,#4
000050  4807              LDR      r0,|L20.112|
000052  f7fffffe          BL       SPI_SingleRead
;;;405    	// wait
;;;406    	while (SPI_IsBusy(SPI1)) {}
000056  bf00              NOP      
                  |L20.88|
000058  4805              LDR      r0,|L20.112|
00005a  f7fffffe          BL       SPI_IsBusy
00005e  2800              CMP      r0,#0
000060  d1fa              BNE      |L20.88|
;;;407    
;;;408    	SPI_ClrSS(SPI1, SPI_SS0); 
000062  2101              MOVS     r1,#1
000064  4802              LDR      r0,|L20.112|
000066  f7fffffe          BL       SPI_ClrSS
;;;409    
;;;410        return ucResult;
00006a  9801              LDR      r0,[sp,#4]
00006c  b2c0              UXTB     r0,r0
;;;411    }
00006e  bd1c              POP      {r2-r4,pc}
;;;412    
                          ENDP

                  |L20.112|
                          DCD      0x40130000

                          AREA ||i.SPI_ClrSS||, CODE, READONLY, ALIGN=1

                  SPI_ClrSS PROC
;;;247      */
;;;248    static __INLINE void SPI_ClrSS(SPI_TypeDef *SpiPort, SPI_SLAVE_SEL eSlaveSel)
000000  68c2              LDR      r2,[r0,#0xc]
;;;249    {	
;;;250    	SpiPort->SSR &= ~eSlaveSel;	
000002  438a              BICS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;251    }
000006  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.SPI_IsBusy||, CODE, READONLY, ALIGN=1

                  SPI_IsBusy PROC
;;;258      */
;;;259    static __INLINE uint8_t SPI_IsBusy(SPI_TypeDef *SpiPort)
000000  4601              MOV      r1,r0
;;;260    {
;;;261        return ((SpiPort->CTL & SPI_CTL_GO_BUSY)?TRUE:FALSE);
000002  6808              LDR      r0,[r1,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
;;;262    }
000008  4770              BX       lr
;;;263    
                          ENDP


                          AREA ||i.SPI_SetSS||, CODE, READONLY, ALIGN=1

                  SPI_SetSS PROC
;;;235      */
;;;236    static __INLINE void SPI_SetSS(SPI_TypeDef *SpiPort, SPI_SLAVE_SEL eSlaveSel)
000000  68c2              LDR      r2,[r0,#0xc]
;;;237    {
;;;238        SpiPort->SSR = (SpiPort->SSR & ~SPI_SSR_SSR_MASK) | eSlaveSel;
000002  0892              LSRS     r2,r2,#2
000004  0092              LSLS     r2,r2,#2
000006  430a              ORRS     r2,r2,r1
000008  60c2              STR      r2,[r0,#0xc]
;;;239    }
00000a  4770              BX       lr
;;;240    
                          ENDP


                          AREA ||i.SetBitMask||, CODE, READONLY, ALIGN=1

                  SetBitMask PROC
;;;445    /////////////////////////////////////////////////////////////////////
;;;446    void SetBitMask(unsigned char reg,unsigned char mask)  
000000  b570              PUSH     {r4-r6,lr}
;;;447    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;448        char tmp = 0x0;
000006  2600              MOVS     r6,#0
;;;449        tmp = ReadRawRC(reg);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       ReadRawRC
00000e  4606              MOV      r6,r0
;;;450        WriteRawRC(reg,tmp | mask);  // set bit mask
000010  4630              MOV      r0,r6
000012  4320              ORRS     r0,r0,r4
000014  4601              MOV      r1,r0
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       WriteRawRC
;;;451    }
00001c  bd70              POP      {r4-r6,pc}
;;;452    
                          ENDP


                          AREA ||i.WriteRawRC||, CODE, READONLY, ALIGN=2

                  WriteRawRC PROC
;;;417    /////////////////////////////////////////////////////////////////////
;;;418    void WriteRawRC(unsigned char Address, unsigned char value)
000000  b538              PUSH     {r3-r5,lr}
;;;419    {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;420    	uint32_t  temp;
;;;421        /* SPI RC522 */
;;;422    	// configure transaction length as 8 bits
;;;423    	SPI_SetBitLength(SPI1, 8);	
000006  2108              MOVS     r1,#8
000008  4812              LDR      r0,|L25.84|
00000a  f7fffffe          BL       SPI_SetBitLength
;;;424    
;;;425    	// /CS: active
;;;426    	SPI_SetSS(SPI1, SPI_SS0);	
00000e  2101              MOVS     r1,#1
000010  4810              LDR      r0,|L25.84|
000012  f7fffffe          BL       SPI_SetSS
;;;427    
;;;428        temp = ((Address<<1)&0x7E);			/*   write Address */
000016  0060              LSLS     r0,r4,#1
000018  217e              MOVS     r1,#0x7e
00001a  4008              ANDS     r0,r0,r1
00001c  9000              STR      r0,[sp,#0]
;;;429        SPI_SingleWrite(SPI1, &temp);
00001e  4669              MOV      r1,sp
000020  480c              LDR      r0,|L25.84|
000022  f7fffffe          BL       SPI_SingleWrite
;;;430    	// wait
;;;431    	while (SPI_IsBusy(SPI1)) {}
000026  bf00              NOP      
                  |L25.40|
000028  480a              LDR      r0,|L25.84|
00002a  f7fffffe          BL       SPI_IsBusy
00002e  2800              CMP      r0,#0
000030  d1fa              BNE      |L25.40|
;;;432    
;;;433        temp = value;						/* write value */
000032  9500              STR      r5,[sp,#0]
;;;434        SPI_SingleWrite(SPI1, &temp);
000034  4669              MOV      r1,sp
000036  4807              LDR      r0,|L25.84|
000038  f7fffffe          BL       SPI_SingleWrite
;;;435    	// wait
;;;436    	while (SPI_IsBusy(SPI1)) {}
00003c  bf00              NOP      
                  |L25.62|
00003e  4805              LDR      r0,|L25.84|
000040  f7fffffe          BL       SPI_IsBusy
000044  2800              CMP      r0,#0
000046  d1fa              BNE      |L25.62|
;;;437    
;;;438    	SPI_ClrSS(SPI1, SPI_SS0);
000048  2101              MOVS     r1,#1
00004a  4802              LDR      r0,|L25.84|
00004c  f7fffffe          BL       SPI_ClrSS
;;;439    }
000050  bd38              POP      {r3-r5,pc}
;;;440    
                          ENDP

000052  0000              DCW      0x0000
                  |L25.84|
                          DCD      0x40130000

                          AREA ||i.delay_10ms||, CODE, READONLY, ALIGN=2

                  delay_10ms PROC
;;;685    ///////////////////////////////////////////////////////////////////////
;;;686    void delay_10ms(unsigned int t)
000000  4b04              LDR      r3,|L26.20|
;;;687    {
;;;688    	uint32_t i;
;;;689    	uint32_t j;
;;;690    
;;;691    	j=60000000/1000*t;
000002  4343              MULS     r3,r0,r3
000004  461a              MOV      r2,r3
;;;692    	for(i = 0; i < j; i++);
000006  2100              MOVS     r1,#0
000008  e000              B        |L26.12|
                  |L26.10|
00000a  1c49              ADDS     r1,r1,#1
                  |L26.12|
00000c  4291              CMP      r1,r2
00000e  d3fc              BCC      |L26.10|
;;;693    	return;	
;;;694    }
000010  4770              BX       lr
                          ENDP

000012  0000              DCW      0x0000
                  |L26.20|
                          DCD      0x0000ea60

;*** Start embedded assembler ***

#line 1 "Users\\RC522.C"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_RC522_C_cbc389e5____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_RC522_C_cbc389e5____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_RC522_C_cbc389e5____REVSH|
#line 144
|__asm___7_RC522_C_cbc389e5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
