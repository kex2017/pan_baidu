; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\obj\mifare.o --depend=.\obj\mifare.d --feedback=.\obj\START_KIT.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Libraries -I.\Include -I.\Users -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\Nuvoton -D__MICROLIB -D__LCDDISPLAY_BTL001_LB_H --omf_browse=.\obj\mifare.crf Users\Mifare.c]
                          THUMB

                          AREA ||i.AnticollSelect||, CODE, READONLY, ALIGN=1

                  AnticollSelect PROC
;;;759    **************************************************/
;;;760    short AnticollSelect(unsigned char bcnt, unsigned char *snr)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;761    {
000002  b087              SUB      sp,sp,#0x1c
000004  460f              MOV      r7,r1
;;;762        unsigned char i;
;;;763        short status=STATUS_SUCCESS;
000006  2500              MOVS     r5,#0
;;;764        unsigned char length, casc_code, length_in,sak,tmpSnr[12];
;;;765        length_in = bcnt;
000008  9e07              LDR      r6,[sp,#0x1c]
;;;766        /* do loop for max. cascade level */
;;;767        for(i=0;i<MAX_CASCADE_LEVELS;i++)
00000a  2400              MOVS     r4,#0
00000c  e048              B        |L1.160|
                  |L1.14|
;;;768        {
;;;769            if(length_in)
00000e  2e00              CMP      r6,#0
000010  d009              BEQ      |L1.38|
;;;770            {
;;;771                if(length_in > SINGLE_UID_LENGTH)
000012  2e20              CMP      r6,#0x20
000014  dd04              BLE      |L1.32|
;;;772                {
;;;773                    length = SINGLE_UID_LENGTH;
000016  2020              MOVS     r0,#0x20
000018  9006              STR      r0,[sp,#0x18]
;;;774                    length_in -= SINGLE_UID_LENGTH;
00001a  1a30              SUBS     r0,r6,r0
00001c  b2c6              UXTB     r6,r0
00001e  e004              B        |L1.42|
                  |L1.32|
;;;775                }
;;;776                else
;;;777                {
;;;778                    length = length_in;
000020  9606              STR      r6,[sp,#0x18]
;;;779                    length_in = 0;
000022  2600              MOVS     r6,#0
000024  e001              B        |L1.42|
                  |L1.38|
;;;780                }
;;;781            }
;;;782            else
;;;783            {
;;;784                length = 0;
000026  2000              MOVS     r0,#0
000028  9006              STR      r0,[sp,#0x18]
                  |L1.42|
;;;785            }
;;;786    
;;;787            switch(i)
00002a  2c01              CMP      r4,#1
00002c  d002              BEQ      |L1.52|
00002e  2c02              CMP      r4,#2
000030  d10c              BNE      |L1.76|
000032  e008              B        |L1.70|
                  |L1.52|
;;;788            {
;;;789                case 1:  casc_code = SELECT_CASCADE_LEVEL_2;
000034  2095              MOVS     r0,#0x95
000036  9005              STR      r0,[sp,#0x14]
;;;790                         memcpy(snr, tmpSnr+1,3);
000038  2203              MOVS     r2,#3
00003a  a901              ADD      r1,sp,#4
00003c  3101              ADDS     r1,#1
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       __aeabi_memcpy
;;;791                         break;
000044  e005              B        |L1.82|
                  |L1.70|
;;;792                case 2:  casc_code = SELECT_CASCADE_LEVEL_3;
000046  2097              MOVS     r0,#0x97
000048  9005              STR      r0,[sp,#0x14]
;;;793                         break;
00004a  e002              B        |L1.82|
                  |L1.76|
;;;794                default: casc_code = SELECT_CASCADE_LEVEL_1;
00004c  2093              MOVS     r0,#0x93
00004e  9005              STR      r0,[sp,#0x14]
;;;795                         break;
000050  bf00              NOP      
                  |L1.82|
000052  bf00              NOP                            ;791
;;;796            }
;;;797    
;;;798            if(length != SINGLE_UID_LENGTH && status == STATUS_SUCCESS)
000054  9806              LDR      r0,[sp,#0x18]
000056  2820              CMP      r0,#0x20
000058  d009              BEQ      |L1.110|
00005a  2d00              CMP      r5,#0
00005c  d107              BNE      |L1.110|
;;;799            /* do anticollission with selected level */
;;;800            status = CascAnticoll(casc_code,
00005e  00a0              LSLS     r0,r4,#2
000060  a901              ADD      r1,sp,#4
000062  1842              ADDS     r2,r0,r1
000064  9906              LDR      r1,[sp,#0x18]
000066  9805              LDR      r0,[sp,#0x14]
000068  f7fffffe          BL       CascAnticoll
00006c  4605              MOV      r5,r0
                  |L1.110|
;;;801                                  length,
;;;802                                  tmpSnr + i * 4);
;;;803    
;;;804    
;;;805            if(status == STATUS_SUCCESS)
00006e  2d00              CMP      r5,#0
000070  d113              BNE      |L1.154|
;;;806            {
;;;807                /* select 1st cascade level uid */
;;;808                status = Select(casc_code, tmpSnr + i * 4, &sak);
000072  00a0              LSLS     r0,r4,#2
000074  aa01              ADD      r2,sp,#4
000076  1881              ADDS     r1,r0,r2
000078  aa04              ADD      r2,sp,#0x10
00007a  9805              LDR      r0,[sp,#0x14]
00007c  f7fffffe          BL       Select
000080  4605              MOV      r5,r0
;;;809    
;;;810                /* check if further cascade level is used */
;;;811                if(status == STATUS_SUCCESS)
000082  2d00              CMP      r5,#0
000084  d10a              BNE      |L1.156|
;;;812                {
;;;813                    /* increase number of received bits in parameter */
;;;814                    bcnt = (unsigned char)(SINGLE_UID_LENGTH * (i + 1)); //the actually length of the UID, you can return it.
000086  1c60              ADDS     r0,r4,#1
000088  0740              LSLS     r0,r0,#29
00008a  0e00              LSRS     r0,r0,#24
00008c  9007              STR      r0,[sp,#0x1c]
;;;815    
;;;816                    /* check if cascade bit is set */
;;;817                    if(!(sak & CASCADE_BIT))
00008e  4668              MOV      r0,sp
000090  7c00              LDRB     r0,[r0,#0x10]
000092  2104              MOVS     r1,#4
000094  4208              TST      r0,r1
000096  d101              BNE      |L1.156|
;;;818                    {
;;;819                        break;
000098  e004              B        |L1.164|
                  |L1.154|
;;;820                    }
;;;821                }
;;;822            }
;;;823            else
;;;824            {
;;;825                break;
00009a  e003              B        |L1.164|
                  |L1.156|
00009c  1c60              ADDS     r0,r4,#1              ;767
00009e  b2c4              UXTB     r4,r0                 ;767
                  |L1.160|
0000a0  2c03              CMP      r4,#3                 ;767
0000a2  dbb4              BLT      |L1.14|
                  |L1.164|
0000a4  bf00              NOP                            ;819
;;;826            }
;;;827        }
;;;828        switch(i)
0000a6  2c01              CMP      r4,#1
0000a8  d002              BEQ      |L1.176|
0000aa  2c02              CMP      r4,#2
0000ac  d10c              BNE      |L1.200|
0000ae  e005              B        |L1.188|
                  |L1.176|
;;;829        {
;;;830            case 1:  memcpy(snr+3, tmpSnr+4,4);     //copy UID to snr buffer without CT(0x88)
0000b0  2204              MOVS     r2,#4
0000b2  a902              ADD      r1,sp,#8
0000b4  1cf8              ADDS     r0,r7,#3
0000b6  f7fffffe          BL       __aeabi_memcpy
;;;831                     break;
0000ba  e00b              B        |L1.212|
                  |L1.188|
;;;832            case 2:  memcpy(snr+6, tmpSnr+4,4);
0000bc  2204              MOVS     r2,#4
0000be  a902              ADD      r1,sp,#8
0000c0  1db8              ADDS     r0,r7,#6
0000c2  f7fffffe          BL       __aeabi_memcpy
;;;833                     break;
0000c6  e005              B        |L1.212|
                  |L1.200|
;;;834            default: memcpy(snr, tmpSnr,4);
0000c8  2204              MOVS     r2,#4
0000ca  a901              ADD      r1,sp,#4
0000cc  4638              MOV      r0,r7
0000ce  f7fffffe          BL       __aeabi_memcpy
;;;835                     break;
0000d2  bf00              NOP      
                  |L1.212|
0000d4  bf00              NOP                            ;831
;;;836        }
;;;837        return status;
0000d6  4628              MOV      r0,r5
;;;838    }
0000d8  b009              ADD      sp,sp,#0x24
0000da  bdf0              POP      {r4-r7,pc}
;;;839    
                          ENDP


                          AREA ||i.Authentication||, CODE, READONLY, ALIGN=2

                  Authentication PROC
;;;877    **************************************************/
;;;878    short Authentication(unsigned char auth_mode,
000000  b5ff              PUSH     {r0-r7,lr}
;;;879                         unsigned char *key,
;;;880                         unsigned char *snr,
;;;881                         unsigned char addr)
;;;882    {
000002  b081              SUB      sp,sp,#4
000004  4605              MOV      r5,r0
000006  4617              MOV      r7,r2
000008  461e              MOV      r6,r3
;;;883        short status;
;;;884        unsigned char RegVal;
;;;885    
;;;886        ResetInfo(MInfo);
00000a  2000              MOVS     r0,#0
00000c  4919              LDR      r1,|L2.116|
00000e  7008              STRB     r0,[r1,#0]
000010  7048              STRB     r0,[r1,#1]
000012  7088              STRB     r0,[r1,#2]
000014  70c8              STRB     r0,[r1,#3]
000016  7108              STRB     r0,[r1,#4]
000018  80c8              STRH     r0,[r1,#6]
00001a  7208              STRB     r0,[r1,#8]
;;;887    
;;;888        SerBuffer[0] = auth_mode;      //key A or key B
00001c  4816              LDR      r0,|L2.120|
00001e  7005              STRB     r5,[r0,#0]
;;;889        SerBuffer[1] = addr;           //address to authentication
000020  7046              STRB     r6,[r0,#1]
;;;890        memcpy(SerBuffer+2,key,6);     //6 bytes key
000022  2206              MOVS     r2,#6
000024  1c80              ADDS     r0,r0,#2
000026  9902              LDR      r1,[sp,#8]
000028  f7fffffe          BL       __aeabi_memcpy
;;;891        memcpy(SerBuffer+8,snr,4);     //4 bytes UID
00002c  2204              MOVS     r2,#4
00002e  4639              MOV      r1,r7
000030  4811              LDR      r0,|L2.120|
000032  3008              ADDS     r0,r0,#8
000034  f7fffffe          BL       __aeabi_memcpy
;;;892        MInfo.nBytesToSend = 12;       //length
000038  200c              MOVS     r0,#0xc
00003a  490e              LDR      r1,|L2.116|
00003c  70c8              STRB     r0,[r1,#3]
;;;893        SetTimeOut(2000);
00003e  207d              MOVS     r0,#0x7d
000040  0100              LSLS     r0,r0,#4
000042  f7fffffe          BL       SetTimeOut
;;;894        status = M522PcdCmd(JCMD_AUTHENT, SerBuffer, &MInfo);
000046  4a0b              LDR      r2,|L2.116|
000048  490b              LDR      r1,|L2.120|
00004a  200e              MOVS     r0,#0xe
00004c  f7fffffe          BL       M522PcdCmd
000050  9000              STR      r0,[sp,#0]
;;;895        if(status == STATUS_SUCCESS)
000052  9800              LDR      r0,[sp,#0]
000054  2800              CMP      r0,#0
000056  d109              BNE      |L2.108|
;;;896        {
;;;897            RegVal = RcGetReg(JREG_STATUS2);
000058  2008              MOVS     r0,#8
00005a  f7fffffe          BL       RcGetReg
00005e  4604              MOV      r4,r0
;;;898            if((RegVal & 0x0f) != 0x08)
000060  0720              LSLS     r0,r4,#28
000062  0f00              LSRS     r0,r0,#28
000064  2808              CMP      r0,#8
000066  d001              BEQ      |L2.108|
;;;899                status = STATUS_AUTHENT_ERROR;
000068  2005              MOVS     r0,#5
00006a  9000              STR      r0,[sp,#0]
                  |L2.108|
;;;900        }
;;;901        return status;
00006c  9800              LDR      r0,[sp,#0]
;;;902    }
00006e  b005              ADD      sp,sp,#0x14
000070  bdf0              POP      {r4-r7,pc}
;;;903    
                          ENDP

000072  0000              DCW      0x0000
                  |L2.116|
                          DCD      MInfo
                  |L2.120|
                          DCD      SerBuffer

                          AREA ||i.CascAnticoll||, CODE, READONLY, ALIGN=2

                  CascAnticoll PROC
;;;590    **************************************************/
;;;591    short CascAnticoll(unsigned char sel_code,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;592                       unsigned char bitcount,
;;;593                       unsigned char *snr)
;;;594    {
000002  b086              SUB      sp,sp,#0x18
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;595        short status = STATUS_SUCCESS;
000008  2000              MOVS     r0,#0
00000a  9005              STR      r0,[sp,#0x14]
;;;596        short istatus = STATUS_SUCCESS;
00000c  9004              STR      r0,[sp,#0x10]
;;;597    
;;;598        unsigned char  i;
;;;599        unsigned char  complete = 0; /* signs end of anticollission loop */
00000e  9003              STR      r0,[sp,#0xc]
;;;600        unsigned char  rbits    = 0; /* number of total received bits */
000010  9002              STR      r0,[sp,#8]
;;;601        unsigned char  nbits    = 0; /* */
000012  9001              STR      r0,[sp,#4]
;;;602        unsigned char  nbytes   = 0; /* */
000014  2700              MOVS     r7,#0
;;;603        unsigned char  byteOffset;   /* stores offset for ID copy if uncomplete last byte was sent */
;;;604    
;;;605        /* initialise relvant bytes in internal buffer */
;;;606        for(i=2;i<7;i++)
000016  2502              MOVS     r5,#2
000018  e004              B        |L3.36|
                  |L3.26|
;;;607            SerBuffer[i] = 0x00;
00001a  2000              MOVS     r0,#0
00001c  4966              LDR      r1,|L3.440|
00001e  5548              STRB     r0,[r1,r5]
000020  1c68              ADDS     r0,r5,#1              ;606
000022  b2c5              UXTB     r5,r0                 ;606
                  |L3.36|
000024  2d07              CMP      r5,#7                 ;606
000026  dbf8              BLT      |L3.26|
;;;608    
;;;609        /* disable TxCRC and RxCRC */
;;;610        RcModifyReg(JREG_TXMODE, 0, JBIT_CRCEN);
000028  2280              MOVS     r2,#0x80
00002a  2100              MOVS     r1,#0
00002c  2012              MOVS     r0,#0x12
00002e  f7fffffe          BL       RcModifyReg
;;;611        RcModifyReg(JREG_RXMODE, 0, JBIT_CRCEN);
000032  2280              MOVS     r2,#0x80
000034  2100              MOVS     r1,#0
000036  2013              MOVS     r0,#0x13
000038  f7fffffe          BL       RcModifyReg
;;;612    
;;;613        /* activate deletion of bits after coll */
;;;614        RcSetReg(JREG_COLL, 0);
00003c  2100              MOVS     r1,#0
00003e  200e              MOVS     r0,#0xe
000040  f7fffffe          BL       RcSetReg
;;;615    
;;;616        /* init parameters for anticollision */
;;;617        while(!complete && (istatus == STATUS_SUCCESS))
000044  e0a5              B        |L3.402|
                  |L3.70|
;;;618        {
;;;619             /* if there is a communication problem on the RF interface, bcnt
;;;620                could be larger than 32 - folowing loops will be defective. */
;;;621            if(bitcount > SINGLE_UID_LENGTH)
000046  2c20              CMP      r4,#0x20
000048  dd02              BLE      |L3.80|
;;;622            {
;;;623                istatus = STATUS_INVALID_PARAMETER;
00004a  2014              MOVS     r0,#0x14
00004c  9004              STR      r0,[sp,#0x10]
;;;624                continue;
00004e  e0a0              B        |L3.402|
                  |L3.80|
;;;625            }
;;;626    
;;;627            /* prepare data length */
;;;628            nbits = (unsigned char)(bitcount % BITS_PER_BYTE);
000050  4620              MOV      r0,r4
000052  17e1              ASRS     r1,r4,#31
000054  0f49              LSRS     r1,r1,#29
000056  1909              ADDS     r1,r1,r4
000058  10c9              ASRS     r1,r1,#3
00005a  00c9              LSLS     r1,r1,#3
00005c  1a61              SUBS     r1,r4,r1
00005e  b2c9              UXTB     r1,r1
000060  9101              STR      r1,[sp,#4]
;;;629            nbytes = (unsigned char)(bitcount / BITS_PER_BYTE);
000062  17e1              ASRS     r1,r4,#31
000064  0f49              LSRS     r1,r1,#29
000066  1909              ADDS     r1,r1,r4
000068  10cf              ASRS     r7,r1,#3
;;;630            if(nbits)
00006a  9801              LDR      r0,[sp,#4]
00006c  2800              CMP      r0,#0
00006e  d001              BEQ      |L3.116|
;;;631                nbytes++;
000070  1c78              ADDS     r0,r7,#1
000072  b2c7              UXTB     r7,r0
                  |L3.116|
;;;632    
;;;633            /* prepare data buffer */
;;;634            SerBuffer[0] = sel_code;
000074  4950              LDR      r1,|L3.440|
000076  9806              LDR      r0,[sp,#0x18]
000078  7008              STRB     r0,[r1,#0]
;;;635            SerBuffer[1] = (unsigned char)(NVB_MIN_PARAMETER + ((bitcount / BITS_PER_BYTE) << UPPER_NIBBLE_SHIFT) + nbits);
00007a  4620              MOV      r0,r4
00007c  17e1              ASRS     r1,r4,#31
00007e  0f49              LSRS     r1,r1,#29
000080  1909              ADDS     r1,r1,r4
000082  10c9              ASRS     r1,r1,#3
000084  0109              LSLS     r1,r1,#4
000086  3120              ADDS     r1,r1,#0x20
000088  9a01              LDR      r2,[sp,#4]
00008a  1889              ADDS     r1,r1,r2
00008c  4a4a              LDR      r2,|L3.440|
00008e  7051              STRB     r1,[r2,#1]
;;;636            for(i=0;i<nbytes;i++)
000090  2500              MOVS     r5,#0
000092  e005              B        |L3.160|
                  |L3.148|
;;;637                SerBuffer[2+i] = snr[i];   /* copy serial number to tranmit buffer */
000094  5d71              LDRB     r1,[r6,r5]
000096  1ca8              ADDS     r0,r5,#2
000098  4a47              LDR      r2,|L3.440|
00009a  5411              STRB     r1,[r2,r0]
00009c  1c68              ADDS     r0,r5,#1              ;636
00009e  b2c5              UXTB     r5,r0                 ;636
                  |L3.160|
0000a0  42bd              CMP      r5,r7                 ;636
0000a2  dbf7              BLT      |L3.148|
;;;638    
;;;639            /* set TxLastBits and RxAlign to number of bits sent */
;;;640            RcSetReg(JREG_BITFRAMING, (unsigned char)((nbits << UPPER_NIBBLE_SHIFT) | nbits));
0000a4  9801              LDR      r0,[sp,#4]
0000a6  0100              LSLS     r0,r0,#4
0000a8  9a01              LDR      r2,[sp,#4]
0000aa  4310              ORRS     r0,r0,r2
0000ac  b2c1              UXTB     r1,r0
0000ae  200d              MOVS     r0,#0xd
0000b0  f7fffffe          BL       RcSetReg
;;;641    
;;;642            /* prepare data for common transceive */
;;;643            ResetInfo(MInfo);
0000b4  2000              MOVS     r0,#0
0000b6  4941              LDR      r1,|L3.444|
0000b8  7008              STRB     r0,[r1,#0]
0000ba  7048              STRB     r0,[r1,#1]
0000bc  7088              STRB     r0,[r1,#2]
0000be  70c8              STRB     r0,[r1,#3]
0000c0  7108              STRB     r0,[r1,#4]
0000c2  80c8              STRH     r0,[r1,#6]
0000c4  7208              STRB     r0,[r1,#8]
;;;644            MInfo.nBytesToSend   = (unsigned char)(nbytes + 2);
0000c6  1cb8              ADDS     r0,r7,#2
0000c8  70c8              STRB     r0,[r1,#3]
;;;645    
;;;646            SetTimeOut(300);
0000ca  20ff              MOVS     r0,#0xff
0000cc  302d              ADDS     r0,r0,#0x2d
0000ce  f7fffffe          BL       SetTimeOut
;;;647            status = M522PcdCmd(JCMD_TRANSCEIVE, SerBuffer, &MInfo);
0000d2  4a3a              LDR      r2,|L3.444|
0000d4  4938              LDR      r1,|L3.440|
0000d6  200c              MOVS     r0,#0xc
0000d8  f7fffffe          BL       M522PcdCmd
0000dc  9005              STR      r0,[sp,#0x14]
;;;648    
;;;649            if(istatus == STATUS_COLLISION_ERROR || istatus == STATUS_SUCCESS)
0000de  9804              LDR      r0,[sp,#0x10]
0000e0  2807              CMP      r0,#7
0000e2  d002              BEQ      |L3.234|
0000e4  9804              LDR      r0,[sp,#0x10]
0000e6  2800              CMP      r0,#0
0000e8  d152              BNE      |L3.400|
                  |L3.234|
;;;650            {
;;;651                /* store number of received data bits and bytes internaly */
;;;652                rbits = (unsigned char)(MInfo.nBitsReceived + (MInfo.nBytesReceived << 3) - nbits);
0000ea  4834              LDR      r0,|L3.444|
0000ec  88c0              LDRH     r0,[r0,#6]  ; MInfo
0000ee  4933              LDR      r1,|L3.444|
0000f0  7909              LDRB     r1,[r1,#4]  ; MInfo
0000f2  00c9              LSLS     r1,r1,#3
0000f4  1841              ADDS     r1,r0,r1
0000f6  9801              LDR      r0,[sp,#4]
0000f8  1a08              SUBS     r0,r1,r0
0000fa  b2c0              UXTB     r0,r0
0000fc  9002              STR      r0,[sp,#8]
;;;653    
;;;654                if((rbits + bitcount) > COMPLETE_UID_BITS)
0000fe  9802              LDR      r0,[sp,#8]
000100  1900              ADDS     r0,r0,r4
000102  2828              CMP      r0,#0x28
000104  dd02              BLE      |L3.268|
;;;655                {
;;;656                    istatus = STATUS_BITCOUNT_ERROR;
000106  2002              MOVS     r0,#2
000108  9004              STR      r0,[sp,#0x10]
;;;657                    continue;
00010a  e042              B        |L3.402|
                  |L3.268|
;;;658                }
;;;659    
;;;660                /* increment number of bytes received if also some bits received */
;;;661                if(MInfo.nBitsReceived)
00010c  482b              LDR      r0,|L3.444|
00010e  88c0              LDRH     r0,[r0,#6]  ; MInfo
000110  2800              CMP      r0,#0
000112  d004              BEQ      |L3.286|
;;;662                    MInfo.nBytesReceived++;
000114  4829              LDR      r0,|L3.444|
000116  7900              LDRB     r0,[r0,#4]  ; MInfo
000118  1c40              ADDS     r0,r0,#1
00011a  4928              LDR      r1,|L3.444|
00011c  7108              STRB     r0,[r1,#4]
                  |L3.286|
;;;663    
;;;664                /* reset offset for data copying */
;;;665                byteOffset = 0;
00011e  2000              MOVS     r0,#0
000120  9000              STR      r0,[sp,#0]
;;;666                /* if number of bits sent are not 0, write first received byte in last of sent */
;;;667                if(nbits)
000122  9801              LDR      r0,[sp,#4]
000124  2800              CMP      r0,#0
000126  d00a              BEQ      |L3.318|
;;;668                {   /* last byte transmitted and first byte received are the same */
;;;669                    snr[nbytes - 1] |= SerBuffer[0];
000128  1e78              SUBS     r0,r7,#1
00012a  5c30              LDRB     r0,[r6,r0]
00012c  4922              LDR      r1,|L3.440|
00012e  7809              LDRB     r1,[r1,#0]  ; SerBuffer
000130  4308              ORRS     r0,r0,r1
000132  1e79              SUBS     r1,r7,#1
000134  5470              STRB     r0,[r6,r1]
;;;670                    byteOffset++;
000136  9800              LDR      r0,[sp,#0]
000138  1c40              ADDS     r0,r0,#1
00013a  b2c0              UXTB     r0,r0
00013c  9000              STR      r0,[sp,#0]
                  |L3.318|
;;;671                }
;;;672    
;;;673                for(i=0;i<(4-nbytes);i++)
00013e  2500              MOVS     r5,#0
000140  e007              B        |L3.338|
                  |L3.322|
;;;674                    snr[nbytes + i] = SerBuffer[i + byteOffset];
000142  9800              LDR      r0,[sp,#0]
000144  1828              ADDS     r0,r5,r0
000146  491c              LDR      r1,|L3.440|
000148  5c08              LDRB     r0,[r1,r0]
00014a  1979              ADDS     r1,r7,r5
00014c  5470              STRB     r0,[r6,r1]
00014e  1c68              ADDS     r0,r5,#1              ;673
000150  b2c5              UXTB     r5,r0                 ;673
                  |L3.338|
000152  2004              MOVS     r0,#4                 ;673
000154  1bc0              SUBS     r0,r0,r7              ;673
000156  42a8              CMP      r0,r5                 ;673
000158  dcf3              BGT      |L3.322|
;;;675    
;;;676                if(istatus == STATUS_COLLISION_ERROR)
00015a  9804              LDR      r0,[sp,#0x10]
00015c  2807              CMP      r0,#7
00015e  d105              BNE      |L3.364|
;;;677                {
;;;678                    /* calculate new bitcount value */
;;;679                    bitcount = (unsigned char)(bitcount + rbits);
000160  9802              LDR      r0,[sp,#8]
000162  1820              ADDS     r0,r4,r0
000164  b2c4              UXTB     r4,r0
;;;680                    istatus = STATUS_SUCCESS;
000166  2000              MOVS     r0,#0
000168  9004              STR      r0,[sp,#0x10]
00016a  e011              B        |L3.400|
                  |L3.364|
;;;681                } else
;;;682                {
;;;683                    if((snr[0] ^ snr[1] ^ snr[2] ^ snr[3]) != SerBuffer[i + byteOffset])
00016c  7830              LDRB     r0,[r6,#0]
00016e  7871              LDRB     r1,[r6,#1]
000170  4048              EORS     r0,r0,r1
000172  78b1              LDRB     r1,[r6,#2]
000174  4048              EORS     r0,r0,r1
000176  78f1              LDRB     r1,[r6,#3]
000178  4048              EORS     r0,r0,r1
00017a  9900              LDR      r1,[sp,#0]
00017c  1869              ADDS     r1,r5,r1
00017e  4a0e              LDR      r2,|L3.440|
000180  5c51              LDRB     r1,[r2,r1]
000182  4288              CMP      r0,r1
000184  d002              BEQ      |L3.396|
;;;684                    {
;;;685                        istatus = STATUS_WRONG_UID_CHECKBYTE;
000186  2006              MOVS     r0,#6
000188  9004              STR      r0,[sp,#0x10]
;;;686                        continue;
00018a  e002              B        |L3.402|
                  |L3.396|
;;;687                    }
;;;688                    complete=1;
00018c  2001              MOVS     r0,#1
00018e  9003              STR      r0,[sp,#0xc]
                  |L3.400|
000190  bf00              NOP                            ;624
                  |L3.402|
000192  9803              LDR      r0,[sp,#0xc]          ;617
000194  2800              CMP      r0,#0                 ;617
000196  d103              BNE      |L3.416|
000198  9804              LDR      r0,[sp,#0x10]         ;617
00019a  2800              CMP      r0,#0                 ;617
00019c  d100              BNE      |L3.416|
00019e  e752              B        |L3.70|
                  |L3.416|
;;;689                }
;;;690            }
;;;691        }
;;;692    
;;;693        /* clear RxAlign and TxLastbits */
;;;694        RcSetReg(JREG_BITFRAMING, 0);
0001a0  2100              MOVS     r1,#0
0001a2  200d              MOVS     r0,#0xd
0001a4  f7fffffe          BL       RcSetReg
;;;695    
;;;696        /* activate values after coll */
;;;697        RcSetReg(JREG_COLL, JBIT_VALUESAFTERCOLL);
0001a8  2180              MOVS     r1,#0x80
0001aa  200e              MOVS     r0,#0xe
0001ac  f7fffffe          BL       RcSetReg
;;;698    
;;;699    	if(status)
;;;700    	{
;;;701    	}
;;;702    
;;;703        return istatus;
0001b0  9804              LDR      r0,[sp,#0x10]
;;;704    }
0001b2  b009              ADD      sp,sp,#0x24
0001b4  bdf0              POP      {r4-r7,pc}
;;;705    
                          ENDP

0001b6  0000              DCW      0x0000
                  |L3.440|
                          DCD      SerBuffer
                  |L3.444|
                          DCD      MInfo

                          AREA ||i.ChangeJoinerBaudRate||, CODE, READONLY, ALIGN=2

                  ChangeJoinerBaudRate PROC
;;;152    **************************************************/
;;;153    short ChangeJoinerBaudRate(unsigned long baudrate)
000000  b570              PUSH     {r4-r6,lr}
;;;154    {
000002  4605              MOV      r5,r0
;;;155        short   status = STATUS_SUCCESS;
000004  2600              MOVS     r6,#0
;;;156        unsigned char setRegVal;
;;;157        switch(baudrate)
000006  214b              MOVS     r1,#0x4b
000008  0249              LSLS     r1,r1,#9
00000a  1a68              SUBS     r0,r5,r1
00000c  428d              CMP      r5,r1
00000e  d01c              BEQ      |L4.74|
000010  dc08              BGT      |L4.36|
000012  4817              LDR      r0,|L4.112|
000014  1a28              SUBS     r0,r5,r0
000016  d012              BEQ      |L4.62|
000018  10c9              ASRS     r1,r1,#3
00001a  1a40              SUBS     r0,r0,r1
00001c  d011              BEQ      |L4.66|
00001e  1a40              SUBS     r0,r0,r1
000020  d11b              BNE      |L4.90|
000022  e010              B        |L4.70|
                  |L4.36|
000024  214b              MOVS     r1,#0x4b
000026  0209              LSLS     r1,r1,#8
000028  1a40              SUBS     r0,r0,r1
00002a  d010              BEQ      |L4.78|
00002c  21e1              MOVS     r1,#0xe1
00002e  0209              LSLS     r1,r1,#8
000030  1a40              SUBS     r0,r0,r1
000032  d00e              BEQ      |L4.82|
000034  2119              MOVS     r1,#0x19
000036  0249              LSLS     r1,r1,#9
000038  1a40              SUBS     r0,r0,r1
00003a  d10e              BNE      |L4.90|
00003c  e00b              B        |L4.86|
                  |L4.62|
;;;158        {
;;;159            case 9600:
;;;160                setRegVal = 0xEB;
00003e  24eb              MOVS     r4,#0xeb
;;;161                break;
000040  e00d              B        |L4.94|
                  |L4.66|
;;;162    
;;;163            case 14400:
;;;164                setRegVal = 0xDA;
000042  24da              MOVS     r4,#0xda
;;;165                break;
000044  e00b              B        |L4.94|
                  |L4.70|
;;;166    
;;;167            case 19200:
;;;168                setRegVal = 0xCB;
000046  24cb              MOVS     r4,#0xcb
;;;169                break;
000048  e009              B        |L4.94|
                  |L4.74|
;;;170    
;;;171            case 38400:
;;;172                setRegVal = 0xAB;
00004a  24ab              MOVS     r4,#0xab
;;;173                break;
00004c  e007              B        |L4.94|
                  |L4.78|
;;;174    
;;;175            case 57600:
;;;176                setRegVal = 0x9A;
00004e  249a              MOVS     r4,#0x9a
;;;177                break;
000050  e005              B        |L4.94|
                  |L4.82|
;;;178    
;;;179            case 115200:
;;;180                setRegVal = 0x7A;
000052  247a              MOVS     r4,#0x7a
;;;181                break;
000054  e003              B        |L4.94|
                  |L4.86|
;;;182    
;;;183            case 128000:
;;;184                setRegVal = 0x74;
000056  2474              MOVS     r4,#0x74
;;;185                break;
000058  e001              B        |L4.94|
                  |L4.90|
;;;186    
;;;187            default:
;;;188                status = STATUS_INVALID_PARAMETER;
00005a  2614              MOVS     r6,#0x14
;;;189                break;
00005c  bf00              NOP      
                  |L4.94|
00005e  bf00              NOP                            ;161
;;;190        }
;;;191    
;;;192    	/* Set the appropriate value */
;;;193    	if (status == STATUS_SUCCESS)
000060  2e00              CMP      r6,#0
000062  d103              BNE      |L4.108|
;;;194    		RcSetReg(JREG_SERIALSPEED,setRegVal);
000064  4621              MOV      r1,r4
000066  201f              MOVS     r0,#0x1f
000068  f7fffffe          BL       RcSetReg
                  |L4.108|
;;;195    	/* Now the RC522 is set to the new speed*/
;;;196        return status;
00006c  4630              MOV      r0,r6
;;;197    }
00006e  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP

                  |L4.112|
                          DCD      0x00002580

                          AREA ||i.HaltA||, CODE, READONLY, ALIGN=2

                  HaltA PROC
;;;848    **************************************************/
;;;849    short HaltA(void)
000000  b510              PUSH     {r4,lr}
;;;850    {
;;;851        short  status = STATUS_SUCCESS;
000002  2400              MOVS     r4,#0
;;;852        /* initialise data buffer */
;;;853        SerBuffer[0] = HALTA_CMD;
000004  2050              MOVS     r0,#0x50
000006  490e              LDR      r1,|L5.64|
000008  7008              STRB     r0,[r1,#0]
;;;854        SerBuffer[1] = HALTA_PARAM;
00000a  2000              MOVS     r0,#0
00000c  7048              STRB     r0,[r1,#1]
;;;855    
;;;856        ResetInfo(MInfo);
00000e  490d              LDR      r1,|L5.68|
000010  7008              STRB     r0,[r1,#0]
000012  7048              STRB     r0,[r1,#1]
000014  7088              STRB     r0,[r1,#2]
000016  70c8              STRB     r0,[r1,#3]
000018  7108              STRB     r0,[r1,#4]
00001a  80c8              STRH     r0,[r1,#6]
00001c  7208              STRB     r0,[r1,#8]
;;;857        MInfo.nBytesToSend   = HALTA_CMD_LENGTH;
00001e  2002              MOVS     r0,#2
000020  70c8              STRB     r0,[r1,#3]
;;;858        SetTimeOut(200);
000022  20c8              MOVS     r0,#0xc8
000024  f7fffffe          BL       SetTimeOut
;;;859        status = M522PcdCmd(JCMD_TRANSCEIVE, SerBuffer, &MInfo);
000028  4a06              LDR      r2,|L5.68|
00002a  4905              LDR      r1,|L5.64|
00002c  200c              MOVS     r0,#0xc
00002e  f7fffffe          BL       M522PcdCmd
000032  4604              MOV      r4,r0
;;;860    
;;;861        if(status == STATUS_IO_TIMEOUT)
000034  2c01              CMP      r4,#1
000036  d100              BNE      |L5.58|
;;;862            status = STATUS_SUCCESS;
000038  2400              MOVS     r4,#0
                  |L5.58|
;;;863        return status;
00003a  4620              MOV      r0,r4
;;;864    }
00003c  bd10              POP      {r4,pc}
;;;865    
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      SerBuffer
                  |L5.68|
                          DCD      MInfo

                          AREA ||i.InitBlock||, CODE, READONLY, ALIGN=1

                  InitBlock PROC
;;;1162   **************************************************/
;;;1163   short InitBlock(unsigned char addr,unsigned char *value)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1164   {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;1165   	unsigned char tmp[16],i;
;;;1166   	short status = STATUS_SUCCESS;
000008  2700              MOVS     r7,#0
;;;1167   	for(i=0;i<4;i++)
00000a  2400              MOVS     r4,#0
00000c  e00e              B        |L6.44|
                  |L6.14|
;;;1168   	{
;;;1169   		tmp[i]=value[i];
00000e  5d28              LDRB     r0,[r5,r4]
000010  4669              MOV      r1,sp
000012  5508              STRB     r0,[r1,r4]
;;;1170   		tmp[i+4]=255-value[i];
000014  5d28              LDRB     r0,[r5,r4]
000016  21ff              MOVS     r1,#0xff
000018  1a08              SUBS     r0,r1,r0
00001a  466a              MOV      r2,sp
00001c  1d21              ADDS     r1,r4,#4
00001e  5450              STRB     r0,[r2,r1]
;;;1171   		tmp[i+8]=value[i];
000020  5d29              LDRB     r1,[r5,r4]
000022  4620              MOV      r0,r4
000024  3008              ADDS     r0,r0,#8
000026  5411              STRB     r1,[r2,r0]
000028  1c60              ADDS     r0,r4,#1              ;1167
00002a  b2c4              UXTB     r4,r0                 ;1167
                  |L6.44|
00002c  2c04              CMP      r4,#4                 ;1167
00002e  dbee              BLT      |L6.14|
;;;1172   	}
;;;1173   	tmp[12]=addr;
000030  4668              MOV      r0,sp
000032  7306              STRB     r6,[r0,#0xc]
;;;1174   	tmp[13]=255-addr;
000034  20ff              MOVS     r0,#0xff
000036  1b81              SUBS     r1,r0,r6
000038  4668              MOV      r0,sp
00003a  7341              STRB     r1,[r0,#0xd]
;;;1175   	tmp[14]=tmp[12];
00003c  7b01              LDRB     r1,[r0,#0xc]
00003e  7381              STRB     r1,[r0,#0xe]
;;;1176   	tmp[15]=tmp[13];
000040  7b41              LDRB     r1,[r0,#0xd]
000042  73c1              STRB     r1,[r0,#0xf]
;;;1177   	status=Write(addr,tmp);
000044  4669              MOV      r1,sp
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       Write
00004c  4607              MOV      r7,r0
;;;1178   	return status;
00004e  4638              MOV      r0,r7
;;;1179   }
000050  b005              ADD      sp,sp,#0x14
000052  bdf0              POP      {r4-r7,pc}
                          ENDP


                          AREA ||i.M522PcdCmd||, CODE, READONLY, ALIGN=2

                  M522PcdCmd PROC
;;;321    **************************************************/
;;;322    short  M522PcdCmd(unsigned char cmd,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;323                     unsigned char *ExchangeBuf,
;;;324                     MfCmdInfo  *info)
;;;325    {
000002  b08a              SUB      sp,sp,#0x28
000004  4607              MOV      r7,r0
;;;326        short          status    = STATUS_SUCCESS;
000006  2000              MOVS     r0,#0
000008  9009              STR      r0,[sp,#0x24]
;;;327        short          istatus    = STATUS_SUCCESS;
00000a  9008              STR      r0,[sp,#0x20]
;;;328    
;;;329        unsigned char  commIrqEn   = 0;
00000c  9007              STR      r0,[sp,#0x1c]
;;;330        unsigned char  divIrqEn    = 0;
00000e  9006              STR      r0,[sp,#0x18]
;;;331        unsigned char  waitForComm = JBIT_ERRI | JBIT_TXI;
000010  2042              MOVS     r0,#0x42
000012  9005              STR      r0,[sp,#0x14]
;;;332        unsigned char  waitForDiv  = 0;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;333        unsigned char  doReceive   = 0;
000018  9003              STR      r0,[sp,#0xc]
;;;334        unsigned char  i;
;;;335        unsigned char  getRegVal,setRegVal;
;;;336    
;;;337        unsigned char  nbytes, nbits;
;;;338        unsigned int   counter;
;;;339    
;;;340        /*remove all Interrupt request flags that are used during function,
;;;341        keep all other like they are*/
;;;342        RcSetReg(JREG_COMMIRQ, waitForComm);
00001a  2004              MOVS     r0,#4
00001c  9905              LDR      r1,[sp,#0x14]
00001e  f7fffffe          BL       RcSetReg
;;;343        RcSetReg(JREG_DIVIRQ, waitForDiv);
000022  2005              MOVS     r0,#5
000024  9904              LDR      r1,[sp,#0x10]
000026  f7fffffe          BL       RcSetReg
;;;344        RcSetReg(JREG_FIFOLEVEL, JBIT_FLUSHBUFFER);
00002a  2180              MOVS     r1,#0x80
00002c  200a              MOVS     r0,#0xa
00002e  f7fffffe          BL       RcSetReg
;;;345    
;;;346        /*disable command or set to transceive*/
;;;347        getRegVal = RcGetReg(JREG_COMMAND);
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       RcGetReg
000038  4604              MOV      r4,r0
;;;348        if(cmd == JCMD_TRANSCEIVE)
00003a  2f0c              CMP      r7,#0xc
00003c  d108              BNE      |L7.80|
;;;349        {
;;;350            /*re-init the transceive command*/
;;;351            setRegVal = (getRegVal & ~JMASK_COMMAND) | JCMD_TRANSCEIVE;
00003e  0920              LSRS     r0,r4,#4
000040  0100              LSLS     r0,r0,#4
000042  300c              ADDS     r0,r0,#0xc
000044  b2c6              UXTB     r6,r0
;;;352            RcSetReg(JREG_COMMAND, setRegVal);//0c
000046  4631              MOV      r1,r6
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       RcSetReg
00004e  e005              B        |L7.92|
                  |L7.80|
;;;353        }
;;;354        else
;;;355        {
;;;356            /*clear current command*/
;;;357            setRegVal = (getRegVal & ~JMASK_COMMAND);
000050  0926              LSRS     r6,r4,#4
000052  0136              LSLS     r6,r6,#4
;;;358            RcSetReg(JREG_COMMAND, setRegVal);
000054  4631              MOV      r1,r6
000056  2001              MOVS     r0,#1
000058  f7fffffe          BL       RcSetReg
                  |L7.92|
;;;359        }
;;;360        MpIsrInfo = info;
00005c  49ac              LDR      r1,|L7.784|
00005e  980c              LDR      r0,[sp,#0x30]
000060  6008              STR      r0,[r1,#0]  ; MpIsrInfo
;;;361        switch(cmd)
000062  2f08              CMP      r7,#8
000064  d01b              BEQ      |L7.158|
000066  dc06              BGT      |L7.118|
000068  2f00              CMP      r7,#0
00006a  d00b              BEQ      |L7.132|
00006c  2f03              CMP      r7,#3
00006e  d00d              BEQ      |L7.140|
000070  2f04              CMP      r7,#4
000072  d128              BNE      |L7.198|
000074  e00e              B        |L7.148|
                  |L7.118|
000076  2f0c              CMP      r7,#0xc
000078  d017              BEQ      |L7.170|
00007a  2f0e              CMP      r7,#0xe
00007c  d01b              BEQ      |L7.182|
00007e  2f0f              CMP      r7,#0xf
000080  d121              BNE      |L7.198|
000082  e01c              B        |L7.190|
                  |L7.132|
;;;362        {
;;;363           case JCMD_IDLE:         /* values are 00, so return immediately after all bytes written to FIFO */
;;;364                waitForComm = 0;
000084  2000              MOVS     r0,#0
000086  9005              STR      r0,[sp,#0x14]
;;;365                waitForDiv  = 0;
000088  9004              STR      r0,[sp,#0x10]
;;;366                break;
00008a  e01f              B        |L7.204|
                  |L7.140|
;;;367            case JCMD_CALCCRC:      /* values are 00, so return immediately after all bytes written to FIFO */
;;;368                waitForComm = 0;
00008c  2000              MOVS     r0,#0
00008e  9005              STR      r0,[sp,#0x14]
;;;369                waitForDiv  = 0;
000090  9004              STR      r0,[sp,#0x10]
;;;370                break;
000092  e01b              B        |L7.204|
                  |L7.148|
;;;371            case JCMD_TRANSMIT:
;;;372                commIrqEn = JBIT_TXI | JBIT_TIMERI;
000094  2041              MOVS     r0,#0x41
000096  9007              STR      r0,[sp,#0x1c]
;;;373                waitForComm = JBIT_TXI;
000098  2040              MOVS     r0,#0x40
00009a  9005              STR      r0,[sp,#0x14]
;;;374                break;
00009c  e016              B        |L7.204|
                  |L7.158|
;;;375            case JCMD_RECEIVE:
;;;376                commIrqEn = JBIT_RXI | JBIT_TIMERI | JBIT_ERRI;
00009e  2023              MOVS     r0,#0x23
0000a0  9007              STR      r0,[sp,#0x1c]
;;;377                waitForComm = JBIT_RXI | JBIT_TIMERI | JBIT_ERRI;
0000a2  9005              STR      r0,[sp,#0x14]
;;;378                doReceive = 1;
0000a4  2001              MOVS     r0,#1
0000a6  9003              STR      r0,[sp,#0xc]
;;;379                break;
0000a8  e010              B        |L7.204|
                  |L7.170|
;;;380            case JCMD_TRANSCEIVE:
;;;381                commIrqEn = JBIT_RXI | JBIT_TIMERI | JBIT_ERRI;
0000aa  2023              MOVS     r0,#0x23
0000ac  9007              STR      r0,[sp,#0x1c]
;;;382                waitForComm = JBIT_RXI | JBIT_TIMERI | JBIT_ERRI;
0000ae  9005              STR      r0,[sp,#0x14]
;;;383                doReceive = 1;
0000b0  2001              MOVS     r0,#1
0000b2  9003              STR      r0,[sp,#0xc]
;;;384                break;
0000b4  e00a              B        |L7.204|
                  |L7.182|
;;;385            case JCMD_AUTHENT:
;;;386                commIrqEn = JBIT_IDLEI | JBIT_TIMERI | JBIT_ERRI;
0000b6  2013              MOVS     r0,#0x13
0000b8  9007              STR      r0,[sp,#0x1c]
;;;387                waitForComm = JBIT_IDLEI | JBIT_TIMERI | JBIT_ERRI;
0000ba  9005              STR      r0,[sp,#0x14]
;;;388                break;
0000bc  e006              B        |L7.204|
                  |L7.190|
;;;389            case JCMD_SOFTRESET:    /* values are 0x00 for IrqEn and for waitFor, nothing to do */
;;;390                waitForComm = 0;
0000be  2000              MOVS     r0,#0
0000c0  9005              STR      r0,[sp,#0x14]
;;;391                waitForDiv  = 0;
0000c2  9004              STR      r0,[sp,#0x10]
;;;392                break;
0000c4  e002              B        |L7.204|
                  |L7.198|
;;;393            default:
;;;394                status = STATUS_UNSUPPORTED_COMMAND;
0000c6  2013              MOVS     r0,#0x13
0000c8  9009              STR      r0,[sp,#0x24]
0000ca  bf00              NOP                            ;361
                  |L7.204|
0000cc  bf00              NOP                            ;366
;;;395        }
;;;396        if(status == STATUS_SUCCESS)
0000ce  9809              LDR      r0,[sp,#0x24]
0000d0  2800              CMP      r0,#0
0000d2  d16a              BNE      |L7.426|
;;;397        {
;;;398            /* activate necessary communication Irq's */
;;;399            getRegVal = RcGetReg(JREG_COMMIEN);
0000d4  2002              MOVS     r0,#2
0000d6  f7fffffe          BL       RcGetReg
0000da  4604              MOV      r4,r0
;;;400            RcSetReg(JREG_COMMIEN, getRegVal | commIrqEn);
0000dc  4620              MOV      r0,r4
0000de  9a07              LDR      r2,[sp,#0x1c]
0000e0  4310              ORRS     r0,r0,r2
0000e2  4601              MOV      r1,r0
0000e4  2002              MOVS     r0,#2
0000e6  f7fffffe          BL       RcSetReg
;;;401    
;;;402            /* activate necessary other Irq's */
;;;403            getRegVal = RcGetReg(JREG_DIVIEN);
0000ea  2003              MOVS     r0,#3
0000ec  f7fffffe          BL       RcGetReg
0000f0  4604              MOV      r4,r0
;;;404            RcSetReg(JREG_DIVIEN, getRegVal | divIrqEn);
0000f2  4620              MOV      r0,r4
0000f4  9a06              LDR      r2,[sp,#0x18]
0000f6  4310              ORRS     r0,r0,r2
0000f8  4601              MOV      r1,r0
0000fa  2003              MOVS     r0,#3
0000fc  f7fffffe          BL       RcSetReg
;;;405    
;;;406            /*write data to FIFO*/
;;;407            for(i=0; i<MpIsrInfo->nBytesToSend; i++)
000100  2500              MOVS     r5,#0
000102  e006              B        |L7.274|
                  |L7.260|
;;;408            {
;;;409                RcSetReg(JREG_FIFODATA, ExchangeBuf[i]);
000104  980b              LDR      r0,[sp,#0x2c]
000106  5d41              LDRB     r1,[r0,r5]
000108  2009              MOVS     r0,#9
00010a  f7fffffe          BL       RcSetReg
00010e  1c68              ADDS     r0,r5,#1              ;407
000110  b2c5              UXTB     r5,r0                 ;407
                  |L7.274|
000112  487f              LDR      r0,|L7.784|
000114  6800              LDR      r0,[r0,#0]            ;407  ; MpIsrInfo
000116  78c0              LDRB     r0,[r0,#3]            ;407
000118  42a8              CMP      r0,r5                 ;407
00011a  dcf3              BGT      |L7.260|
;;;410            }
;;;411    
;;;412            /*do seperate action if command to be executed is transceive*/
;;;413            if(cmd == JCMD_TRANSCEIVE)
00011c  2f0c              CMP      r7,#0xc
00011e  d105              BNE      |L7.300|
;;;414            {
;;;415                /*TRx is always an endless loop, Initiator and Target must set STARTSEND.*/
;;;416                RcModifyReg(JREG_BITFRAMING, 1, JBIT_STARTSEND);
000120  2280              MOVS     r2,#0x80
000122  2101              MOVS     r1,#1
000124  200d              MOVS     r0,#0xd
000126  f7fffffe          BL       RcModifyReg
00012a  e00a              B        |L7.322|
                  |L7.300|
;;;417            }
;;;418            else
;;;419            {
;;;420                getRegVal = RcGetReg(JREG_COMMAND);
00012c  2001              MOVS     r0,#1
00012e  f7fffffe          BL       RcGetReg
000132  4604              MOV      r4,r0
;;;421                RcSetReg(JREG_COMMAND, (getRegVal & ~JMASK_COMMAND) | cmd);
000134  0920              LSRS     r0,r4,#4
000136  0100              LSLS     r0,r0,#4
000138  4338              ORRS     r0,r0,r7
00013a  4601              MOV      r1,r0
00013c  2001              MOVS     r0,#1
00013e  f7fffffe          BL       RcSetReg
                  |L7.322|
;;;422            }
;;;423    
;;;424            /*polling mode*/
;;;425            getRegVal = 0;
000142  2400              MOVS     r4,#0
;;;426            setRegVal = 0;
000144  2600              MOVS     r6,#0
;;;427            counter = 0; /*Just for debug*/
000146  2000              MOVS     r0,#0
000148  9000              STR      r0,[sp,#0]
;;;428            while(!(waitForComm ? (waitForComm & setRegVal) : 1) ||
00014a  e010              B        |L7.366|
                  |L7.332|
;;;429                  !(waitForDiv ? (waitForDiv & getRegVal) :1))
;;;430            {
;;;431                setRegVal = RcGetReg(JREG_COMMIRQ);
00014c  2004              MOVS     r0,#4
00014e  f7fffffe          BL       RcGetReg
000152  4606              MOV      r6,r0
;;;432                getRegVal = RcGetReg(JREG_DIVIRQ);
000154  2005              MOVS     r0,#5
000156  f7fffffe          BL       RcGetReg
00015a  4604              MOV      r4,r0
;;;433                counter ++;
00015c  9800              LDR      r0,[sp,#0]
00015e  1c40              ADDS     r0,r0,#1
000160  9000              STR      r0,[sp,#0]
;;;434                if(counter > 0x0100)
000162  21ff              MOVS     r1,#0xff
000164  3101              ADDS     r1,#1
000166  9800              LDR      r0,[sp,#0]
000168  4288              CMP      r0,r1
00016a  d900              BLS      |L7.366|
;;;435                    break;
00016c  e011              B        |L7.402|
                  |L7.366|
00016e  9805              LDR      r0,[sp,#0x14]         ;428
000170  2800              CMP      r0,#0                 ;428
000172  d002              BEQ      |L7.378|
000174  9805              LDR      r0,[sp,#0x14]         ;428
000176  4030              ANDS     r0,r0,r6              ;428
000178  e000              B        |L7.380|
                  |L7.378|
00017a  2001              MOVS     r0,#1                 ;428
                  |L7.380|
00017c  2800              CMP      r0,#0                 ;428
00017e  d0e5              BEQ      |L7.332|
000180  9804              LDR      r0,[sp,#0x10]         ;429
000182  2800              CMP      r0,#0                 ;429
000184  d002              BEQ      |L7.396|
000186  9804              LDR      r0,[sp,#0x10]         ;429
000188  4020              ANDS     r0,r0,r4              ;429
00018a  e000              B        |L7.398|
                  |L7.396|
00018c  2001              MOVS     r0,#1                 ;429
                  |L7.398|
00018e  2800              CMP      r0,#0                 ;429
000190  d0dc              BEQ      |L7.332|
                  |L7.402|
000192  bf00              NOP      
;;;436            }
;;;437            /*store IRQ bits for clearance afterwards*/
;;;438            waitForComm = (unsigned char)(waitForComm & setRegVal);
000194  9805              LDR      r0,[sp,#0x14]
000196  4030              ANDS     r0,r0,r6
000198  9005              STR      r0,[sp,#0x14]
;;;439            waitForDiv  = (unsigned char)(waitForDiv & getRegVal);
00019a  9804              LDR      r0,[sp,#0x10]
00019c  4020              ANDS     r0,r0,r4
00019e  9004              STR      r0,[sp,#0x10]
;;;440    
;;;441            /*set status to Timer Interrupt occurence*/
;;;442            if (setRegVal & JBIT_TIMERI)
0001a0  07f0              LSLS     r0,r6,#31
0001a2  0fc0              LSRS     r0,r0,#31
0001a4  d001              BEQ      |L7.426|
;;;443            {
;;;444                istatus = STATUS_IO_TIMEOUT;
0001a6  2001              MOVS     r0,#1
0001a8  9008              STR      r0,[sp,#0x20]
                  |L7.426|
;;;445            }
;;;446        }
;;;447    
;;;448        /*disable all interrupt sources*/
;;;449        RcModifyReg(JREG_COMMIEN, 0, commIrqEn);
0001aa  2100              MOVS     r1,#0
0001ac  2002              MOVS     r0,#2
0001ae  9a07              LDR      r2,[sp,#0x1c]
0001b0  f7fffffe          BL       RcModifyReg
;;;450    
;;;451        RcModifyReg(JREG_DIVIEN, 0, divIrqEn);
0001b4  2100              MOVS     r1,#0
0001b6  2003              MOVS     r0,#3
0001b8  9a06              LDR      r2,[sp,#0x18]
0001ba  f7fffffe          BL       RcModifyReg
;;;452    
;;;453        if(doReceive && (istatus == STATUS_SUCCESS))
0001be  9803              LDR      r0,[sp,#0xc]
0001c0  2800              CMP      r0,#0
0001c2  d06f              BEQ      |L7.676|
0001c4  9808              LDR      r0,[sp,#0x20]
0001c6  2800              CMP      r0,#0
0001c8  d16c              BNE      |L7.676|
;;;454        {
;;;455            /*read number of bytes received (used for error check and correct transaction*/
;;;456            MpIsrInfo->nBytesReceived = RcGetReg(JREG_FIFOLEVEL);
0001ca  200a              MOVS     r0,#0xa
0001cc  f7fffffe          BL       RcGetReg
0001d0  494f              LDR      r1,|L7.784|
0001d2  6809              LDR      r1,[r1,#0]  ; MpIsrInfo
0001d4  7108              STRB     r0,[r1,#4]
;;;457            nbytes = MpIsrInfo->nBytesReceived;
0001d6  484e              LDR      r0,|L7.784|
0001d8  6800              LDR      r0,[r0,#0]  ; MpIsrInfo
0001da  7900              LDRB     r0,[r0,#4]
0001dc  9002              STR      r0,[sp,#8]
;;;458            getRegVal = RcGetReg(JREG_CONTROL);
0001de  200c              MOVS     r0,#0xc
0001e0  f7fffffe          BL       RcGetReg
0001e4  4604              MOV      r4,r0
;;;459            MpIsrInfo->nBitsReceived = (unsigned char)(getRegVal & 0x07);
0001e6  0760              LSLS     r0,r4,#29
0001e8  0f40              LSRS     r0,r0,#29
0001ea  4949              LDR      r1,|L7.784|
0001ec  6809              LDR      r1,[r1,#0]  ; MpIsrInfo
0001ee  80c8              STRH     r0,[r1,#6]
;;;460            nbits = MpIsrInfo->nBitsReceived;
0001f0  4847              LDR      r0,|L7.784|
0001f2  6800              LDR      r0,[r0,#0]  ; MpIsrInfo
0001f4  88c0              LDRH     r0,[r0,#6]
0001f6  b2c0              UXTB     r0,r0
0001f8  9001              STR      r0,[sp,#4]
;;;461    
;;;462            getRegVal = RcGetReg(JREG_ERROR);
0001fa  2006              MOVS     r0,#6
0001fc  f7fffffe          BL       RcGetReg
000200  4604              MOV      r4,r0
;;;463            /*set status information if error occured*/
;;;464            if(getRegVal)
000202  2c00              CMP      r4,#0
000204  d049              BEQ      |L7.666|
;;;465            {
;;;466                if(getRegVal & JBIT_COLLERR)
000206  2008              MOVS     r0,#8
000208  4204              TST      r4,r0
00020a  d002              BEQ      |L7.530|
;;;467                    istatus = STATUS_COLLISION_ERROR;         /* Collision Error */
00020c  2007              MOVS     r0,#7
00020e  9008              STR      r0,[sp,#0x20]
000210  e004              B        |L7.540|
                  |L7.530|
;;;468                else if(getRegVal & JBIT_PARITYERR)
000212  2002              MOVS     r0,#2
000214  4204              TST      r4,r0
000216  d001              BEQ      |L7.540|
;;;469                    istatus = STATUS_PARITY_ERROR;            /* Parity Error */
000218  2012              MOVS     r0,#0x12
00021a  9008              STR      r0,[sp,#0x20]
                  |L7.540|
;;;470    
;;;471                if(getRegVal & JBIT_PROTERR)
00021c  07e0              LSLS     r0,r4,#31
00021e  0fc0              LSRS     r0,r0,#31
000220  d002              BEQ      |L7.552|
;;;472                    istatus = STATUS_PROTOCOL_ERROR;          /* Protocoll Error */
000222  2011              MOVS     r0,#0x11
000224  9008              STR      r0,[sp,#0x20]
000226  e02a              B        |L7.638|
                  |L7.552|
;;;473                else if(getRegVal & JBIT_BUFFEROVFL)
000228  2010              MOVS     r0,#0x10
00022a  4204              TST      r4,r0
00022c  d001              BEQ      |L7.562|
;;;474                    istatus = STATUS_BUFFER_OVERFLOW;         /* BufferOverflow Error */
00022e  9008              STR      r0,[sp,#0x20]
000230  e025              B        |L7.638|
                  |L7.562|
;;;475                else if(getRegVal & JBIT_CRCERR)
000232  2004              MOVS     r0,#4
000234  4204              TST      r4,r0
000236  d01d              BEQ      |L7.628|
;;;476                {   /* CRC Error */
;;;477                    if(MpIsrInfo->nBytesReceived == 0x01 &&
000238  4835              LDR      r0,|L7.784|
00023a  6800              LDR      r0,[r0,#0]  ; MpIsrInfo
00023c  7900              LDRB     r0,[r0,#4]
00023e  2801              CMP      r0,#1
000240  d115              BNE      |L7.622|
;;;478                        (MpIsrInfo->nBitsReceived == 0x04 ||
000242  4833              LDR      r0,|L7.784|
000244  6800              LDR      r0,[r0,#0]  ; MpIsrInfo
000246  88c0              LDRH     r0,[r0,#6]
000248  2804              CMP      r0,#4
00024a  d004              BEQ      |L7.598|
;;;479                         MpIsrInfo->nBitsReceived == 0x00))
00024c  4830              LDR      r0,|L7.784|
00024e  6800              LDR      r0,[r0,#0]  ; MpIsrInfo
000250  88c0              LDRH     r0,[r0,#6]
000252  2800              CMP      r0,#0
000254  d10b              BNE      |L7.622|
                  |L7.598|
;;;480                    {   /* CRC Error and only one byte received might be a Mifare (N)ACK */
;;;481                        ExchangeBuf[0] = RcGetReg(JREG_FIFODATA);
000256  2009              MOVS     r0,#9
000258  f7fffffe          BL       RcGetReg
00025c  990b              LDR      r1,[sp,#0x2c]
00025e  7008              STRB     r0,[r1,#0]
;;;482                        MpIsrInfo->nBytesReceived = 1;
000260  2001              MOVS     r0,#1
000262  492b              LDR      r1,|L7.784|
000264  6809              LDR      r1,[r1,#0]  ; MpIsrInfo
000266  7108              STRB     r0,[r1,#4]
;;;483                        istatus = STATUS_ACK_SUPPOSED;        /* (N)ACK supposed */
000268  2008              MOVS     r0,#8
00026a  9008              STR      r0,[sp,#0x20]
00026c  e007              B        |L7.638|
                  |L7.622|
;;;484                    }
;;;485                    else
;;;486                        istatus = STATUS_CRC_ERROR;           /* CRC Error */
00026e  200c              MOVS     r0,#0xc
000270  9008              STR      r0,[sp,#0x20]
000272  e004              B        |L7.638|
                  |L7.628|
;;;487                }
;;;488                else if(getRegVal & JBIT_TEMPERR)
000274  2040              MOVS     r0,#0x40
000276  4204              TST      r4,r0
000278  d001              BEQ      |L7.638|
;;;489                    istatus = STATUS_JOINER_TEMP_ERROR;       /* Temperature Error */
00027a  200b              MOVS     r0,#0xb
00027c  9008              STR      r0,[sp,#0x20]
                  |L7.638|
;;;490                if(getRegVal & JBIT_WRERR)
00027e  2080              MOVS     r0,#0x80
000280  4204              TST      r4,r0
000282  d001              BEQ      |L7.648|
;;;491                    istatus = STATUS_FIFO_WRITE_ERROR;        /* Error Writing to FIFO */
000284  200a              MOVS     r0,#0xa
000286  9008              STR      r0,[sp,#0x20]
                  |L7.648|
;;;492                if(istatus == STATUS_SUCCESS)
000288  9808              LDR      r0,[sp,#0x20]
00028a  2800              CMP      r0,#0
00028c  d101              BNE      |L7.658|
;;;493                    istatus = STATUS_ERROR_NY_IMPLEMENTED;    /* Error not yet implemented, shall never occur! */
00028e  2009              MOVS     r0,#9
000290  9008              STR      r0,[sp,#0x20]
                  |L7.658|
;;;494    
;;;495                /* if an error occured, clear error register before IRQ register */
;;;496                RcSetReg(JREG_ERROR, 0);
000292  2100              MOVS     r1,#0
000294  2006              MOVS     r0,#6
000296  f7fffffe          BL       RcSetReg
                  |L7.666|
;;;497            }
;;;498    
;;;499            /*read data from FIFO and set response parameter*/
;;;500            if(istatus != STATUS_ACK_SUPPOSED)
00029a  9808              LDR      r0,[sp,#0x20]
00029c  2808              CMP      r0,#8
00029e  d01f              BEQ      |L7.736|
;;;501            {
;;;502                for(i=0; i<MpIsrInfo->nBytesReceived; i++)
0002a0  2500              MOVS     r5,#0
0002a2  e007              B        |L7.692|
                  |L7.676|
0002a4  e01c              B        |L7.736|
                  |L7.678|
;;;503                {
;;;504                    ExchangeBuf[i] = RcGetReg(JREG_FIFODATA);
0002a6  2009              MOVS     r0,#9
0002a8  f7fffffe          BL       RcGetReg
0002ac  990b              LDR      r1,[sp,#0x2c]
0002ae  5548              STRB     r0,[r1,r5]
0002b0  1c68              ADDS     r0,r5,#1              ;502
0002b2  b2c5              UXTB     r5,r0                 ;502
                  |L7.692|
0002b4  4816              LDR      r0,|L7.784|
0002b6  6800              LDR      r0,[r0,#0]            ;502  ; MpIsrInfo
0002b8  7900              LDRB     r0,[r0,#4]            ;502
0002ba  42a8              CMP      r0,r5                 ;502
0002bc  dcf3              BGT      |L7.678|
;;;505                }
;;;506                /*in case of incomplete last byte reduce number of complete bytes by 1*/
;;;507                if(MpIsrInfo->nBitsReceived && MpIsrInfo->nBytesReceived)
0002be  4814              LDR      r0,|L7.784|
0002c0  6800              LDR      r0,[r0,#0]  ; MpIsrInfo
0002c2  88c0              LDRH     r0,[r0,#6]
0002c4  2800              CMP      r0,#0
0002c6  d00b              BEQ      |L7.736|
0002c8  4811              LDR      r0,|L7.784|
0002ca  6800              LDR      r0,[r0,#0]  ; MpIsrInfo
0002cc  7900              LDRB     r0,[r0,#4]
0002ce  2800              CMP      r0,#0
0002d0  d006              BEQ      |L7.736|
;;;508                    MpIsrInfo->nBytesReceived --;
0002d2  480f              LDR      r0,|L7.784|
0002d4  6800              LDR      r0,[r0,#0]  ; MpIsrInfo
0002d6  7900              LDRB     r0,[r0,#4]
0002d8  1e40              SUBS     r0,r0,#1
0002da  490d              LDR      r1,|L7.784|
0002dc  6809              LDR      r1,[r1,#0]  ; MpIsrInfo
0002de  7108              STRB     r0,[r1,#4]
                  |L7.736|
;;;509            }
;;;510        }
;;;511        RcSetReg(JREG_COMMIRQ, waitForComm);
0002e0  2004              MOVS     r0,#4
0002e2  9905              LDR      r1,[sp,#0x14]
0002e4  f7fffffe          BL       RcSetReg
;;;512        RcSetReg(JREG_DIVIRQ, waitForDiv);
0002e8  2005              MOVS     r0,#5
0002ea  9904              LDR      r1,[sp,#0x10]
0002ec  f7fffffe          BL       RcSetReg
;;;513        RcSetReg(JREG_FIFOLEVEL, JBIT_FLUSHBUFFER);
0002f0  2180              MOVS     r1,#0x80
0002f2  200a              MOVS     r0,#0xa
0002f4  f7fffffe          BL       RcSetReg
;;;514        RcSetReg(JREG_COMMIRQ, JBIT_TIMERI);
0002f8  2101              MOVS     r1,#1
0002fa  2004              MOVS     r0,#4
0002fc  f7fffffe          BL       RcSetReg
;;;515        RcSetReg(JREG_BITFRAMING, 0);
000300  2100              MOVS     r1,#0
000302  200d              MOVS     r0,#0xd
000304  f7fffffe          BL       RcSetReg
;;;516    
;;;517    	if(nbytes)
;;;518    	{
;;;519    	}
;;;520    	if(nbits)
;;;521    	{
;;;522    	}
;;;523    
;;;524        return istatus;
000308  9808              LDR      r0,[sp,#0x20]
;;;525    }
00030a  b00d              ADD      sp,sp,#0x34
00030c  bdf0              POP      {r4-r7,pc}
;;;526    
                          ENDP

00030e  0000              DCW      0x0000
                  |L7.784|
                          DCD      MpIsrInfo

                          AREA ||i.Rc522Init||, CODE, READONLY, ALIGN=2

                  Rc522Init PROC
;;;207    **************************************************/
;;;208    void Rc522Init(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;209    {
;;;210        unsigned char RegVal;
;;;211    	SPI_DATA_T conf;
;;;212    
;;;213    	/* RC522 pin */
;;;214    	MFP_SPI1_SS0_TO_PORTB();
000002  2005              MOVS     r0,#5
000004  0700              LSLS     r0,r0,#28
000006  6b80              LDR      r0,[r0,#0x38]
000008  0c00              LSRS     r0,r0,#16
00000a  0400              LSLS     r0,r0,#16
00000c  494f              LDR      r1,|L8.332|
00000e  1840              ADDS     r0,r0,r1
000010  2105              MOVS     r1,#5
000012  0709              LSLS     r1,r1,#28
000014  6388              STR      r0,[r1,#0x38]
;;;215    	
;;;216    	SPI_Init(SPI1);
000016  484e              LDR      r0,|L8.336|
000018  f7fffffe          BL       SPI_Init
;;;217    	
;;;218    	/* Configure SPI0 as a master, 32-bit transaction*/
;;;219    	conf.u32Mode = SPI_MODE_MASTER;
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
;;;220    	conf.u32Type = SPI_TYPE0;
000020  2004              MOVS     r0,#4
000022  9001              STR      r0,[sp,#4]
;;;221    	conf.i32BitLength = 32;	
000024  2020              MOVS     r0,#0x20
000026  9002              STR      r0,[sp,#8]
;;;222    	SPI_Open(SPI0, &conf);	
000028  4669              MOV      r1,sp
00002a  484a              LDR      r0,|L8.340|
00002c  f7fffffe          BL       SPI_Open
;;;223    	
;;;224    	/* Diable AutoSS */
;;;225    	SPI_DisableAutoSS(SPI1);
000030  bf00              NOP      
000032  4847              LDR      r0,|L8.336|
000034  68c0              LDR      r0,[r0,#0xc]
000036  2108              MOVS     r1,#8
000038  4388              BICS     r0,r0,r1
00003a  4945              LDR      r1,|L8.336|
00003c  60c8              STR      r0,[r1,#0xc]
00003e  bf00              NOP      
;;;226    	
;;;227    	/* Set the active level of slave select. */
;;;228    	SPI_SetSlaveSelectActiveLow(SPI1);
000040  bf00              NOP      
000042  4608              MOV      r0,r1
000044  68c0              LDR      r0,[r0,#0xc]
000046  2104              MOVS     r1,#4
000048  4388              BICS     r0,r0,r1
00004a  4941              LDR      r1,|L8.336|
00004c  60c8              STR      r0,[r1,#0xc]
00004e  bf00              NOP      
;;;229    	
;;;230    	/* SPI clock rate 2MHz */
;;;231    	SPI_SetClockFreq(SPI1, 1000000, 0);
000050  2200              MOVS     r2,#0
000052  4941              LDR      r1,|L8.344|
000054  483e              LDR      r0,|L8.336|
000056  f7fffffe          BL       SPI_SetClockFreq
;;;232    
;;;233    	/*RC522*/
;;;234    	CLS_RC522_PWR();
00005a  bf00              NOP      
00005c  483f              LDR      r0,|L8.348|
00005e  6880              LDR      r0,[r0,#8]
000060  220a              MOVS     r2,#0xa
000062  2101              MOVS     r1,#1
000064  4091              LSLS     r1,r1,r2
000066  4388              BICS     r0,r0,r1
000068  493c              LDR      r1,|L8.348|
00006a  6088              STR      r0,[r1,#8]
00006c  bf00              NOP      
;;;235    
;;;236        RcSetReg(JREG_COMMAND, 0x0f); /*reset the RC522*/
00006e  210f              MOVS     r1,#0xf
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       RcSetReg
;;;237    
;;;238        /* disable Crypto1 bit*/
;;;239        RcModifyReg(JREG_STATUS2, 0, JBIT_CRYPTO1ON);
000076  2208              MOVS     r2,#8
000078  2100              MOVS     r1,#0
00007a  4610              MOV      r0,r2
00007c  f7fffffe          BL       RcModifyReg
;;;240    
;;;241        /* do not touch bits: InvMod in register TxMode */
;;;242        RegVal = RcGetReg(JREG_TXMODE);
000080  2012              MOVS     r0,#0x12
000082  f7fffffe          BL       RcGetReg
000086  4604              MOV      r4,r0
;;;243        RegVal = (unsigned char)(RegVal & JBIT_INVMOD);
000088  4620              MOV      r0,r4
00008a  2108              MOVS     r1,#8
00008c  4008              ANDS     r0,r0,r1
00008e  4604              MOV      r4,r0
;;;244        RegVal = (unsigned char)(RegVal | JBIT_CRCEN | (RCO_VAL_RF106K << JOINER_SPEED_SHL_VALUE));
000090  4620              MOV      r0,r4
000092  2180              MOVS     r1,#0x80
000094  4308              ORRS     r0,r0,r1
000096  4604              MOV      r4,r0
;;;245        /* TxCRCEn = 1; TxSpeed = x; InvMod, TXMix = 0; TxFraming = 0 */
;;;246        RcSetReg(JREG_TXMODE, RegVal);
000098  4621              MOV      r1,r4
00009a  2012              MOVS     r0,#0x12
00009c  f7fffffe          BL       RcSetReg
;;;247    
;;;248        /* do not touch bits: RxNoErr in register RxMode */
;;;249        RegVal = RcGetReg(JREG_RXMODE);
0000a0  2013              MOVS     r0,#0x13
0000a2  f7fffffe          BL       RcGetReg
0000a6  4604              MOV      r4,r0
;;;250        RegVal = (unsigned char)(RegVal & JBIT_RXNOERR);
0000a8  4620              MOV      r0,r4
0000aa  2108              MOVS     r1,#8
0000ac  4008              ANDS     r0,r0,r1
0000ae  4604              MOV      r4,r0
;;;251        RegVal = (unsigned char)(RegVal | JBIT_CRCEN | (RCO_VAL_RF106K << JOINER_SPEED_SHL_VALUE));
0000b0  4620              MOV      r0,r4
0000b2  2180              MOVS     r1,#0x80
0000b4  4308              ORRS     r0,r0,r1
0000b6  4604              MOV      r4,r0
;;;252         /* RxCRCEn = 1; RxSpeed = x; RxNoErr, RxMultiple = 0; TxFraming = 0 */
;;;253        RcSetReg(JREG_RXMODE, RegVal);
0000b8  4621              MOV      r1,r4
0000ba  2013              MOVS     r0,#0x13
0000bc  f7fffffe          BL       RcSetReg
;;;254    
;;;255        /* ADDIQ = 10b; FixIQ = 1; RFU = 0; TauRcv = 11b; TauSync = 01b */
;;;256        RcSetReg(JREG_DEMOD, 0x6D);
0000c0  216d              MOVS     r1,#0x6d
0000c2  2019              MOVS     r0,#0x19
0000c4  f7fffffe          BL       RcSetReg
;;;257    
;;;258        /* RxGain = 4*/
;;;259        RcSetReg(JREG_RFCFG, 0x48);
0000c8  2148              MOVS     r1,#0x48
0000ca  2026              MOVS     r0,#0x26
0000cc  f7fffffe          BL       RcSetReg
;;;260    
;;;261        /* do settings common for all functions */
;;;262        RcSetReg(JREG_RXTRESHOLD, 0x55);    /* MinLevel = 5; CollLevel = 5 */
0000d0  2155              MOVS     r1,#0x55
0000d2  2018              MOVS     r0,#0x18
0000d4  f7fffffe          BL       RcSetReg
;;;263    
;;;264        RcSetReg(JREG_MODWIDTH, 0x26);      /* Modwidth = 0x26 */
0000d8  2126              MOVS     r1,#0x26
0000da  2024              MOVS     r0,#0x24
0000dc  f7fffffe          BL       RcSetReg
;;;265        RcSetReg(JREG_GSN, 0x80 | 0x0F);     /* CWGsN = 0xF; ModGsN = 0x4 */
0000e0  218f              MOVS     r1,#0x8f
0000e2  2027              MOVS     r0,#0x27
0000e4  f7fffffe          BL       RcSetReg
;;;266    
;;;267        /* Set the timer to auto mode, 5ms using operation control commands before HF is switched on to
;;;268         * guarantee Iso14443-3 compliance of Polling procedure
;;;269    	 */
;;;270        SetTimeOut(5000);
0000e8  481d              LDR      r0,|L8.352|
0000ea  f7fffffe          BL       SetTimeOut
;;;271    
;;;272        /* Activate the field  */
;;;273        RcModifyReg(JREG_TXCONTROL, 1, JBIT_TX2RFEN | JBIT_TX1RFEN);
0000ee  2203              MOVS     r2,#3
0000f0  2101              MOVS     r1,#1
0000f2  2014              MOVS     r0,#0x14
0000f4  f7fffffe          BL       RcModifyReg
;;;274    
;;;275        /* start timer manually to check the initial waiting time */
;;;276        RcModifyReg(JREG_CONTROL, 1, JBIT_TSTARTNOW);
0000f8  2240              MOVS     r2,#0x40
0000fa  2101              MOVS     r1,#1
0000fc  200c              MOVS     r0,#0xc
0000fe  f7fffffe          BL       RcModifyReg
;;;277    
;;;278        /*
;;;279    	 * After switching on the timer wait until the timer interrupt occures, so that
;;;280         * the field is on and the 5ms delay have been passed.
;;;281    	 */
;;;282        do {
000102  bf00              NOP      
                  |L8.260|
;;;283            RegVal = RcGetReg(JREG_COMMIRQ);
000104  2004              MOVS     r0,#4
000106  f7fffffe          BL       RcGetReg
00010a  4604              MOV      r4,r0
;;;284        }
;;;285        while(!(RegVal & JBIT_TIMERI));
00010c  07e0              LSLS     r0,r4,#31
00010e  0fc0              LSRS     r0,r0,#31
000110  d0f8              BEQ      |L8.260|
;;;286    
;;;287    
;;;288        /* Clear the status flag afterwards */
;;;289        RcSetReg(JREG_COMMIRQ, JBIT_TIMERI);
000112  2101              MOVS     r1,#1
000114  2004              MOVS     r0,#4
000116  f7fffffe          BL       RcSetReg
;;;290    
;;;291        /*
;;;292    	 * Reset timer 1 ms using operation control commands (AutoMode and Prescaler are the same)
;;;293    	 * set reload value
;;;294    	 */
;;;295        SetTimeOut(5000);
00011a  4811              LDR      r0,|L8.352|
00011c  f7fffffe          BL       SetTimeOut
;;;296    
;;;297        RcSetReg(JREG_WATERLEVEL, 0x1A);
000120  211a              MOVS     r1,#0x1a
000122  200b              MOVS     r0,#0xb
000124  f7fffffe          BL       RcSetReg
;;;298        RcSetReg(JREG_TXSEL, 0x10);
000128  2110              MOVS     r1,#0x10
00012a  2016              MOVS     r0,#0x16
00012c  f7fffffe          BL       RcSetReg
;;;299        RcSetReg(JREG_RXSEL, 0x84);
000130  2184              MOVS     r1,#0x84
000132  2017              MOVS     r0,#0x17
000134  f7fffffe          BL       RcSetReg
;;;300    
;;;301    
;;;302    
;;;303        /* Activate receiver for communication
;;;304           The RcvOff bit and the PowerDown bit are cleared, the command is not changed. */
;;;305        RcSetReg(JREG_COMMAND, JCMD_IDLE);
000138  2100              MOVS     r1,#0
00013a  2001              MOVS     r0,#1
00013c  f7fffffe          BL       RcSetReg
;;;306    
;;;307    	/* Set timeout for REQA, ANTICOLL, SELECT to 200us */
;;;308    	SetTimeOut(2000);
000140  207d              MOVS     r0,#0x7d
000142  0100              LSLS     r0,r0,#4
000144  f7fffffe          BL       SetTimeOut
;;;309    }
000148  bd3e              POP      {r1-r5,pc}
;;;310    
                          ENDP

00014a  0000              DCW      0x0000
                  |L8.332|
                          DCD      0x00003333
                  |L8.336|
                          DCD      0x40130000
                  |L8.340|
                          DCD      0x40030000
                  |L8.344|
                          DCD      0x000f4240
                  |L8.348|
                          DCD      0x50004040
                  |L8.352|
                          DCD      0x00001388

                          AREA ||i.Read||, CODE, READONLY, ALIGN=2

                  Read PROC
;;;913    **************************************************/
;;;914    short Read(unsigned char addr, unsigned char *_data)
000000  b570              PUSH     {r4-r6,lr}
;;;915    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;916       short status = STATUS_SUCCESS;
000006  2400              MOVS     r4,#0
;;;917    //   char tmp    = 0;
;;;918    
;;;919       ResetInfo(MInfo);
000008  2000              MOVS     r0,#0
00000a  4922              LDR      r1,|L9.148|
00000c  7008              STRB     r0,[r1,#0]
00000e  7048              STRB     r0,[r1,#1]
000010  7088              STRB     r0,[r1,#2]
000012  70c8              STRB     r0,[r1,#3]
000014  7108              STRB     r0,[r1,#4]
000016  80c8              STRH     r0,[r1,#6]
000018  7208              STRB     r0,[r1,#8]
;;;920       SerBuffer[0] = MIFARE_READ;
00001a  2030              MOVS     r0,#0x30
00001c  491e              LDR      r1,|L9.152|
00001e  7008              STRB     r0,[r1,#0]
;;;921       SerBuffer[1] = addr;
000020  4608              MOV      r0,r1
000022  7045              STRB     r5,[r0,#1]
;;;922       MInfo.nBytesToSend   = 2;
000024  2002              MOVS     r0,#2
000026  491b              LDR      r1,|L9.148|
000028  70c8              STRB     r0,[r1,#3]
;;;923       SetTimeOut(5000);
00002a  481c              LDR      r0,|L9.156|
00002c  f7fffffe          BL       SetTimeOut
;;;924       status = M522PcdCmd(JCMD_TRANSCEIVE,
000030  4a18              LDR      r2,|L9.148|
000032  4919              LDR      r1,|L9.152|
000034  200c              MOVS     r0,#0xc
000036  f7fffffe          BL       M522PcdCmd
00003a  4604              MOV      r4,r0
;;;925                           SerBuffer,
;;;926                           &MInfo);
;;;927    
;;;928       if (status != STATUS_SUCCESS)
00003c  2c00              CMP      r4,#0
00003e  d018              BEQ      |L9.114|
;;;929       {
;;;930          if (status != STATUS_IO_TIMEOUT )     // no timeout occured
000040  2c01              CMP      r4,#1
000042  d011              BEQ      |L9.104|
;;;931          {
;;;932             if (MInfo.nBitsReceived == 4)
000044  4813              LDR      r0,|L9.148|
000046  88c0              LDRH     r0,[r0,#6]  ; MInfo
000048  2804              CMP      r0,#4
00004a  d10d              BNE      |L9.104|
;;;933             {
;;;934                 SerBuffer[0] &= 0x0f;
00004c  4812              LDR      r0,|L9.152|
00004e  7800              LDRB     r0,[r0,#0]  ; SerBuffer
000050  0700              LSLS     r0,r0,#28
000052  0f00              LSRS     r0,r0,#28
000054  4910              LDR      r1,|L9.152|
000056  7008              STRB     r0,[r1,#0]
;;;935                 if ((SerBuffer[0] & 0x0a) == 0)
000058  4608              MOV      r0,r1
00005a  7800              LDRB     r0,[r0,#0]  ; SerBuffer
00005c  210a              MOVS     r1,#0xa
00005e  4208              TST      r0,r1
000060  d101              BNE      |L9.102|
;;;936                 {
;;;937                    status = STATUS_AUTHENT_ERROR;
000062  2405              MOVS     r4,#5
000064  e000              B        |L9.104|
                  |L9.102|
;;;938                 }
;;;939                 else
;;;940                 {
;;;941                    status = STATUS_INVALID_FORMAT;
000066  2403              MOVS     r4,#3
                  |L9.104|
;;;942                 }
;;;943              }
;;;944          }
;;;945          memset(_data,0,16);
000068  2110              MOVS     r1,#0x10
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       __aeabi_memclr
000070  e00e              B        |L9.144|
                  |L9.114|
;;;946       }
;;;947       else   // Response Processing
;;;948       {
;;;949          if (MInfo.nBytesReceived != 16)
000072  4808              LDR      r0,|L9.148|
000074  7900              LDRB     r0,[r0,#4]  ; MInfo
000076  2810              CMP      r0,#0x10
000078  d005              BEQ      |L9.134|
;;;950          {
;;;951             status = STATUS_ACCESS_DENIED;
00007a  2404              MOVS     r4,#4
;;;952             memset(_data,0,16);
00007c  2110              MOVS     r1,#0x10
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       __aeabi_memclr
000084  e004              B        |L9.144|
                  |L9.134|
;;;953          }
;;;954          else
;;;955          {
;;;956             memcpy(_data,SerBuffer,16);
000086  2210              MOVS     r2,#0x10
000088  4903              LDR      r1,|L9.152|
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       __aeabi_memcpy
                  |L9.144|
;;;957          }
;;;958       }
;;;959       return status;
000090  4620              MOV      r0,r4
;;;960    }
000092  bd70              POP      {r4-r6,pc}
;;;961    
                          ENDP

                  |L9.148|
                          DCD      MInfo
                  |L9.152|
                          DCD      SerBuffer
                  |L9.156|
                          DCD      0x00001388

                          AREA ||i.Request||, CODE, READONLY, ALIGN=2

                  Request PROC
;;;536    **************************************************/
;;;537    short Request(unsigned char req_code, unsigned char *atq)
000000  b570              PUSH     {r4-r6,lr}
;;;538    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;539       char  status = STATUS_SUCCESS;
000006  2600              MOVS     r6,#0
;;;540    
;;;541       /************* initialize *****************/
;;;542       RcModifyReg(JREG_STATUS2, 0, JBIT_CRYPTO1ON);  /* disable Crypto if activated before */
000008  2208              MOVS     r2,#8
00000a  2100              MOVS     r1,#0
00000c  4610              MOV      r0,r2
00000e  f7fffffe          BL       RcModifyReg
;;;543       RcSetReg(JREG_COLL, JBIT_VALUESAFTERCOLL);  //active values after coll
000012  2180              MOVS     r1,#0x80
000014  200e              MOVS     r0,#0xe
000016  f7fffffe          BL       RcSetReg
;;;544       RcModifyReg(JREG_TXMODE, 0, JBIT_CRCEN);  //disable TxCRC and RxCRC
00001a  2280              MOVS     r2,#0x80
00001c  2100              MOVS     r1,#0
00001e  2012              MOVS     r0,#0x12
000020  f7fffffe          BL       RcModifyReg
;;;545       RcModifyReg(JREG_RXMODE, 0, JBIT_CRCEN);
000024  2280              MOVS     r2,#0x80
000026  2100              MOVS     r1,#0
000028  2013              MOVS     r0,#0x13
00002a  f7fffffe          BL       RcModifyReg
;;;546       RcSetReg(JREG_BITFRAMING, REQUEST_BITS);
00002e  2107              MOVS     r1,#7
000030  200d              MOVS     r0,#0xd
000032  f7fffffe          BL       RcSetReg
;;;547    
;;;548       /* set necessary parameters for transmission */
;;;549       ResetInfo(MInfo);
000036  2000              MOVS     r0,#0
000038  4915              LDR      r1,|L10.144|
00003a  7008              STRB     r0,[r1,#0]
00003c  7048              STRB     r0,[r1,#1]
00003e  7088              STRB     r0,[r1,#2]
000040  70c8              STRB     r0,[r1,#3]
000042  7108              STRB     r0,[r1,#4]
000044  80c8              STRH     r0,[r1,#6]
000046  7208              STRB     r0,[r1,#8]
;;;550       SerBuffer[0] = req_code;
000048  4812              LDR      r0,|L10.148|
00004a  7005              STRB     r5,[r0,#0]
;;;551       MInfo.nBytesToSend   = 1;
00004c  2001              MOVS     r0,#1
00004e  70c8              STRB     r0,[r1,#3]
;;;552    
;;;553       /* Set timeout for REQA, ANTICOLL, SELECT*/
;;;554    	SetTimeOut(300);
000050  20ff              MOVS     r0,#0xff
000052  302d              ADDS     r0,r0,#0x2d
000054  f7fffffe          BL       SetTimeOut
;;;555    
;;;556       status = M522PcdCmd(JCMD_TRANSCEIVE,
000058  4a0d              LDR      r2,|L10.144|
00005a  490e              LDR      r1,|L10.148|
00005c  200c              MOVS     r0,#0xc
00005e  f7fffffe          BL       M522PcdCmd
000062  b2c6              UXTB     r6,r0
;;;557                          SerBuffer,
;;;558                          &MInfo);
;;;559       if (status)      // error occured
000064  2e00              CMP      r6,#0
000066  d002              BEQ      |L10.110|
;;;560       {
;;;561          *atq = 0;
000068  2000              MOVS     r0,#0
00006a  7020              STRB     r0,[r4,#0]
00006c  e00d              B        |L10.138|
                  |L10.110|
;;;562       }
;;;563       else
;;;564       {
;;;565          if (MInfo.nBytesReceived != 2) // 2 bytes expected
00006e  4808              LDR      r0,|L10.144|
000070  7900              LDRB     r0,[r0,#4]  ; MInfo
000072  2802              CMP      r0,#2
000074  d003              BEQ      |L10.126|
;;;566          {
;;;567             *atq = 0;
000076  2000              MOVS     r0,#0
000078  7020              STRB     r0,[r4,#0]
;;;568             status = STATUS_BITCOUNT_ERROR;
00007a  2602              MOVS     r6,#2
00007c  e005              B        |L10.138|
                  |L10.126|
;;;569          }
;;;570          else
;;;571          {
;;;572             status = STATUS_SUCCESS;
00007e  2600              MOVS     r6,#0
;;;573             memcpy(atq,SerBuffer,2);
000080  4804              LDR      r0,|L10.148|
000082  7801              LDRB     r1,[r0,#0]  ; SerBuffer
000084  7021              STRB     r1,[r4,#0]
000086  7840              LDRB     r0,[r0,#1]  ; SerBuffer
000088  7060              STRB     r0,[r4,#1]
                  |L10.138|
;;;574          }
;;;575       }
;;;576       return status;
00008a  4630              MOV      r0,r6
;;;577    }
00008c  bd70              POP      {r4-r6,pc}
;;;578    
                          ENDP

00008e  0000              DCW      0x0000
                  |L10.144|
                          DCD      MInfo
                  |L10.148|
                          DCD      SerBuffer

                          AREA ||i.Select||, CODE, READONLY, ALIGN=2

                  Select PROC
;;;717    **************************************************/
;;;718    short Select(unsigned char sel_code, unsigned char *snr, unsigned char *sak)
000000  b5f8              PUSH     {r3-r7,lr}
;;;719    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;720        short status = STATUS_SUCCESS;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;721        /* define local variables */
;;;722        unsigned char i;
;;;723        /* activate CRC */
;;;724        RcModifyReg(JREG_TXMODE, 1, JBIT_CRCEN);
00000c  2280              MOVS     r2,#0x80
00000e  2101              MOVS     r1,#1
000010  2012              MOVS     r0,#0x12
000012  f7fffffe          BL       RcModifyReg
;;;725        RcModifyReg(JREG_RXMODE, 1, JBIT_CRCEN);
000016  2280              MOVS     r2,#0x80
000018  2101              MOVS     r1,#1
00001a  2013              MOVS     r0,#0x13
00001c  f7fffffe          BL       RcModifyReg
;;;726    
;;;727        /* prepare data stream */
;;;728        SerBuffer[0] = sel_code;   /* command code */
000020  481f              LDR      r0,|L11.160|
000022  7006              STRB     r6,[r0,#0]
;;;729        SerBuffer[1] = NVB_MAX_PARAMETER;       /* parameter */
000024  2070              MOVS     r0,#0x70
000026  491e              LDR      r1,|L11.160|
000028  7048              STRB     r0,[r1,#1]
;;;730        for(i=0;i<4;i++)
00002a  2500              MOVS     r5,#0
00002c  e005              B        |L11.58|
                  |L11.46|
;;;731            SerBuffer[2+i] = snr[i];   /* serial numbner bytes 1 to 4 */
00002e  5d61              LDRB     r1,[r4,r5]
000030  1ca8              ADDS     r0,r5,#2
000032  4a1b              LDR      r2,|L11.160|
000034  5411              STRB     r1,[r2,r0]
000036  1c68              ADDS     r0,r5,#1              ;730
000038  b2c5              UXTB     r5,r0                 ;730
                  |L11.58|
00003a  2d04              CMP      r5,#4                 ;730
00003c  dbf7              BLT      |L11.46|
;;;732        SerBuffer[6] = (unsigned char)(snr[0] ^ snr[1] ^ snr[2] ^ snr[3]);   /* serial number check byte */
00003e  7820              LDRB     r0,[r4,#0]
000040  7861              LDRB     r1,[r4,#1]
000042  4048              EORS     r0,r0,r1
000044  78a1              LDRB     r1,[r4,#2]
000046  4048              EORS     r0,r0,r1
000048  78e1              LDRB     r1,[r4,#3]
00004a  4048              EORS     r0,r0,r1
00004c  4914              LDR      r1,|L11.160|
00004e  7188              STRB     r0,[r1,#6]
;;;733    
;;;734        /* prepare data for common transceive */
;;;735        ResetInfo(MInfo);
000050  2000              MOVS     r0,#0
000052  4914              LDR      r1,|L11.164|
000054  7008              STRB     r0,[r1,#0]
000056  7048              STRB     r0,[r1,#1]
000058  7088              STRB     r0,[r1,#2]
00005a  70c8              STRB     r0,[r1,#3]
00005c  7108              STRB     r0,[r1,#4]
00005e  80c8              STRH     r0,[r1,#6]
000060  7208              STRB     r0,[r1,#8]
;;;736        MInfo.nBytesToSend   = 0x07;
000062  2007              MOVS     r0,#7
000064  70c8              STRB     r0,[r1,#3]
;;;737        SetTimeOut(300);
000066  20ff              MOVS     r0,#0xff
000068  302d              ADDS     r0,r0,#0x2d
00006a  f7fffffe          BL       SetTimeOut
;;;738        status = M522PcdCmd(JCMD_TRANSCEIVE, SerBuffer, &MInfo);
00006e  4a0d              LDR      r2,|L11.164|
000070  490b              LDR      r1,|L11.160|
000072  200c              MOVS     r0,#0xc
000074  f7fffffe          BL       M522PcdCmd
000078  9000              STR      r0,[sp,#0]
;;;739    
;;;740        if(status == STATUS_SUCCESS)
00007a  9800              LDR      r0,[sp,#0]
00007c  2800              CMP      r0,#0
00007e  d10d              BNE      |L11.156|
;;;741        {
;;;742            if(MInfo.nBytesReceived == SAK_LENGTH && MInfo.nBitsReceived == 0)
000080  4808              LDR      r0,|L11.164|
000082  7900              LDRB     r0,[r0,#4]  ; MInfo
000084  2801              CMP      r0,#1
000086  d107              BNE      |L11.152|
000088  4806              LDR      r0,|L11.164|
00008a  88c0              LDRH     r0,[r0,#6]  ; MInfo
00008c  2800              CMP      r0,#0
00008e  d103              BNE      |L11.152|
;;;743                *sak = SerBuffer[0];
000090  4803              LDR      r0,|L11.160|
000092  7800              LDRB     r0,[r0,#0]  ; SerBuffer
000094  7038              STRB     r0,[r7,#0]
000096  e001              B        |L11.156|
                  |L11.152|
;;;744            else
;;;745                status = STATUS_BITCOUNT_ERROR;
000098  2002              MOVS     r0,#2
00009a  9000              STR      r0,[sp,#0]
                  |L11.156|
;;;746        }
;;;747        return status;
00009c  9800              LDR      r0,[sp,#0]
;;;748    }
00009e  bdf8              POP      {r3-r7,pc}
;;;749    
                          ENDP

                  |L11.160|
                          DCD      SerBuffer
                  |L11.164|
                          DCD      MInfo

                          AREA ||i.SetPowerDown||, CODE, READONLY, ALIGN=1

                  SetPowerDown PROC
;;;84     **************************************************/
;;;85     void SetPowerDown(unsigned char ucFlag)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {
000002  4605              MOV      r5,r0
;;;87         unsigned char RegVal;
;;;88     /*
;;;89         Note: The bit Power Down can not be set when the SoftReset command has been activated.
;;;90     */
;;;91         if(ucFlag)
000004  2d00              CMP      r5,#0
000006  d00c              BEQ      |L12.34|
;;;92         {
;;;93             RegVal = RcGetReg(JREG_COMMAND);  //enter power down mode
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       RcGetReg
00000e  4604              MOV      r4,r0
;;;94             RegVal |= 0x10;
000010  4620              MOV      r0,r4
000012  2110              MOVS     r1,#0x10
000014  4308              ORRS     r0,r0,r1
000016  4604              MOV      r4,r0
;;;95             RcSetReg(JREG_COMMAND, RegVal);
000018  4621              MOV      r1,r4
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       RcSetReg
000020  e00b              B        |L12.58|
                  |L12.34|
;;;96         }
;;;97         else
;;;98         {
;;;99             RegVal = RcGetReg(JREG_COMMAND);  //disable power down mode
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       RcGetReg
000028  4604              MOV      r4,r0
;;;100            RegVal &= (~0x10);
00002a  4620              MOV      r0,r4
00002c  2110              MOVS     r1,#0x10
00002e  4388              BICS     r0,r0,r1
000030  4604              MOV      r4,r0
;;;101            RcSetReg(JREG_COMMAND, RegVal);
000032  4621              MOV      r1,r4
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       RcSetReg
                  |L12.58|
;;;102        }
;;;103    }
00003a  bd70              POP      {r4-r6,pc}
;;;104    
                          ENDP


                          AREA ||i.SetTimeOut||, CODE, READONLY, ALIGN=2

                  SetTimeOut PROC
;;;113    **************************************************/
;;;114    short SetTimeOut(unsigned int uiMicroSeconds)
000000  b570              PUSH     {r4-r6,lr}
;;;115    {
000002  4606              MOV      r6,r0
;;;116        unsigned int RegVal;
;;;117        unsigned char TmpVal;
;;;118        RegVal = uiMicroSeconds / 100;
000004  2164              MOVS     r1,#0x64
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       __aeabi_uidivmod
00000c  4604              MOV      r4,r0
;;;119        /*
;;;120        NOTE: The supported hardware range is bigger, since the prescaler here
;;;121              is always set to 100 us.
;;;122        */
;;;123        if(RegVal >= 0xfff)
00000e  4814              LDR      r0,|L13.96|
000010  4284              CMP      r4,r0
000012  d301              BCC      |L13.24|
;;;124        {
;;;125            return STATUS_INVALID_PARAMETER;
000014  2014              MOVS     r0,#0x14
                  |L13.22|
;;;126        }
;;;127        RcModifyReg(JREG_TMODE, 1, JBIT_TAUTO);
;;;128    
;;;129        RcSetReg(JREG_TPRESCALER, 0xa6);
;;;130    
;;;131        TmpVal = RcGetReg(JREG_TMODE);
;;;132        TmpVal &= 0xf0;
;;;133        TmpVal |= 0x02;
;;;134        RcSetReg(JREG_TMODE, TmpVal);//82
;;;135    
;;;136        RcSetReg(JREG_TRELOADLO, ((unsigned char)(RegVal&0xff)));
;;;137        RcSetReg(JREG_TRELOADHI, ((unsigned char)((RegVal>>8)&0xff)));
;;;138        return STATUS_SUCCESS;
;;;139    }
000016  bd70              POP      {r4-r6,pc}
                  |L13.24|
000018  2280              MOVS     r2,#0x80              ;127
00001a  2101              MOVS     r1,#1                 ;127
00001c  202a              MOVS     r0,#0x2a              ;127
00001e  f7fffffe          BL       RcModifyReg
000022  21a6              MOVS     r1,#0xa6              ;129
000024  202b              MOVS     r0,#0x2b              ;129
000026  f7fffffe          BL       RcSetReg
00002a  202a              MOVS     r0,#0x2a              ;131
00002c  f7fffffe          BL       RcGetReg
000030  4605              MOV      r5,r0                 ;131
000032  4628              MOV      r0,r5                 ;132
000034  21f0              MOVS     r1,#0xf0              ;132
000036  4008              ANDS     r0,r0,r1              ;132
000038  4605              MOV      r5,r0                 ;132
00003a  4628              MOV      r0,r5                 ;133
00003c  2102              MOVS     r1,#2                 ;133
00003e  4308              ORRS     r0,r0,r1              ;133
000040  4605              MOV      r5,r0                 ;133
000042  4629              MOV      r1,r5                 ;134
000044  202a              MOVS     r0,#0x2a              ;134
000046  f7fffffe          BL       RcSetReg
00004a  b2e1              UXTB     r1,r4                 ;136
00004c  202d              MOVS     r0,#0x2d              ;136
00004e  f7fffffe          BL       RcSetReg
000052  0420              LSLS     r0,r4,#16             ;137
000054  0e01              LSRS     r1,r0,#24             ;137
000056  202c              MOVS     r0,#0x2c              ;137
000058  f7fffffe          BL       RcSetReg
00005c  2000              MOVS     r0,#0                 ;138
00005e  e7da              B        |L13.22|
;;;140    
                          ENDP

                  |L13.96|
                          DCD      0x00000fff

                          AREA ||i.ValueOper||, CODE, READONLY, ALIGN=2

                  ValueOper PROC
;;;1069   **************************************************/
;;;1070   short ValueOper(unsigned char OperMode,
000000  b5ff              PUSH     {r0-r7,lr}
;;;1071                       unsigned char addr,
;;;1072                       unsigned char *value,
;;;1073                       unsigned char trans_addr)
;;;1074   {
000002  b081              SUB      sp,sp,#4
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  461f              MOV      r7,r3
;;;1075      short status = STATUS_SUCCESS;
00000a  2400              MOVS     r4,#0
;;;1076      ResetInfo(MInfo);
00000c  2000              MOVS     r0,#0
00000e  493e              LDR      r1,|L14.264|
000010  7008              STRB     r0,[r1,#0]
000012  7048              STRB     r0,[r1,#1]
000014  7088              STRB     r0,[r1,#2]
000016  70c8              STRB     r0,[r1,#3]
000018  7108              STRB     r0,[r1,#4]
00001a  80c8              STRH     r0,[r1,#6]
00001c  7208              STRB     r0,[r1,#8]
;;;1077      SerBuffer[0] = OperMode;
00001e  483b              LDR      r0,|L14.268|
000020  7005              STRB     r5,[r0,#0]
;;;1078      SerBuffer[1] = addr;
000022  7046              STRB     r6,[r0,#1]
;;;1079      MInfo.nBytesToSend   = 2;
000024  2002              MOVS     r0,#2
000026  70c8              STRB     r0,[r1,#3]
;;;1080      SetTimeOut(5000);
000028  4839              LDR      r0,|L14.272|
00002a  f7fffffe          BL       SetTimeOut
;;;1081      status = M522PcdCmd(JCMD_TRANSCEIVE,
00002e  4a36              LDR      r2,|L14.264|
000030  4936              LDR      r1,|L14.268|
000032  200c              MOVS     r0,#0xc
000034  f7fffffe          BL       M522PcdCmd
000038  4604              MOV      r4,r0
;;;1082                          SerBuffer,
;;;1083                          &MInfo);
;;;1084   
;;;1085      if (status != STATUS_IO_TIMEOUT)
00003a  2c01              CMP      r4,#1
00003c  d01d              BEQ      |L14.122|
;;;1086      {
;;;1087           if (MInfo.nBitsReceived != 4)
00003e  4832              LDR      r0,|L14.264|
000040  88c0              LDRH     r0,[r0,#6]  ; MInfo
000042  2804              CMP      r0,#4
000044  d001              BEQ      |L14.74|
;;;1088           {
;;;1089              status = STATUS_BITCOUNT_ERROR;
000046  2402              MOVS     r4,#2
000048  e017              B        |L14.122|
                  |L14.74|
;;;1090           }
;;;1091           else
;;;1092           {
;;;1093              SerBuffer[0] &= 0x0f;
00004a  4830              LDR      r0,|L14.268|
00004c  7800              LDRB     r0,[r0,#0]  ; SerBuffer
00004e  0700              LSLS     r0,r0,#28
000050  0f00              LSRS     r0,r0,#28
000052  492e              LDR      r1,|L14.268|
000054  7008              STRB     r0,[r1,#0]
;;;1094              switch(SerBuffer[0])
000056  4608              MOV      r0,r1
000058  7800              LDRB     r0,[r0,#0]  ; SerBuffer
00005a  2800              CMP      r0,#0
00005c  d004              BEQ      |L14.104|
00005e  2801              CMP      r0,#1
000060  d006              BEQ      |L14.112|
000062  280a              CMP      r0,#0xa
000064  d106              BNE      |L14.116|
000066  e001              B        |L14.108|
                  |L14.104|
;;;1095              {
;;;1096                 case 0x00:
;;;1097                    status = STATUS_AUTHENT_ERROR;
000068  2405              MOVS     r4,#5
;;;1098                    break;
00006a  e005              B        |L14.120|
                  |L14.108|
;;;1099                 case 0x0a:
;;;1100                    status = STATUS_SUCCESS;
00006c  2400              MOVS     r4,#0
;;;1101                    break;
00006e  e003              B        |L14.120|
                  |L14.112|
;;;1102                 case 0x01:
;;;1103                    status = STATUS_INVALID_FORMAT;
000070  2403              MOVS     r4,#3
;;;1104                    break;
000072  e001              B        |L14.120|
                  |L14.116|
;;;1105                 default:
;;;1106                    status = STATUS_OTHER_ERROR;
000074  2415              MOVS     r4,#0x15
;;;1107                    break;
000076  bf00              NOP      
                  |L14.120|
000078  bf00              NOP                            ;1098
                  |L14.122|
;;;1108              }
;;;1109           }
;;;1110        }
;;;1111   
;;;1112        if ( status == STATUS_SUCCESS)
00007a  2c00              CMP      r4,#0
00007c  d122              BNE      |L14.196|
;;;1113        {
;;;1114           SetTimeOut(10000);
00007e  4825              LDR      r0,|L14.276|
000080  f7fffffe          BL       SetTimeOut
;;;1115           ResetInfo(MInfo);
000084  2000              MOVS     r0,#0
000086  4920              LDR      r1,|L14.264|
000088  7008              STRB     r0,[r1,#0]
00008a  7048              STRB     r0,[r1,#1]
00008c  7088              STRB     r0,[r1,#2]
00008e  70c8              STRB     r0,[r1,#3]
000090  7108              STRB     r0,[r1,#4]
000092  80c8              STRH     r0,[r1,#6]
000094  7208              STRB     r0,[r1,#8]
;;;1116           memcpy(SerBuffer,value,4);
000096  2204              MOVS     r2,#4
000098  481c              LDR      r0,|L14.268|
00009a  9903              LDR      r1,[sp,#0xc]
00009c  f7fffffe          BL       __aeabi_memcpy
;;;1117           MInfo.nBytesToSend   = 4;
0000a0  2004              MOVS     r0,#4
0000a2  4919              LDR      r1,|L14.264|
0000a4  70c8              STRB     r0,[r1,#3]
;;;1118           status = M522PcdCmd(JCMD_TRANSCEIVE,
0000a6  460a              MOV      r2,r1
0000a8  4918              LDR      r1,|L14.268|
0000aa  200c              MOVS     r0,#0xc
0000ac  f7fffffe          BL       M522PcdCmd
0000b0  4604              MOV      r4,r0
;;;1119                               SerBuffer,
;;;1120                               &MInfo);
;;;1121   
;;;1122           if (status == STATUS_IO_TIMEOUT||(status == MIFARE_DECREMENT && OperMode == MIFARE_DECREMENT))
0000b2  2c01              CMP      r4,#1
0000b4  d003              BEQ      |L14.190|
0000b6  2cc0              CMP      r4,#0xc0
0000b8  d103              BNE      |L14.194|
0000ba  2dc0              CMP      r5,#0xc0
0000bc  d101              BNE      |L14.194|
                  |L14.190|
;;;1123           {
;;;1124               status = STATUS_SUCCESS;
0000be  2400              MOVS     r4,#0
0000c0  e000              B        |L14.196|
                  |L14.194|
;;;1125           }
;;;1126           else
;;;1127           {
;;;1128               status = STATUS_OTHER_ERROR;
0000c2  2415              MOVS     r4,#0x15
                  |L14.196|
;;;1129           }
;;;1130        }
;;;1131        if ( status == STATUS_SUCCESS)
0000c4  2c00              CMP      r4,#0
0000c6  d11c              BNE      |L14.258|
;;;1132        {
;;;1133           ResetInfo(MInfo);
0000c8  2000              MOVS     r0,#0
0000ca  490f              LDR      r1,|L14.264|
0000cc  7008              STRB     r0,[r1,#0]
0000ce  7048              STRB     r0,[r1,#1]
0000d0  7088              STRB     r0,[r1,#2]
0000d2  70c8              STRB     r0,[r1,#3]
0000d4  7108              STRB     r0,[r1,#4]
0000d6  80c8              STRH     r0,[r1,#6]
0000d8  7208              STRB     r0,[r1,#8]
;;;1134           SerBuffer[0] = MIFARE_TRANSFER;
0000da  20b0              MOVS     r0,#0xb0
0000dc  490b              LDR      r1,|L14.268|
0000de  7008              STRB     r0,[r1,#0]
;;;1135           SerBuffer[1] = trans_addr;
0000e0  4608              MOV      r0,r1
0000e2  7047              STRB     r7,[r0,#1]
;;;1136           MInfo.nBytesToSend   = 2;
0000e4  2002              MOVS     r0,#2
0000e6  4908              LDR      r1,|L14.264|
0000e8  70c8              STRB     r0,[r1,#3]
;;;1137           status = M522PcdCmd(JCMD_TRANSCEIVE,
0000ea  460a              MOV      r2,r1
0000ec  4907              LDR      r1,|L14.268|
0000ee  200c              MOVS     r0,#0xc
0000f0  f7fffffe          BL       M522PcdCmd
0000f4  4604              MOV      r4,r0
;;;1138                               SerBuffer,
;;;1139                               &MInfo);
;;;1140   
;;;1141           if (status & MIFARE_ACK_MASK)
0000f6  200a              MOVS     r0,#0xa
0000f8  4204              TST      r4,r0
0000fa  d001              BEQ      |L14.256|
;;;1142           {
;;;1143               status = STATUS_SUCCESS;
0000fc  2400              MOVS     r4,#0
0000fe  e000              B        |L14.258|
                  |L14.256|
;;;1144           }
;;;1145           else
;;;1146           {
;;;1147               status = STATUS_OTHER_ERROR;
000100  2415              MOVS     r4,#0x15
                  |L14.258|
;;;1148           }
;;;1149        }
;;;1150      return status;
000102  4620              MOV      r0,r4
;;;1151   }
000104  b005              ADD      sp,sp,#0x14
000106  bdf0              POP      {r4-r7,pc}
;;;1152   
                          ENDP

                  |L14.264|
                          DCD      MInfo
                  |L14.268|
                          DCD      SerBuffer
                  |L14.272|
                          DCD      0x00001388
                  |L14.276|
                          DCD      0x00002710

                          AREA ||i.Write||, CODE, READONLY, ALIGN=2

                  Write PROC
;;;971    **************************************************/
;;;972    short Write( unsigned char addr, unsigned char *_data)
000000  b570              PUSH     {r4-r6,lr}
;;;973    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;974        short status = STATUS_SUCCESS;
000006  2400              MOVS     r4,#0
;;;975        ResetInfo(MInfo);
000008  2000              MOVS     r0,#0
00000a  4939              LDR      r1,|L15.240|
00000c  7008              STRB     r0,[r1,#0]
00000e  7048              STRB     r0,[r1,#1]
000010  7088              STRB     r0,[r1,#2]
000012  70c8              STRB     r0,[r1,#3]
000014  7108              STRB     r0,[r1,#4]
000016  80c8              STRH     r0,[r1,#6]
000018  7208              STRB     r0,[r1,#8]
;;;976        SerBuffer[0] = MIFARE_WRITE;
00001a  20a0              MOVS     r0,#0xa0
00001c  4935              LDR      r1,|L15.244|
00001e  7008              STRB     r0,[r1,#0]
;;;977        SerBuffer[1] = addr;
000020  4608              MOV      r0,r1
000022  7045              STRB     r5,[r0,#1]
;;;978        MInfo.nBytesToSend   = 2;
000024  2002              MOVS     r0,#2
000026  4932              LDR      r1,|L15.240|
000028  70c8              STRB     r0,[r1,#3]
;;;979        SetTimeOut(10000);
00002a  4833              LDR      r0,|L15.248|
00002c  f7fffffe          BL       SetTimeOut
;;;980        status = M522PcdCmd(JCMD_TRANSCEIVE,
000030  4a2f              LDR      r2,|L15.240|
000032  4930              LDR      r1,|L15.244|
000034  200c              MOVS     r0,#0xc
000036  f7fffffe          BL       M522PcdCmd
00003a  4604              MOV      r4,r0
;;;981                            SerBuffer,
;;;982                            &MInfo);
;;;983    
;;;984        if (status != STATUS_IO_TIMEOUT)
00003c  2c01              CMP      r4,#1
00003e  d019              BEQ      |L15.116|
;;;985        {
;;;986           if (MInfo.nBitsReceived != 4)
000040  482b              LDR      r0,|L15.240|
000042  88c0              LDRH     r0,[r0,#6]  ; MInfo
000044  2804              CMP      r0,#4
000046  d001              BEQ      |L15.76|
;;;987           {
;;;988              status = STATUS_BITCOUNT_ERROR;
000048  2402              MOVS     r4,#2
00004a  e013              B        |L15.116|
                  |L15.76|
;;;989           }
;;;990           else
;;;991           {
;;;992              SerBuffer[0] &= 0x0f;
00004c  4829              LDR      r0,|L15.244|
00004e  7800              LDRB     r0,[r0,#0]  ; SerBuffer
000050  0700              LSLS     r0,r0,#28
000052  0f00              LSRS     r0,r0,#28
000054  4927              LDR      r1,|L15.244|
000056  7008              STRB     r0,[r1,#0]
;;;993              if ((SerBuffer[0] & 0x0a) == 0)
000058  4608              MOV      r0,r1
00005a  7800              LDRB     r0,[r0,#0]  ; SerBuffer
00005c  210a              MOVS     r1,#0xa
00005e  4208              TST      r0,r1
000060  d101              BNE      |L15.102|
;;;994              {
;;;995                 status = STATUS_AUTHENT_ERROR;
000062  2405              MOVS     r4,#5
000064  e006              B        |L15.116|
                  |L15.102|
;;;996              }
;;;997              else
;;;998              {
;;;999                 if (SerBuffer[0] == 0x0a)
000066  4823              LDR      r0,|L15.244|
000068  7800              LDRB     r0,[r0,#0]  ; SerBuffer
00006a  280a              CMP      r0,#0xa
00006c  d101              BNE      |L15.114|
;;;1000                {
;;;1001                   status = STATUS_SUCCESS;
00006e  2400              MOVS     r4,#0
000070  e000              B        |L15.116|
                  |L15.114|
;;;1002                }
;;;1003                else
;;;1004                {
;;;1005                   status = STATUS_INVALID_FORMAT;
000072  2403              MOVS     r4,#3
                  |L15.116|
;;;1006                }
;;;1007             }
;;;1008          }
;;;1009       }
;;;1010   
;;;1011       if ( status == STATUS_SUCCESS)
000074  2c00              CMP      r4,#0
000076  d138              BNE      |L15.234|
;;;1012       {
;;;1013   
;;;1014          SetTimeOut(5000);
000078  4820              LDR      r0,|L15.252|
00007a  f7fffffe          BL       SetTimeOut
;;;1015   
;;;1016          ResetInfo(MInfo);
00007e  2000              MOVS     r0,#0
000080  491b              LDR      r1,|L15.240|
000082  7008              STRB     r0,[r1,#0]
000084  7048              STRB     r0,[r1,#1]
000086  7088              STRB     r0,[r1,#2]
000088  70c8              STRB     r0,[r1,#3]
00008a  7108              STRB     r0,[r1,#4]
00008c  80c8              STRH     r0,[r1,#6]
00008e  7208              STRB     r0,[r1,#8]
;;;1017          memcpy(SerBuffer,_data,16);
000090  2210              MOVS     r2,#0x10
000092  4631              MOV      r1,r6
000094  4817              LDR      r0,|L15.244|
000096  f7fffffe          BL       __aeabi_memcpy
;;;1018          MInfo.nBytesToSend   = 16;
00009a  2010              MOVS     r0,#0x10
00009c  4914              LDR      r1,|L15.240|
00009e  70c8              STRB     r0,[r1,#3]
;;;1019          status = M522PcdCmd(JCMD_TRANSCEIVE,
0000a0  460a              MOV      r2,r1
0000a2  4914              LDR      r1,|L15.244|
0000a4  200c              MOVS     r0,#0xc
0000a6  f7fffffe          BL       M522PcdCmd
0000aa  4604              MOV      r4,r0
;;;1020                              SerBuffer,
;;;1021                              &MInfo);
;;;1022   
;;;1023          if (status & 0x80)
0000ac  2080              MOVS     r0,#0x80
0000ae  4204              TST      r4,r0
0000b0  d001              BEQ      |L15.182|
;;;1024          {
;;;1025             status = STATUS_IO_TIMEOUT;
0000b2  2401              MOVS     r4,#1
0000b4  e019              B        |L15.234|
                  |L15.182|
;;;1026          }
;;;1027          else
;;;1028          {
;;;1029             if (MInfo.nBitsReceived != 4)
0000b6  480e              LDR      r0,|L15.240|
0000b8  88c0              LDRH     r0,[r0,#6]  ; MInfo
0000ba  2804              CMP      r0,#4
0000bc  d001              BEQ      |L15.194|
;;;1030             {
;;;1031                status = STATUS_BITCOUNT_ERROR;
0000be  2402              MOVS     r4,#2
0000c0  e013              B        |L15.234|
                  |L15.194|
;;;1032             }
;;;1033             else
;;;1034             {
;;;1035                SerBuffer[0] &= 0x0f;
0000c2  480c              LDR      r0,|L15.244|
0000c4  7800              LDRB     r0,[r0,#0]  ; SerBuffer
0000c6  0700              LSLS     r0,r0,#28
0000c8  0f00              LSRS     r0,r0,#28
0000ca  490a              LDR      r1,|L15.244|
0000cc  7008              STRB     r0,[r1,#0]
;;;1036                if ((SerBuffer[0] & 0x0a) == 0)
0000ce  4608              MOV      r0,r1
0000d0  7800              LDRB     r0,[r0,#0]  ; SerBuffer
0000d2  210a              MOVS     r1,#0xa
0000d4  4208              TST      r0,r1
0000d6  d101              BNE      |L15.220|
;;;1037                {
;;;1038                   status = STATUS_ACCESS_DENIED;
0000d8  2404              MOVS     r4,#4
0000da  e006              B        |L15.234|
                  |L15.220|
;;;1039                }
;;;1040                else
;;;1041                {
;;;1042                   if (SerBuffer[0] == 0x0a)
0000dc  4805              LDR      r0,|L15.244|
0000de  7800              LDRB     r0,[r0,#0]  ; SerBuffer
0000e0  280a              CMP      r0,#0xa
0000e2  d101              BNE      |L15.232|
;;;1043                   {
;;;1044                      status = STATUS_SUCCESS;
0000e4  2400              MOVS     r4,#0
0000e6  e000              B        |L15.234|
                  |L15.232|
;;;1045                   }
;;;1046                   else
;;;1047                   {
;;;1048                      status = STATUS_INVALID_FORMAT;
0000e8  2403              MOVS     r4,#3
                  |L15.234|
;;;1049                   }
;;;1050                }
;;;1051             }
;;;1052          }
;;;1053       }
;;;1054     return status;
0000ea  4620              MOV      r0,r4
;;;1055   }
0000ec  bd70              POP      {r4-r6,pc}
;;;1056   
                          ENDP

0000ee  0000              DCW      0x0000
                  |L15.240|
                          DCD      MInfo
                  |L15.244|
                          DCD      SerBuffer
                  |L15.248|
                          DCD      0x00002710
                  |L15.252|
                          DCD      0x00001388

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  MInfo
                          %        10
                  SerBuffer
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  MpIsrInfo
                          DCD      0x00000000
